// This file is generated. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct AWSElasticBlockStoreVolumeSource {
    // message fields
    volumeID: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    partition: ::std::option::Option<i32>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AWSElasticBlockStoreVolumeSource {}

impl AWSElasticBlockStoreVolumeSource {
    pub fn new() -> AWSElasticBlockStoreVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AWSElasticBlockStoreVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<AWSElasticBlockStoreVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AWSElasticBlockStoreVolumeSource,
        };
        unsafe {
            instance.get(AWSElasticBlockStoreVolumeSource::new)
        }
    }

    // optional string volumeID = 1;

    pub fn clear_volumeID(&mut self) {
        self.volumeID.clear();
    }

    pub fn has_volumeID(&self) -> bool {
        self.volumeID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeID(&mut self, v: ::std::string::String) {
        self.volumeID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeID(&mut self) -> &mut ::std::string::String {
        if self.volumeID.is_none() {
            self.volumeID.set_default();
        }
        self.volumeID.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeID(&mut self) -> ::std::string::String {
        self.volumeID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volumeID(&self) -> &str {
        match self.volumeID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volumeID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volumeID
    }

    fn mut_volumeID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volumeID
    }

    // optional string fsType = 2;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }

    // optional int32 partition = 3;

    pub fn clear_partition(&mut self) {
        self.partition = ::std::option::Option::None;
    }

    pub fn has_partition(&self) -> bool {
        self.partition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition(&mut self, v: i32) {
        self.partition = ::std::option::Option::Some(v);
    }

    pub fn get_partition(&self) -> i32 {
        self.partition.unwrap_or(0)
    }

    fn get_partition_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.partition
    }

    fn mut_partition_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.partition
    }

    // optional bool readOnly = 4;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }
}

impl ::protobuf::Message for AWSElasticBlockStoreVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.partition = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumeID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.partition {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumeID.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.partition {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AWSElasticBlockStoreVolumeSource {
    fn new() -> AWSElasticBlockStoreVolumeSource {
        AWSElasticBlockStoreVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<AWSElasticBlockStoreVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volumeID",
                    AWSElasticBlockStoreVolumeSource::get_volumeID_for_reflect,
                    AWSElasticBlockStoreVolumeSource::mut_volumeID_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    AWSElasticBlockStoreVolumeSource::get_fsType_for_reflect,
                    AWSElasticBlockStoreVolumeSource::mut_fsType_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "partition",
                    AWSElasticBlockStoreVolumeSource::get_partition_for_reflect,
                    AWSElasticBlockStoreVolumeSource::mut_partition_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    AWSElasticBlockStoreVolumeSource::get_readOnly_for_reflect,
                    AWSElasticBlockStoreVolumeSource::mut_readOnly_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AWSElasticBlockStoreVolumeSource>(
                    "AWSElasticBlockStoreVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AWSElasticBlockStoreVolumeSource {
    fn clear(&mut self) {
        self.clear_volumeID();
        self.clear_fsType();
        self.clear_partition();
        self.clear_readOnly();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AWSElasticBlockStoreVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AWSElasticBlockStoreVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Affinity {
    // message fields
    nodeAffinity: ::protobuf::SingularPtrField<NodeAffinity>,
    podAffinity: ::protobuf::SingularPtrField<PodAffinity>,
    podAntiAffinity: ::protobuf::SingularPtrField<PodAntiAffinity>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Affinity {}

impl Affinity {
    pub fn new() -> Affinity {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Affinity {
        static mut instance: ::protobuf::lazy::Lazy<Affinity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Affinity,
        };
        unsafe {
            instance.get(Affinity::new)
        }
    }

    // optional .k8s.io.api.core.v1.NodeAffinity nodeAffinity = 1;

    pub fn clear_nodeAffinity(&mut self) {
        self.nodeAffinity.clear();
    }

    pub fn has_nodeAffinity(&self) -> bool {
        self.nodeAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeAffinity(&mut self, v: NodeAffinity) {
        self.nodeAffinity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeAffinity(&mut self) -> &mut NodeAffinity {
        if self.nodeAffinity.is_none() {
            self.nodeAffinity.set_default();
        }
        self.nodeAffinity.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeAffinity(&mut self) -> NodeAffinity {
        self.nodeAffinity.take().unwrap_or_else(|| NodeAffinity::new())
    }

    pub fn get_nodeAffinity(&self) -> &NodeAffinity {
        self.nodeAffinity.as_ref().unwrap_or_else(|| NodeAffinity::default_instance())
    }

    fn get_nodeAffinity_for_reflect(&self) -> &::protobuf::SingularPtrField<NodeAffinity> {
        &self.nodeAffinity
    }

    fn mut_nodeAffinity_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<NodeAffinity> {
        &mut self.nodeAffinity
    }

    // optional .k8s.io.api.core.v1.PodAffinity podAffinity = 2;

    pub fn clear_podAffinity(&mut self) {
        self.podAffinity.clear();
    }

    pub fn has_podAffinity(&self) -> bool {
        self.podAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podAffinity(&mut self, v: PodAffinity) {
        self.podAffinity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podAffinity(&mut self) -> &mut PodAffinity {
        if self.podAffinity.is_none() {
            self.podAffinity.set_default();
        }
        self.podAffinity.as_mut().unwrap()
    }

    // Take field
    pub fn take_podAffinity(&mut self) -> PodAffinity {
        self.podAffinity.take().unwrap_or_else(|| PodAffinity::new())
    }

    pub fn get_podAffinity(&self) -> &PodAffinity {
        self.podAffinity.as_ref().unwrap_or_else(|| PodAffinity::default_instance())
    }

    fn get_podAffinity_for_reflect(&self) -> &::protobuf::SingularPtrField<PodAffinity> {
        &self.podAffinity
    }

    fn mut_podAffinity_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PodAffinity> {
        &mut self.podAffinity
    }

    // optional .k8s.io.api.core.v1.PodAntiAffinity podAntiAffinity = 3;

    pub fn clear_podAntiAffinity(&mut self) {
        self.podAntiAffinity.clear();
    }

    pub fn has_podAntiAffinity(&self) -> bool {
        self.podAntiAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podAntiAffinity(&mut self, v: PodAntiAffinity) {
        self.podAntiAffinity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podAntiAffinity(&mut self) -> &mut PodAntiAffinity {
        if self.podAntiAffinity.is_none() {
            self.podAntiAffinity.set_default();
        }
        self.podAntiAffinity.as_mut().unwrap()
    }

    // Take field
    pub fn take_podAntiAffinity(&mut self) -> PodAntiAffinity {
        self.podAntiAffinity.take().unwrap_or_else(|| PodAntiAffinity::new())
    }

    pub fn get_podAntiAffinity(&self) -> &PodAntiAffinity {
        self.podAntiAffinity.as_ref().unwrap_or_else(|| PodAntiAffinity::default_instance())
    }

    fn get_podAntiAffinity_for_reflect(&self) -> &::protobuf::SingularPtrField<PodAntiAffinity> {
        &self.podAntiAffinity
    }

    fn mut_podAntiAffinity_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PodAntiAffinity> {
        &mut self.podAntiAffinity
    }
}

impl ::protobuf::Message for Affinity {
    fn is_initialized(&self) -> bool {
        for v in &self.nodeAffinity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.podAffinity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.podAntiAffinity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nodeAffinity)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.podAffinity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.podAntiAffinity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.nodeAffinity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.podAffinity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.podAntiAffinity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.nodeAffinity.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.podAffinity.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.podAntiAffinity.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Affinity {
    fn new() -> Affinity {
        Affinity::new()
    }

    fn descriptor_static(_: ::std::option::Option<Affinity>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeAffinity>>(
                    "nodeAffinity",
                    Affinity::get_nodeAffinity_for_reflect,
                    Affinity::mut_nodeAffinity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodAffinity>>(
                    "podAffinity",
                    Affinity::get_podAffinity_for_reflect,
                    Affinity::mut_podAffinity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodAntiAffinity>>(
                    "podAntiAffinity",
                    Affinity::get_podAntiAffinity_for_reflect,
                    Affinity::mut_podAntiAffinity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Affinity>(
                    "Affinity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Affinity {
    fn clear(&mut self) {
        self.clear_nodeAffinity();
        self.clear_podAffinity();
        self.clear_podAntiAffinity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Affinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Affinity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttachedVolume {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    devicePath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AttachedVolume {}

impl AttachedVolume {
    pub fn new() -> AttachedVolume {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AttachedVolume {
        static mut instance: ::protobuf::lazy::Lazy<AttachedVolume> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttachedVolume,
        };
        unsafe {
            instance.get(AttachedVolume::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string devicePath = 2;

    pub fn clear_devicePath(&mut self) {
        self.devicePath.clear();
    }

    pub fn has_devicePath(&self) -> bool {
        self.devicePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_devicePath(&mut self, v: ::std::string::String) {
        self.devicePath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_devicePath(&mut self) -> &mut ::std::string::String {
        if self.devicePath.is_none() {
            self.devicePath.set_default();
        }
        self.devicePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_devicePath(&mut self) -> ::std::string::String {
        self.devicePath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_devicePath(&self) -> &str {
        match self.devicePath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_devicePath_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.devicePath
    }

    fn mut_devicePath_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.devicePath
    }
}

impl ::protobuf::Message for AttachedVolume {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.devicePath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.devicePath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.devicePath.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AttachedVolume {
    fn new() -> AttachedVolume {
        AttachedVolume::new()
    }

    fn descriptor_static(_: ::std::option::Option<AttachedVolume>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    AttachedVolume::get_name_for_reflect,
                    AttachedVolume::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "devicePath",
                    AttachedVolume::get_devicePath_for_reflect,
                    AttachedVolume::mut_devicePath_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttachedVolume>(
                    "AttachedVolume",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AttachedVolume {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_devicePath();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttachedVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttachedVolume {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AvoidPods {
    // message fields
    preferAvoidPods: ::protobuf::RepeatedField<PreferAvoidPodsEntry>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AvoidPods {}

impl AvoidPods {
    pub fn new() -> AvoidPods {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AvoidPods {
        static mut instance: ::protobuf::lazy::Lazy<AvoidPods> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AvoidPods,
        };
        unsafe {
            instance.get(AvoidPods::new)
        }
    }

    // repeated .k8s.io.api.core.v1.PreferAvoidPodsEntry preferAvoidPods = 1;

    pub fn clear_preferAvoidPods(&mut self) {
        self.preferAvoidPods.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferAvoidPods(&mut self, v: ::protobuf::RepeatedField<PreferAvoidPodsEntry>) {
        self.preferAvoidPods = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferAvoidPods(&mut self) -> &mut ::protobuf::RepeatedField<PreferAvoidPodsEntry> {
        &mut self.preferAvoidPods
    }

    // Take field
    pub fn take_preferAvoidPods(&mut self) -> ::protobuf::RepeatedField<PreferAvoidPodsEntry> {
        ::std::mem::replace(&mut self.preferAvoidPods, ::protobuf::RepeatedField::new())
    }

    pub fn get_preferAvoidPods(&self) -> &[PreferAvoidPodsEntry] {
        &self.preferAvoidPods
    }

    fn get_preferAvoidPods_for_reflect(&self) -> &::protobuf::RepeatedField<PreferAvoidPodsEntry> {
        &self.preferAvoidPods
    }

    fn mut_preferAvoidPods_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<PreferAvoidPodsEntry> {
        &mut self.preferAvoidPods
    }
}

impl ::protobuf::Message for AvoidPods {
    fn is_initialized(&self) -> bool {
        for v in &self.preferAvoidPods {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preferAvoidPods)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.preferAvoidPods {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.preferAvoidPods {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AvoidPods {
    fn new() -> AvoidPods {
        AvoidPods::new()
    }

    fn descriptor_static(_: ::std::option::Option<AvoidPods>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PreferAvoidPodsEntry>>(
                    "preferAvoidPods",
                    AvoidPods::get_preferAvoidPods_for_reflect,
                    AvoidPods::mut_preferAvoidPods_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AvoidPods>(
                    "AvoidPods",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AvoidPods {
    fn clear(&mut self) {
        self.clear_preferAvoidPods();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AvoidPods {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvoidPods {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AzureDiskVolumeSource {
    // message fields
    diskName: ::protobuf::SingularField<::std::string::String>,
    diskURI: ::protobuf::SingularField<::std::string::String>,
    cachingMode: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    kind: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AzureDiskVolumeSource {}

impl AzureDiskVolumeSource {
    pub fn new() -> AzureDiskVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AzureDiskVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<AzureDiskVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AzureDiskVolumeSource,
        };
        unsafe {
            instance.get(AzureDiskVolumeSource::new)
        }
    }

    // optional string diskName = 1;

    pub fn clear_diskName(&mut self) {
        self.diskName.clear();
    }

    pub fn has_diskName(&self) -> bool {
        self.diskName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diskName(&mut self, v: ::std::string::String) {
        self.diskName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diskName(&mut self) -> &mut ::std::string::String {
        if self.diskName.is_none() {
            self.diskName.set_default();
        }
        self.diskName.as_mut().unwrap()
    }

    // Take field
    pub fn take_diskName(&mut self) -> ::std::string::String {
        self.diskName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_diskName(&self) -> &str {
        match self.diskName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_diskName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.diskName
    }

    fn mut_diskName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.diskName
    }

    // optional string diskURI = 2;

    pub fn clear_diskURI(&mut self) {
        self.diskURI.clear();
    }

    pub fn has_diskURI(&self) -> bool {
        self.diskURI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diskURI(&mut self, v: ::std::string::String) {
        self.diskURI = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diskURI(&mut self) -> &mut ::std::string::String {
        if self.diskURI.is_none() {
            self.diskURI.set_default();
        }
        self.diskURI.as_mut().unwrap()
    }

    // Take field
    pub fn take_diskURI(&mut self) -> ::std::string::String {
        self.diskURI.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_diskURI(&self) -> &str {
        match self.diskURI.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_diskURI_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.diskURI
    }

    fn mut_diskURI_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.diskURI
    }

    // optional string cachingMode = 3;

    pub fn clear_cachingMode(&mut self) {
        self.cachingMode.clear();
    }

    pub fn has_cachingMode(&self) -> bool {
        self.cachingMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cachingMode(&mut self, v: ::std::string::String) {
        self.cachingMode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cachingMode(&mut self) -> &mut ::std::string::String {
        if self.cachingMode.is_none() {
            self.cachingMode.set_default();
        }
        self.cachingMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_cachingMode(&mut self) -> ::std::string::String {
        self.cachingMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_cachingMode(&self) -> &str {
        match self.cachingMode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_cachingMode_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.cachingMode
    }

    fn mut_cachingMode_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.cachingMode
    }

    // optional string fsType = 4;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }

    // optional bool readOnly = 5;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }

    // optional string kind = 6;

    pub fn clear_kind(&mut self) {
        self.kind.clear();
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind.set_default();
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_kind_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.kind
    }

    fn mut_kind_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.kind
    }
}

impl ::protobuf::Message for AzureDiskVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.diskName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.diskURI)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cachingMode)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kind)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.diskName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.diskURI.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.cachingMode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.diskName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.diskURI.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.cachingMode.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.kind.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AzureDiskVolumeSource {
    fn new() -> AzureDiskVolumeSource {
        AzureDiskVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<AzureDiskVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "diskName",
                    AzureDiskVolumeSource::get_diskName_for_reflect,
                    AzureDiskVolumeSource::mut_diskName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "diskURI",
                    AzureDiskVolumeSource::get_diskURI_for_reflect,
                    AzureDiskVolumeSource::mut_diskURI_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "cachingMode",
                    AzureDiskVolumeSource::get_cachingMode_for_reflect,
                    AzureDiskVolumeSource::mut_cachingMode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    AzureDiskVolumeSource::get_fsType_for_reflect,
                    AzureDiskVolumeSource::mut_fsType_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    AzureDiskVolumeSource::get_readOnly_for_reflect,
                    AzureDiskVolumeSource::mut_readOnly_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kind",
                    AzureDiskVolumeSource::get_kind_for_reflect,
                    AzureDiskVolumeSource::mut_kind_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AzureDiskVolumeSource>(
                    "AzureDiskVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AzureDiskVolumeSource {
    fn clear(&mut self) {
        self.clear_diskName();
        self.clear_diskURI();
        self.clear_cachingMode();
        self.clear_fsType();
        self.clear_readOnly();
        self.clear_kind();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AzureDiskVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AzureDiskVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AzureFileVolumeSource {
    // message fields
    secretName: ::protobuf::SingularField<::std::string::String>,
    shareName: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AzureFileVolumeSource {}

impl AzureFileVolumeSource {
    pub fn new() -> AzureFileVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AzureFileVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<AzureFileVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AzureFileVolumeSource,
        };
        unsafe {
            instance.get(AzureFileVolumeSource::new)
        }
    }

    // optional string secretName = 1;

    pub fn clear_secretName(&mut self) {
        self.secretName.clear();
    }

    pub fn has_secretName(&self) -> bool {
        self.secretName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretName(&mut self, v: ::std::string::String) {
        self.secretName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretName(&mut self) -> &mut ::std::string::String {
        if self.secretName.is_none() {
            self.secretName.set_default();
        }
        self.secretName.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretName(&mut self) -> ::std::string::String {
        self.secretName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_secretName(&self) -> &str {
        match self.secretName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_secretName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.secretName
    }

    fn mut_secretName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.secretName
    }

    // optional string shareName = 2;

    pub fn clear_shareName(&mut self) {
        self.shareName.clear();
    }

    pub fn has_shareName(&self) -> bool {
        self.shareName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shareName(&mut self, v: ::std::string::String) {
        self.shareName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shareName(&mut self) -> &mut ::std::string::String {
        if self.shareName.is_none() {
            self.shareName.set_default();
        }
        self.shareName.as_mut().unwrap()
    }

    // Take field
    pub fn take_shareName(&mut self) -> ::std::string::String {
        self.shareName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_shareName(&self) -> &str {
        match self.shareName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_shareName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.shareName
    }

    fn mut_shareName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.shareName
    }

    // optional bool readOnly = 3;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }
}

impl ::protobuf::Message for AzureFileVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secretName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shareName)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secretName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.shareName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secretName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.shareName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AzureFileVolumeSource {
    fn new() -> AzureFileVolumeSource {
        AzureFileVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<AzureFileVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "secretName",
                    AzureFileVolumeSource::get_secretName_for_reflect,
                    AzureFileVolumeSource::mut_secretName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "shareName",
                    AzureFileVolumeSource::get_shareName_for_reflect,
                    AzureFileVolumeSource::mut_shareName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    AzureFileVolumeSource::get_readOnly_for_reflect,
                    AzureFileVolumeSource::mut_readOnly_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AzureFileVolumeSource>(
                    "AzureFileVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AzureFileVolumeSource {
    fn clear(&mut self) {
        self.clear_secretName();
        self.clear_shareName();
        self.clear_readOnly();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AzureFileVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AzureFileVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Binding {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    target: ::protobuf::SingularPtrField<ObjectReference>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Binding {}

impl Binding {
    pub fn new() -> Binding {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Binding {
        static mut instance: ::protobuf::lazy::Lazy<Binding> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Binding,
        };
        unsafe {
            instance.get(Binding::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.ObjectReference target = 2;

    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ObjectReference) {
        self.target = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ObjectReference {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ObjectReference {
        self.target.take().unwrap_or_else(|| ObjectReference::new())
    }

    pub fn get_target(&self) -> &ObjectReference {
        self.target.as_ref().unwrap_or_else(|| ObjectReference::default_instance())
    }

    fn get_target_for_reflect(&self) -> &::protobuf::SingularPtrField<ObjectReference> {
        &self.target
    }

    fn mut_target_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ObjectReference> {
        &mut self.target
    }
}

impl ::protobuf::Message for Binding {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.target.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Binding {
    fn new() -> Binding {
        Binding::new()
    }

    fn descriptor_static(_: ::std::option::Option<Binding>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    Binding::get_metadata_for_reflect,
                    Binding::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                    "target",
                    Binding::get_target_for_reflect,
                    Binding::mut_target_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Binding>(
                    "Binding",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Binding {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_target();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Binding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Binding {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Capabilities {
    // message fields
    add: ::protobuf::RepeatedField<::std::string::String>,
    drop: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Capabilities {}

impl Capabilities {
    pub fn new() -> Capabilities {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Capabilities {
        static mut instance: ::protobuf::lazy::Lazy<Capabilities> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Capabilities,
        };
        unsafe {
            instance.get(Capabilities::new)
        }
    }

    // repeated string add = 1;

    pub fn clear_add(&mut self) {
        self.add.clear();
    }

    // Param is passed by value, moved
    pub fn set_add(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_add(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.add
    }

    // Take field
    pub fn take_add(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.add, ::protobuf::RepeatedField::new())
    }

    pub fn get_add(&self) -> &[::std::string::String] {
        &self.add
    }

    fn get_add_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.add
    }

    fn mut_add_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.add
    }

    // repeated string drop = 2;

    pub fn clear_drop(&mut self) {
        self.drop.clear();
    }

    // Param is passed by value, moved
    pub fn set_drop(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.drop = v;
    }

    // Mutable pointer to the field.
    pub fn mut_drop(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.drop
    }

    // Take field
    pub fn take_drop(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.drop, ::protobuf::RepeatedField::new())
    }

    pub fn get_drop(&self) -> &[::std::string::String] {
        &self.drop
    }

    fn get_drop_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.drop
    }

    fn mut_drop_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.drop
    }
}

impl ::protobuf::Message for Capabilities {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.add)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.drop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.add {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.drop {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.add {
            os.write_string(1, &v)?;
        };
        for v in &self.drop {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Capabilities {
    fn new() -> Capabilities {
        Capabilities::new()
    }

    fn descriptor_static(_: ::std::option::Option<Capabilities>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "add",
                    Capabilities::get_add_for_reflect,
                    Capabilities::mut_add_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "drop",
                    Capabilities::get_drop_for_reflect,
                    Capabilities::mut_drop_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Capabilities>(
                    "Capabilities",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Capabilities {
    fn clear(&mut self) {
        self.clear_add();
        self.clear_drop();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Capabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Capabilities {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CephFSVolumeSource {
    // message fields
    monitors: ::protobuf::RepeatedField<::std::string::String>,
    path: ::protobuf::SingularField<::std::string::String>,
    user: ::protobuf::SingularField<::std::string::String>,
    secretFile: ::protobuf::SingularField<::std::string::String>,
    secretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CephFSVolumeSource {}

impl CephFSVolumeSource {
    pub fn new() -> CephFSVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CephFSVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<CephFSVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CephFSVolumeSource,
        };
        unsafe {
            instance.get(CephFSVolumeSource::new)
        }
    }

    // repeated string monitors = 1;

    pub fn clear_monitors(&mut self) {
        self.monitors.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitors(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.monitors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_monitors(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.monitors
    }

    // Take field
    pub fn take_monitors(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.monitors, ::protobuf::RepeatedField::new())
    }

    pub fn get_monitors(&self) -> &[::std::string::String] {
        &self.monitors
    }

    fn get_monitors_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.monitors
    }

    fn mut_monitors_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.monitors
    }

    // optional string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional string user = 3;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_user_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.user
    }

    fn mut_user_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.user
    }

    // optional string secretFile = 4;

    pub fn clear_secretFile(&mut self) {
        self.secretFile.clear();
    }

    pub fn has_secretFile(&self) -> bool {
        self.secretFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretFile(&mut self, v: ::std::string::String) {
        self.secretFile = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretFile(&mut self) -> &mut ::std::string::String {
        if self.secretFile.is_none() {
            self.secretFile.set_default();
        }
        self.secretFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretFile(&mut self) -> ::std::string::String {
        self.secretFile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_secretFile(&self) -> &str {
        match self.secretFile.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_secretFile_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.secretFile
    }

    fn mut_secretFile_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.secretFile
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 5;

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    pub fn get_secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| LocalObjectReference::default_instance())
    }

    fn get_secretRef_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalObjectReference> {
        &self.secretRef
    }

    fn mut_secretRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalObjectReference> {
        &mut self.secretRef
    }

    // optional bool readOnly = 6;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }
}

impl ::protobuf::Message for CephFSVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.monitors)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secretFile)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.monitors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.secretFile.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.monitors {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.secretFile.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CephFSVolumeSource {
    fn new() -> CephFSVolumeSource {
        CephFSVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<CephFSVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "monitors",
                    CephFSVolumeSource::get_monitors_for_reflect,
                    CephFSVolumeSource::mut_monitors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    CephFSVolumeSource::get_path_for_reflect,
                    CephFSVolumeSource::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user",
                    CephFSVolumeSource::get_user_for_reflect,
                    CephFSVolumeSource::mut_user_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "secretFile",
                    CephFSVolumeSource::get_secretFile_for_reflect,
                    CephFSVolumeSource::mut_secretFile_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "secretRef",
                    CephFSVolumeSource::get_secretRef_for_reflect,
                    CephFSVolumeSource::mut_secretRef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    CephFSVolumeSource::get_readOnly_for_reflect,
                    CephFSVolumeSource::mut_readOnly_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CephFSVolumeSource>(
                    "CephFSVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CephFSVolumeSource {
    fn clear(&mut self) {
        self.clear_monitors();
        self.clear_path();
        self.clear_user();
        self.clear_secretFile();
        self.clear_secretRef();
        self.clear_readOnly();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CephFSVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CephFSVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CinderVolumeSource {
    // message fields
    volumeID: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CinderVolumeSource {}

impl CinderVolumeSource {
    pub fn new() -> CinderVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CinderVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<CinderVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CinderVolumeSource,
        };
        unsafe {
            instance.get(CinderVolumeSource::new)
        }
    }

    // optional string volumeID = 1;

    pub fn clear_volumeID(&mut self) {
        self.volumeID.clear();
    }

    pub fn has_volumeID(&self) -> bool {
        self.volumeID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeID(&mut self, v: ::std::string::String) {
        self.volumeID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeID(&mut self) -> &mut ::std::string::String {
        if self.volumeID.is_none() {
            self.volumeID.set_default();
        }
        self.volumeID.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeID(&mut self) -> ::std::string::String {
        self.volumeID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volumeID(&self) -> &str {
        match self.volumeID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volumeID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volumeID
    }

    fn mut_volumeID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volumeID
    }

    // optional string fsType = 2;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }

    // optional bool readOnly = 3;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }
}

impl ::protobuf::Message for CinderVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumeID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumeID.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CinderVolumeSource {
    fn new() -> CinderVolumeSource {
        CinderVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<CinderVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volumeID",
                    CinderVolumeSource::get_volumeID_for_reflect,
                    CinderVolumeSource::mut_volumeID_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    CinderVolumeSource::get_fsType_for_reflect,
                    CinderVolumeSource::mut_fsType_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    CinderVolumeSource::get_readOnly_for_reflect,
                    CinderVolumeSource::mut_readOnly_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CinderVolumeSource>(
                    "CinderVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CinderVolumeSource {
    fn clear(&mut self) {
        self.clear_volumeID();
        self.clear_fsType();
        self.clear_readOnly();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CinderVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CinderVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComponentCondition {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    status: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    error: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ComponentCondition {}

impl ComponentCondition {
    pub fn new() -> ComponentCondition {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ComponentCondition {
        static mut instance: ::protobuf::lazy::Lazy<ComponentCondition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ComponentCondition,
        };
        unsafe {
            instance.get(ComponentCondition::new)
        }
    }

    // optional string type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_field_type_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.field_type
    }

    // optional string status = 2;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.status
    }

    // optional string message = 3;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // optional string error = 4;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_error_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.error
    }

    fn mut_error_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.error
    }
}

impl ::protobuf::Message for ComponentCondition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ComponentCondition {
    fn new() -> ComponentCondition {
        ComponentCondition::new()
    }

    fn descriptor_static(_: ::std::option::Option<ComponentCondition>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    ComponentCondition::get_field_type_for_reflect,
                    ComponentCondition::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "status",
                    ComponentCondition::get_status_for_reflect,
                    ComponentCondition::mut_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    ComponentCondition::get_message_for_reflect,
                    ComponentCondition::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    ComponentCondition::get_error_for_reflect,
                    ComponentCondition::mut_error_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ComponentCondition>(
                    "ComponentCondition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ComponentCondition {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_status();
        self.clear_message();
        self.clear_error();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComponentCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComponentStatus {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    conditions: ::protobuf::RepeatedField<ComponentCondition>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ComponentStatus {}

impl ComponentStatus {
    pub fn new() -> ComponentStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ComponentStatus {
        static mut instance: ::protobuf::lazy::Lazy<ComponentStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ComponentStatus,
        };
        unsafe {
            instance.get(ComponentStatus::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.ComponentCondition conditions = 2;

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<ComponentCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<ComponentCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<ComponentCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }

    pub fn get_conditions(&self) -> &[ComponentCondition] {
        &self.conditions
    }

    fn get_conditions_for_reflect(&self) -> &::protobuf::RepeatedField<ComponentCondition> {
        &self.conditions
    }

    fn mut_conditions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ComponentCondition> {
        &mut self.conditions
    }
}

impl ::protobuf::Message for ComponentStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.conditions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ComponentStatus {
    fn new() -> ComponentStatus {
        ComponentStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<ComponentStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    ComponentStatus::get_metadata_for_reflect,
                    ComponentStatus::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ComponentCondition>>(
                    "conditions",
                    ComponentStatus::get_conditions_for_reflect,
                    ComponentStatus::mut_conditions_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ComponentStatus>(
                    "ComponentStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ComponentStatus {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_conditions();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComponentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComponentStatusList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<ComponentStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ComponentStatusList {}

impl ComponentStatusList {
    pub fn new() -> ComponentStatusList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ComponentStatusList {
        static mut instance: ::protobuf::lazy::Lazy<ComponentStatusList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ComponentStatusList,
        };
        unsafe {
            instance.get(ComponentStatusList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.ComponentStatus items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ComponentStatus>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ComponentStatus> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ComponentStatus> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[ComponentStatus] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<ComponentStatus> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ComponentStatus> {
        &mut self.items
    }
}

impl ::protobuf::Message for ComponentStatusList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ComponentStatusList {
    fn new() -> ComponentStatusList {
        ComponentStatusList::new()
    }

    fn descriptor_static(_: ::std::option::Option<ComponentStatusList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    ComponentStatusList::get_metadata_for_reflect,
                    ComponentStatusList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ComponentStatus>>(
                    "items",
                    ComponentStatusList::get_items_for_reflect,
                    ComponentStatusList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ComponentStatusList>(
                    "ComponentStatusList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ComponentStatusList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComponentStatusList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentStatusList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigMap {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    pub data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ConfigMap {}

impl ConfigMap {
    pub fn new() -> ConfigMap {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ConfigMap {
        static mut instance: ::protobuf::lazy::Lazy<ConfigMap> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfigMap,
        };
        unsafe {
            instance.get(ConfigMap::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.ConfigMap.DataEntry data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.data, ::std::collections::HashMap::new())
    }

    pub fn get_data(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.data
    }

    fn get_data_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.data
    }
}

impl ::protobuf::Message for ConfigMap {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.data);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.data, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ConfigMap {
    fn new() -> ConfigMap {
        ConfigMap::new()
    }

    fn descriptor_static(_: ::std::option::Option<ConfigMap>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    ConfigMap::get_metadata_for_reflect,
                    ConfigMap::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "data",
                    ConfigMap::get_data_for_reflect,
                    ConfigMap::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfigMap>(
                    "ConfigMap",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ConfigMap {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMap {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigMapEnvSource {
    // message fields
    localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    optional: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ConfigMapEnvSource {}

impl ConfigMapEnvSource {
    pub fn new() -> ConfigMapEnvSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ConfigMapEnvSource {
        static mut instance: ::protobuf::lazy::Lazy<ConfigMapEnvSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfigMapEnvSource,
        };
        unsafe {
            instance.get(ConfigMapEnvSource::new)
        }
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| LocalObjectReference::default_instance())
    }

    fn get_localObjectReference_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalObjectReference> {
        &self.localObjectReference
    }

    fn mut_localObjectReference_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalObjectReference> {
        &mut self.localObjectReference
    }

    // optional bool optional = 2;

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    fn get_optional_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.optional
    }

    fn mut_optional_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.optional
    }
}

impl ::protobuf::Message for ConfigMapEnvSource {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ConfigMapEnvSource {
    fn new() -> ConfigMapEnvSource {
        ConfigMapEnvSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<ConfigMapEnvSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "localObjectReference",
                    ConfigMapEnvSource::get_localObjectReference_for_reflect,
                    ConfigMapEnvSource::mut_localObjectReference_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "optional",
                    ConfigMapEnvSource::get_optional_for_reflect,
                    ConfigMapEnvSource::mut_optional_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfigMapEnvSource>(
                    "ConfigMapEnvSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ConfigMapEnvSource {
    fn clear(&mut self) {
        self.clear_localObjectReference();
        self.clear_optional();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigMapEnvSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapEnvSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigMapKeySelector {
    // message fields
    localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    key: ::protobuf::SingularField<::std::string::String>,
    optional: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ConfigMapKeySelector {}

impl ConfigMapKeySelector {
    pub fn new() -> ConfigMapKeySelector {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ConfigMapKeySelector {
        static mut instance: ::protobuf::lazy::Lazy<ConfigMapKeySelector> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfigMapKeySelector,
        };
        unsafe {
            instance.get(ConfigMapKeySelector::new)
        }
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| LocalObjectReference::default_instance())
    }

    fn get_localObjectReference_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalObjectReference> {
        &self.localObjectReference
    }

    fn mut_localObjectReference_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalObjectReference> {
        &mut self.localObjectReference
    }

    // optional string key = 2;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_key_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.key
    }

    fn mut_key_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.key
    }

    // optional bool optional = 3;

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    fn get_optional_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.optional
    }

    fn mut_optional_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.optional
    }
}

impl ::protobuf::Message for ConfigMapKeySelector {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ConfigMapKeySelector {
    fn new() -> ConfigMapKeySelector {
        ConfigMapKeySelector::new()
    }

    fn descriptor_static(_: ::std::option::Option<ConfigMapKeySelector>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "localObjectReference",
                    ConfigMapKeySelector::get_localObjectReference_for_reflect,
                    ConfigMapKeySelector::mut_localObjectReference_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    ConfigMapKeySelector::get_key_for_reflect,
                    ConfigMapKeySelector::mut_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "optional",
                    ConfigMapKeySelector::get_optional_for_reflect,
                    ConfigMapKeySelector::mut_optional_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfigMapKeySelector>(
                    "ConfigMapKeySelector",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ConfigMapKeySelector {
    fn clear(&mut self) {
        self.clear_localObjectReference();
        self.clear_key();
        self.clear_optional();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigMapKeySelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapKeySelector {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigMapList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<ConfigMap>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ConfigMapList {}

impl ConfigMapList {
    pub fn new() -> ConfigMapList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ConfigMapList {
        static mut instance: ::protobuf::lazy::Lazy<ConfigMapList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfigMapList,
        };
        unsafe {
            instance.get(ConfigMapList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.ConfigMap items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ConfigMap>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ConfigMap> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ConfigMap> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[ConfigMap] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<ConfigMap> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ConfigMap> {
        &mut self.items
    }
}

impl ::protobuf::Message for ConfigMapList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ConfigMapList {
    fn new() -> ConfigMapList {
        ConfigMapList::new()
    }

    fn descriptor_static(_: ::std::option::Option<ConfigMapList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    ConfigMapList::get_metadata_for_reflect,
                    ConfigMapList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigMap>>(
                    "items",
                    ConfigMapList::get_items_for_reflect,
                    ConfigMapList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfigMapList>(
                    "ConfigMapList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ConfigMapList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigMapList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigMapProjection {
    // message fields
    localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    items: ::protobuf::RepeatedField<KeyToPath>,
    optional: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ConfigMapProjection {}

impl ConfigMapProjection {
    pub fn new() -> ConfigMapProjection {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ConfigMapProjection {
        static mut instance: ::protobuf::lazy::Lazy<ConfigMapProjection> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfigMapProjection,
        };
        unsafe {
            instance.get(ConfigMapProjection::new)
        }
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| LocalObjectReference::default_instance())
    }

    fn get_localObjectReference_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalObjectReference> {
        &self.localObjectReference
    }

    fn mut_localObjectReference_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalObjectReference> {
        &mut self.localObjectReference
    }

    // repeated .k8s.io.api.core.v1.KeyToPath items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<KeyToPath>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<KeyToPath> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<KeyToPath> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[KeyToPath] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<KeyToPath> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<KeyToPath> {
        &mut self.items
    }

    // optional bool optional = 4;

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    fn get_optional_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.optional
    }

    fn mut_optional_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.optional
    }
}

impl ::protobuf::Message for ConfigMapProjection {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.optional {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ConfigMapProjection {
    fn new() -> ConfigMapProjection {
        ConfigMapProjection::new()
    }

    fn descriptor_static(_: ::std::option::Option<ConfigMapProjection>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "localObjectReference",
                    ConfigMapProjection::get_localObjectReference_for_reflect,
                    ConfigMapProjection::mut_localObjectReference_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyToPath>>(
                    "items",
                    ConfigMapProjection::get_items_for_reflect,
                    ConfigMapProjection::mut_items_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "optional",
                    ConfigMapProjection::get_optional_for_reflect,
                    ConfigMapProjection::mut_optional_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfigMapProjection>(
                    "ConfigMapProjection",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ConfigMapProjection {
    fn clear(&mut self) {
        self.clear_localObjectReference();
        self.clear_items();
        self.clear_optional();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigMapProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapProjection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigMapVolumeSource {
    // message fields
    localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    items: ::protobuf::RepeatedField<KeyToPath>,
    defaultMode: ::std::option::Option<i32>,
    optional: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ConfigMapVolumeSource {}

impl ConfigMapVolumeSource {
    pub fn new() -> ConfigMapVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ConfigMapVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<ConfigMapVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConfigMapVolumeSource,
        };
        unsafe {
            instance.get(ConfigMapVolumeSource::new)
        }
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| LocalObjectReference::default_instance())
    }

    fn get_localObjectReference_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalObjectReference> {
        &self.localObjectReference
    }

    fn mut_localObjectReference_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalObjectReference> {
        &mut self.localObjectReference
    }

    // repeated .k8s.io.api.core.v1.KeyToPath items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<KeyToPath>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<KeyToPath> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<KeyToPath> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[KeyToPath] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<KeyToPath> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<KeyToPath> {
        &mut self.items
    }

    // optional int32 defaultMode = 3;

    pub fn clear_defaultMode(&mut self) {
        self.defaultMode = ::std::option::Option::None;
    }

    pub fn has_defaultMode(&self) -> bool {
        self.defaultMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultMode(&mut self, v: i32) {
        self.defaultMode = ::std::option::Option::Some(v);
    }

    pub fn get_defaultMode(&self) -> i32 {
        self.defaultMode.unwrap_or(0)
    }

    fn get_defaultMode_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.defaultMode
    }

    fn mut_defaultMode_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.defaultMode
    }

    // optional bool optional = 4;

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    fn get_optional_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.optional
    }

    fn mut_optional_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.optional
    }
}

impl ::protobuf::Message for ConfigMapVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.defaultMode = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.defaultMode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.defaultMode {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ConfigMapVolumeSource {
    fn new() -> ConfigMapVolumeSource {
        ConfigMapVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<ConfigMapVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "localObjectReference",
                    ConfigMapVolumeSource::get_localObjectReference_for_reflect,
                    ConfigMapVolumeSource::mut_localObjectReference_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyToPath>>(
                    "items",
                    ConfigMapVolumeSource::get_items_for_reflect,
                    ConfigMapVolumeSource::mut_items_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "defaultMode",
                    ConfigMapVolumeSource::get_defaultMode_for_reflect,
                    ConfigMapVolumeSource::mut_defaultMode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "optional",
                    ConfigMapVolumeSource::get_optional_for_reflect,
                    ConfigMapVolumeSource::mut_optional_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConfigMapVolumeSource>(
                    "ConfigMapVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ConfigMapVolumeSource {
    fn clear(&mut self) {
        self.clear_localObjectReference();
        self.clear_items();
        self.clear_defaultMode();
        self.clear_optional();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigMapVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Container {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    image: ::protobuf::SingularField<::std::string::String>,
    command: ::protobuf::RepeatedField<::std::string::String>,
    args: ::protobuf::RepeatedField<::std::string::String>,
    workingDir: ::protobuf::SingularField<::std::string::String>,
    ports: ::protobuf::RepeatedField<ContainerPort>,
    envFrom: ::protobuf::RepeatedField<EnvFromSource>,
    env: ::protobuf::RepeatedField<EnvVar>,
    resources: ::protobuf::SingularPtrField<ResourceRequirements>,
    volumeMounts: ::protobuf::RepeatedField<VolumeMount>,
    livenessProbe: ::protobuf::SingularPtrField<Probe>,
    readinessProbe: ::protobuf::SingularPtrField<Probe>,
    lifecycle: ::protobuf::SingularPtrField<Lifecycle>,
    terminationMessagePath: ::protobuf::SingularField<::std::string::String>,
    terminationMessagePolicy: ::protobuf::SingularField<::std::string::String>,
    imagePullPolicy: ::protobuf::SingularField<::std::string::String>,
    securityContext: ::protobuf::SingularPtrField<SecurityContext>,
    stdin: ::std::option::Option<bool>,
    stdinOnce: ::std::option::Option<bool>,
    tty: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Container {}

impl Container {
    pub fn new() -> Container {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Container {
        static mut instance: ::protobuf::lazy::Lazy<Container> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Container,
        };
        unsafe {
            instance.get(Container::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string image = 2;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_image_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.image
    }

    fn mut_image_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.image
    }

    // repeated string command = 3;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    pub fn get_command(&self) -> &[::std::string::String] {
        &self.command
    }

    fn get_command_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.command
    }

    fn mut_command_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }

    // repeated string args = 4;

    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    pub fn get_args(&self) -> &[::std::string::String] {
        &self.args
    }

    fn get_args_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.args
    }

    fn mut_args_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.args
    }

    // optional string workingDir = 5;

    pub fn clear_workingDir(&mut self) {
        self.workingDir.clear();
    }

    pub fn has_workingDir(&self) -> bool {
        self.workingDir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workingDir(&mut self, v: ::std::string::String) {
        self.workingDir = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workingDir(&mut self) -> &mut ::std::string::String {
        if self.workingDir.is_none() {
            self.workingDir.set_default();
        }
        self.workingDir.as_mut().unwrap()
    }

    // Take field
    pub fn take_workingDir(&mut self) -> ::std::string::String {
        self.workingDir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_workingDir(&self) -> &str {
        match self.workingDir.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_workingDir_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.workingDir
    }

    fn mut_workingDir_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.workingDir
    }

    // repeated .k8s.io.api.core.v1.ContainerPort ports = 6;

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::protobuf::RepeatedField<ContainerPort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::protobuf::RepeatedField<ContainerPort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::protobuf::RepeatedField<ContainerPort> {
        ::std::mem::replace(&mut self.ports, ::protobuf::RepeatedField::new())
    }

    pub fn get_ports(&self) -> &[ContainerPort] {
        &self.ports
    }

    fn get_ports_for_reflect(&self) -> &::protobuf::RepeatedField<ContainerPort> {
        &self.ports
    }

    fn mut_ports_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ContainerPort> {
        &mut self.ports
    }

    // repeated .k8s.io.api.core.v1.EnvFromSource envFrom = 19;

    pub fn clear_envFrom(&mut self) {
        self.envFrom.clear();
    }

    // Param is passed by value, moved
    pub fn set_envFrom(&mut self, v: ::protobuf::RepeatedField<EnvFromSource>) {
        self.envFrom = v;
    }

    // Mutable pointer to the field.
    pub fn mut_envFrom(&mut self) -> &mut ::protobuf::RepeatedField<EnvFromSource> {
        &mut self.envFrom
    }

    // Take field
    pub fn take_envFrom(&mut self) -> ::protobuf::RepeatedField<EnvFromSource> {
        ::std::mem::replace(&mut self.envFrom, ::protobuf::RepeatedField::new())
    }

    pub fn get_envFrom(&self) -> &[EnvFromSource] {
        &self.envFrom
    }

    fn get_envFrom_for_reflect(&self) -> &::protobuf::RepeatedField<EnvFromSource> {
        &self.envFrom
    }

    fn mut_envFrom_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<EnvFromSource> {
        &mut self.envFrom
    }

    // repeated .k8s.io.api.core.v1.EnvVar env = 7;

    pub fn clear_env(&mut self) {
        self.env.clear();
    }

    // Param is passed by value, moved
    pub fn set_env(&mut self, v: ::protobuf::RepeatedField<EnvVar>) {
        self.env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_env(&mut self) -> &mut ::protobuf::RepeatedField<EnvVar> {
        &mut self.env
    }

    // Take field
    pub fn take_env(&mut self) -> ::protobuf::RepeatedField<EnvVar> {
        ::std::mem::replace(&mut self.env, ::protobuf::RepeatedField::new())
    }

    pub fn get_env(&self) -> &[EnvVar] {
        &self.env
    }

    fn get_env_for_reflect(&self) -> &::protobuf::RepeatedField<EnvVar> {
        &self.env
    }

    fn mut_env_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<EnvVar> {
        &mut self.env
    }

    // optional .k8s.io.api.core.v1.ResourceRequirements resources = 8;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ResourceRequirements) {
        self.resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut ResourceRequirements {
        if self.resources.is_none() {
            self.resources.set_default();
        }
        self.resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_resources(&mut self) -> ResourceRequirements {
        self.resources.take().unwrap_or_else(|| ResourceRequirements::new())
    }

    pub fn get_resources(&self) -> &ResourceRequirements {
        self.resources.as_ref().unwrap_or_else(|| ResourceRequirements::default_instance())
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::SingularPtrField<ResourceRequirements> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ResourceRequirements> {
        &mut self.resources
    }

    // repeated .k8s.io.api.core.v1.VolumeMount volumeMounts = 9;

    pub fn clear_volumeMounts(&mut self) {
        self.volumeMounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeMounts(&mut self, v: ::protobuf::RepeatedField<VolumeMount>) {
        self.volumeMounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeMounts(&mut self) -> &mut ::protobuf::RepeatedField<VolumeMount> {
        &mut self.volumeMounts
    }

    // Take field
    pub fn take_volumeMounts(&mut self) -> ::protobuf::RepeatedField<VolumeMount> {
        ::std::mem::replace(&mut self.volumeMounts, ::protobuf::RepeatedField::new())
    }

    pub fn get_volumeMounts(&self) -> &[VolumeMount] {
        &self.volumeMounts
    }

    fn get_volumeMounts_for_reflect(&self) -> &::protobuf::RepeatedField<VolumeMount> {
        &self.volumeMounts
    }

    fn mut_volumeMounts_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<VolumeMount> {
        &mut self.volumeMounts
    }

    // optional .k8s.io.api.core.v1.Probe livenessProbe = 10;

    pub fn clear_livenessProbe(&mut self) {
        self.livenessProbe.clear();
    }

    pub fn has_livenessProbe(&self) -> bool {
        self.livenessProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_livenessProbe(&mut self, v: Probe) {
        self.livenessProbe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_livenessProbe(&mut self) -> &mut Probe {
        if self.livenessProbe.is_none() {
            self.livenessProbe.set_default();
        }
        self.livenessProbe.as_mut().unwrap()
    }

    // Take field
    pub fn take_livenessProbe(&mut self) -> Probe {
        self.livenessProbe.take().unwrap_or_else(|| Probe::new())
    }

    pub fn get_livenessProbe(&self) -> &Probe {
        self.livenessProbe.as_ref().unwrap_or_else(|| Probe::default_instance())
    }

    fn get_livenessProbe_for_reflect(&self) -> &::protobuf::SingularPtrField<Probe> {
        &self.livenessProbe
    }

    fn mut_livenessProbe_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Probe> {
        &mut self.livenessProbe
    }

    // optional .k8s.io.api.core.v1.Probe readinessProbe = 11;

    pub fn clear_readinessProbe(&mut self) {
        self.readinessProbe.clear();
    }

    pub fn has_readinessProbe(&self) -> bool {
        self.readinessProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readinessProbe(&mut self, v: Probe) {
        self.readinessProbe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readinessProbe(&mut self) -> &mut Probe {
        if self.readinessProbe.is_none() {
            self.readinessProbe.set_default();
        }
        self.readinessProbe.as_mut().unwrap()
    }

    // Take field
    pub fn take_readinessProbe(&mut self) -> Probe {
        self.readinessProbe.take().unwrap_or_else(|| Probe::new())
    }

    pub fn get_readinessProbe(&self) -> &Probe {
        self.readinessProbe.as_ref().unwrap_or_else(|| Probe::default_instance())
    }

    fn get_readinessProbe_for_reflect(&self) -> &::protobuf::SingularPtrField<Probe> {
        &self.readinessProbe
    }

    fn mut_readinessProbe_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Probe> {
        &mut self.readinessProbe
    }

    // optional .k8s.io.api.core.v1.Lifecycle lifecycle = 12;

    pub fn clear_lifecycle(&mut self) {
        self.lifecycle.clear();
    }

    pub fn has_lifecycle(&self) -> bool {
        self.lifecycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifecycle(&mut self, v: Lifecycle) {
        self.lifecycle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lifecycle(&mut self) -> &mut Lifecycle {
        if self.lifecycle.is_none() {
            self.lifecycle.set_default();
        }
        self.lifecycle.as_mut().unwrap()
    }

    // Take field
    pub fn take_lifecycle(&mut self) -> Lifecycle {
        self.lifecycle.take().unwrap_or_else(|| Lifecycle::new())
    }

    pub fn get_lifecycle(&self) -> &Lifecycle {
        self.lifecycle.as_ref().unwrap_or_else(|| Lifecycle::default_instance())
    }

    fn get_lifecycle_for_reflect(&self) -> &::protobuf::SingularPtrField<Lifecycle> {
        &self.lifecycle
    }

    fn mut_lifecycle_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Lifecycle> {
        &mut self.lifecycle
    }

    // optional string terminationMessagePath = 13;

    pub fn clear_terminationMessagePath(&mut self) {
        self.terminationMessagePath.clear();
    }

    pub fn has_terminationMessagePath(&self) -> bool {
        self.terminationMessagePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationMessagePath(&mut self, v: ::std::string::String) {
        self.terminationMessagePath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminationMessagePath(&mut self) -> &mut ::std::string::String {
        if self.terminationMessagePath.is_none() {
            self.terminationMessagePath.set_default();
        }
        self.terminationMessagePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_terminationMessagePath(&mut self) -> ::std::string::String {
        self.terminationMessagePath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_terminationMessagePath(&self) -> &str {
        match self.terminationMessagePath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_terminationMessagePath_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.terminationMessagePath
    }

    fn mut_terminationMessagePath_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.terminationMessagePath
    }

    // optional string terminationMessagePolicy = 20;

    pub fn clear_terminationMessagePolicy(&mut self) {
        self.terminationMessagePolicy.clear();
    }

    pub fn has_terminationMessagePolicy(&self) -> bool {
        self.terminationMessagePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationMessagePolicy(&mut self, v: ::std::string::String) {
        self.terminationMessagePolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminationMessagePolicy(&mut self) -> &mut ::std::string::String {
        if self.terminationMessagePolicy.is_none() {
            self.terminationMessagePolicy.set_default();
        }
        self.terminationMessagePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_terminationMessagePolicy(&mut self) -> ::std::string::String {
        self.terminationMessagePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_terminationMessagePolicy(&self) -> &str {
        match self.terminationMessagePolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_terminationMessagePolicy_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.terminationMessagePolicy
    }

    fn mut_terminationMessagePolicy_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.terminationMessagePolicy
    }

    // optional string imagePullPolicy = 14;

    pub fn clear_imagePullPolicy(&mut self) {
        self.imagePullPolicy.clear();
    }

    pub fn has_imagePullPolicy(&self) -> bool {
        self.imagePullPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imagePullPolicy(&mut self, v: ::std::string::String) {
        self.imagePullPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_imagePullPolicy(&mut self) -> &mut ::std::string::String {
        if self.imagePullPolicy.is_none() {
            self.imagePullPolicy.set_default();
        }
        self.imagePullPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_imagePullPolicy(&mut self) -> ::std::string::String {
        self.imagePullPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_imagePullPolicy(&self) -> &str {
        match self.imagePullPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_imagePullPolicy_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.imagePullPolicy
    }

    fn mut_imagePullPolicy_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.imagePullPolicy
    }

    // optional .k8s.io.api.core.v1.SecurityContext securityContext = 15;

    pub fn clear_securityContext(&mut self) {
        self.securityContext.clear();
    }

    pub fn has_securityContext(&self) -> bool {
        self.securityContext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_securityContext(&mut self, v: SecurityContext) {
        self.securityContext = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_securityContext(&mut self) -> &mut SecurityContext {
        if self.securityContext.is_none() {
            self.securityContext.set_default();
        }
        self.securityContext.as_mut().unwrap()
    }

    // Take field
    pub fn take_securityContext(&mut self) -> SecurityContext {
        self.securityContext.take().unwrap_or_else(|| SecurityContext::new())
    }

    pub fn get_securityContext(&self) -> &SecurityContext {
        self.securityContext.as_ref().unwrap_or_else(|| SecurityContext::default_instance())
    }

    fn get_securityContext_for_reflect(&self) -> &::protobuf::SingularPtrField<SecurityContext> {
        &self.securityContext
    }

    fn mut_securityContext_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<SecurityContext> {
        &mut self.securityContext
    }

    // optional bool stdin = 16;

    pub fn clear_stdin(&mut self) {
        self.stdin = ::std::option::Option::None;
    }

    pub fn has_stdin(&self) -> bool {
        self.stdin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = ::std::option::Option::Some(v);
    }

    pub fn get_stdin(&self) -> bool {
        self.stdin.unwrap_or(false)
    }

    fn get_stdin_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.stdin
    }

    fn mut_stdin_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.stdin
    }

    // optional bool stdinOnce = 17;

    pub fn clear_stdinOnce(&mut self) {
        self.stdinOnce = ::std::option::Option::None;
    }

    pub fn has_stdinOnce(&self) -> bool {
        self.stdinOnce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdinOnce(&mut self, v: bool) {
        self.stdinOnce = ::std::option::Option::Some(v);
    }

    pub fn get_stdinOnce(&self) -> bool {
        self.stdinOnce.unwrap_or(false)
    }

    fn get_stdinOnce_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.stdinOnce
    }

    fn mut_stdinOnce_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.stdinOnce
    }

    // optional bool tty = 18;

    pub fn clear_tty(&mut self) {
        self.tty = ::std::option::Option::None;
    }

    pub fn has_tty(&self) -> bool {
        self.tty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = ::std::option::Option::Some(v);
    }

    pub fn get_tty(&self) -> bool {
        self.tty.unwrap_or(false)
    }

    fn get_tty_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.tty
    }

    fn mut_tty_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.tty
    }
}

impl ::protobuf::Message for Container {
    fn is_initialized(&self) -> bool {
        for v in &self.ports {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.envFrom {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.env {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.volumeMounts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.livenessProbe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readinessProbe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lifecycle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.securityContext {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.command)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.args)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.workingDir)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ports)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.envFrom)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.env)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resources)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumeMounts)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.livenessProbe)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readinessProbe)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lifecycle)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.terminationMessagePath)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.terminationMessagePolicy)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.imagePullPolicy)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.securityContext)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdin = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdinOnce = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tty = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.workingDir.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.envFrom {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.env {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.volumeMounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.livenessProbe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readinessProbe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lifecycle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.terminationMessagePath.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.terminationMessagePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(ref v) = self.imagePullPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.securityContext.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stdin {
            my_size += 3;
        }
        if let Some(v) = self.stdinOnce {
            my_size += 3;
        }
        if let Some(v) = self.tty {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.command {
            os.write_string(3, &v)?;
        };
        for v in &self.args {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.workingDir.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.ports {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.envFrom {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.env {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.resources.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.volumeMounts {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.livenessProbe.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readinessProbe.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lifecycle.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.terminationMessagePath.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.terminationMessagePolicy.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(ref v) = self.imagePullPolicy.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.securityContext.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.stdin {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.stdinOnce {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.tty {
            os.write_bool(18, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Container {
    fn new() -> Container {
        Container::new()
    }

    fn descriptor_static(_: ::std::option::Option<Container>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Container::get_name_for_reflect,
                    Container::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "image",
                    Container::get_image_for_reflect,
                    Container::mut_image_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "command",
                    Container::get_command_for_reflect,
                    Container::mut_command_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "args",
                    Container::get_args_for_reflect,
                    Container::mut_args_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "workingDir",
                    Container::get_workingDir_for_reflect,
                    Container::mut_workingDir_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerPort>>(
                    "ports",
                    Container::get_ports_for_reflect,
                    Container::mut_ports_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EnvFromSource>>(
                    "envFrom",
                    Container::get_envFrom_for_reflect,
                    Container::mut_envFrom_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EnvVar>>(
                    "env",
                    Container::get_env_for_reflect,
                    Container::mut_env_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceRequirements>>(
                    "resources",
                    Container::get_resources_for_reflect,
                    Container::mut_resources_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VolumeMount>>(
                    "volumeMounts",
                    Container::get_volumeMounts_for_reflect,
                    Container::mut_volumeMounts_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Probe>>(
                    "livenessProbe",
                    Container::get_livenessProbe_for_reflect,
                    Container::mut_livenessProbe_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Probe>>(
                    "readinessProbe",
                    Container::get_readinessProbe_for_reflect,
                    Container::mut_readinessProbe_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Lifecycle>>(
                    "lifecycle",
                    Container::get_lifecycle_for_reflect,
                    Container::mut_lifecycle_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "terminationMessagePath",
                    Container::get_terminationMessagePath_for_reflect,
                    Container::mut_terminationMessagePath_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "terminationMessagePolicy",
                    Container::get_terminationMessagePolicy_for_reflect,
                    Container::mut_terminationMessagePolicy_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "imagePullPolicy",
                    Container::get_imagePullPolicy_for_reflect,
                    Container::mut_imagePullPolicy_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecurityContext>>(
                    "securityContext",
                    Container::get_securityContext_for_reflect,
                    Container::mut_securityContext_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "stdin",
                    Container::get_stdin_for_reflect,
                    Container::mut_stdin_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "stdinOnce",
                    Container::get_stdinOnce_for_reflect,
                    Container::mut_stdinOnce_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "tty",
                    Container::get_tty_for_reflect,
                    Container::mut_tty_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Container>(
                    "Container",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Container {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_image();
        self.clear_command();
        self.clear_args();
        self.clear_workingDir();
        self.clear_ports();
        self.clear_envFrom();
        self.clear_env();
        self.clear_resources();
        self.clear_volumeMounts();
        self.clear_livenessProbe();
        self.clear_readinessProbe();
        self.clear_lifecycle();
        self.clear_terminationMessagePath();
        self.clear_terminationMessagePolicy();
        self.clear_imagePullPolicy();
        self.clear_securityContext();
        self.clear_stdin();
        self.clear_stdinOnce();
        self.clear_tty();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Container {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Container {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerImage {
    // message fields
    names: ::protobuf::RepeatedField<::std::string::String>,
    sizeBytes: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerImage {}

impl ContainerImage {
    pub fn new() -> ContainerImage {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerImage {
        static mut instance: ::protobuf::lazy::Lazy<ContainerImage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerImage,
        };
        unsafe {
            instance.get(ContainerImage::new)
        }
    }

    // repeated string names = 1;

    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }

    pub fn get_names(&self) -> &[::std::string::String] {
        &self.names
    }

    fn get_names_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.names
    }

    fn mut_names_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.names
    }

    // optional int64 sizeBytes = 2;

    pub fn clear_sizeBytes(&mut self) {
        self.sizeBytes = ::std::option::Option::None;
    }

    pub fn has_sizeBytes(&self) -> bool {
        self.sizeBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sizeBytes(&mut self, v: i64) {
        self.sizeBytes = ::std::option::Option::Some(v);
    }

    pub fn get_sizeBytes(&self) -> i64 {
        self.sizeBytes.unwrap_or(0)
    }

    fn get_sizeBytes_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.sizeBytes
    }

    fn mut_sizeBytes_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.sizeBytes
    }
}

impl ::protobuf::Message for ContainerImage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.names)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sizeBytes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.sizeBytes {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.names {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.sizeBytes {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerImage {
    fn new() -> ContainerImage {
        ContainerImage::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerImage>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "names",
                    ContainerImage::get_names_for_reflect,
                    ContainerImage::mut_names_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sizeBytes",
                    ContainerImage::get_sizeBytes_for_reflect,
                    ContainerImage::mut_sizeBytes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerImage>(
                    "ContainerImage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerImage {
    fn clear(&mut self) {
        self.clear_names();
        self.clear_sizeBytes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerImage {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerPort {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    hostPort: ::std::option::Option<i32>,
    containerPort: ::std::option::Option<i32>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    hostIP: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerPort {}

impl ContainerPort {
    pub fn new() -> ContainerPort {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerPort {
        static mut instance: ::protobuf::lazy::Lazy<ContainerPort> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerPort,
        };
        unsafe {
            instance.get(ContainerPort::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional int32 hostPort = 2;

    pub fn clear_hostPort(&mut self) {
        self.hostPort = ::std::option::Option::None;
    }

    pub fn has_hostPort(&self) -> bool {
        self.hostPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostPort(&mut self, v: i32) {
        self.hostPort = ::std::option::Option::Some(v);
    }

    pub fn get_hostPort(&self) -> i32 {
        self.hostPort.unwrap_or(0)
    }

    fn get_hostPort_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.hostPort
    }

    fn mut_hostPort_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.hostPort
    }

    // optional int32 containerPort = 3;

    pub fn clear_containerPort(&mut self) {
        self.containerPort = ::std::option::Option::None;
    }

    pub fn has_containerPort(&self) -> bool {
        self.containerPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerPort(&mut self, v: i32) {
        self.containerPort = ::std::option::Option::Some(v);
    }

    pub fn get_containerPort(&self) -> i32 {
        self.containerPort.unwrap_or(0)
    }

    fn get_containerPort_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.containerPort
    }

    fn mut_containerPort_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.containerPort
    }

    // optional string protocol = 4;

    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_protocol_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.protocol
    }

    fn mut_protocol_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.protocol
    }

    // optional string hostIP = 5;

    pub fn clear_hostIP(&mut self) {
        self.hostIP.clear();
    }

    pub fn has_hostIP(&self) -> bool {
        self.hostIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostIP(&mut self, v: ::std::string::String) {
        self.hostIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostIP(&mut self) -> &mut ::std::string::String {
        if self.hostIP.is_none() {
            self.hostIP.set_default();
        }
        self.hostIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostIP(&mut self) -> ::std::string::String {
        self.hostIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostIP(&self) -> &str {
        match self.hostIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hostIP_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hostIP
    }

    fn mut_hostIP_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hostIP
    }
}

impl ::protobuf::Message for ContainerPort {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hostPort = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.containerPort = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostIP)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.hostPort {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.containerPort {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.hostIP.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.hostPort {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.containerPort {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.hostIP.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerPort {
    fn new() -> ContainerPort {
        ContainerPort::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerPort>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    ContainerPort::get_name_for_reflect,
                    ContainerPort::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "hostPort",
                    ContainerPort::get_hostPort_for_reflect,
                    ContainerPort::mut_hostPort_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "containerPort",
                    ContainerPort::get_containerPort_for_reflect,
                    ContainerPort::mut_containerPort_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "protocol",
                    ContainerPort::get_protocol_for_reflect,
                    ContainerPort::mut_protocol_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostIP",
                    ContainerPort::get_hostIP_for_reflect,
                    ContainerPort::mut_hostIP_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerPort>(
                    "ContainerPort",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerPort {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_hostPort();
        self.clear_containerPort();
        self.clear_protocol();
        self.clear_hostIP();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerPort {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerState {
    // message fields
    waiting: ::protobuf::SingularPtrField<ContainerStateWaiting>,
    running: ::protobuf::SingularPtrField<ContainerStateRunning>,
    terminated: ::protobuf::SingularPtrField<ContainerStateTerminated>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerState {}

impl ContainerState {
    pub fn new() -> ContainerState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerState {
        static mut instance: ::protobuf::lazy::Lazy<ContainerState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerState,
        };
        unsafe {
            instance.get(ContainerState::new)
        }
    }

    // optional .k8s.io.api.core.v1.ContainerStateWaiting waiting = 1;

    pub fn clear_waiting(&mut self) {
        self.waiting.clear();
    }

    pub fn has_waiting(&self) -> bool {
        self.waiting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_waiting(&mut self, v: ContainerStateWaiting) {
        self.waiting = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_waiting(&mut self) -> &mut ContainerStateWaiting {
        if self.waiting.is_none() {
            self.waiting.set_default();
        }
        self.waiting.as_mut().unwrap()
    }

    // Take field
    pub fn take_waiting(&mut self) -> ContainerStateWaiting {
        self.waiting.take().unwrap_or_else(|| ContainerStateWaiting::new())
    }

    pub fn get_waiting(&self) -> &ContainerStateWaiting {
        self.waiting.as_ref().unwrap_or_else(|| ContainerStateWaiting::default_instance())
    }

    fn get_waiting_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerStateWaiting> {
        &self.waiting
    }

    fn mut_waiting_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerStateWaiting> {
        &mut self.waiting
    }

    // optional .k8s.io.api.core.v1.ContainerStateRunning running = 2;

    pub fn clear_running(&mut self) {
        self.running.clear();
    }

    pub fn has_running(&self) -> bool {
        self.running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_running(&mut self, v: ContainerStateRunning) {
        self.running = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_running(&mut self) -> &mut ContainerStateRunning {
        if self.running.is_none() {
            self.running.set_default();
        }
        self.running.as_mut().unwrap()
    }

    // Take field
    pub fn take_running(&mut self) -> ContainerStateRunning {
        self.running.take().unwrap_or_else(|| ContainerStateRunning::new())
    }

    pub fn get_running(&self) -> &ContainerStateRunning {
        self.running.as_ref().unwrap_or_else(|| ContainerStateRunning::default_instance())
    }

    fn get_running_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerStateRunning> {
        &self.running
    }

    fn mut_running_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerStateRunning> {
        &mut self.running
    }

    // optional .k8s.io.api.core.v1.ContainerStateTerminated terminated = 3;

    pub fn clear_terminated(&mut self) {
        self.terminated.clear();
    }

    pub fn has_terminated(&self) -> bool {
        self.terminated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminated(&mut self, v: ContainerStateTerminated) {
        self.terminated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminated(&mut self) -> &mut ContainerStateTerminated {
        if self.terminated.is_none() {
            self.terminated.set_default();
        }
        self.terminated.as_mut().unwrap()
    }

    // Take field
    pub fn take_terminated(&mut self) -> ContainerStateTerminated {
        self.terminated.take().unwrap_or_else(|| ContainerStateTerminated::new())
    }

    pub fn get_terminated(&self) -> &ContainerStateTerminated {
        self.terminated.as_ref().unwrap_or_else(|| ContainerStateTerminated::default_instance())
    }

    fn get_terminated_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerStateTerminated> {
        &self.terminated
    }

    fn mut_terminated_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerStateTerminated> {
        &mut self.terminated
    }
}

impl ::protobuf::Message for ContainerState {
    fn is_initialized(&self) -> bool {
        for v in &self.waiting {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.running {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.terminated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.waiting)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.running)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.terminated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.waiting.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.running.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.terminated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.waiting.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.running.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.terminated.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerState {
    fn new() -> ContainerState {
        ContainerState::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStateWaiting>>(
                    "waiting",
                    ContainerState::get_waiting_for_reflect,
                    ContainerState::mut_waiting_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStateRunning>>(
                    "running",
                    ContainerState::get_running_for_reflect,
                    ContainerState::mut_running_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStateTerminated>>(
                    "terminated",
                    ContainerState::get_terminated_for_reflect,
                    ContainerState::mut_terminated_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerState>(
                    "ContainerState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerState {
    fn clear(&mut self) {
        self.clear_waiting();
        self.clear_running();
        self.clear_terminated();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStateRunning {
    // message fields
    startedAt: ::protobuf::SingularPtrField<super::generated::Time>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerStateRunning {}

impl ContainerStateRunning {
    pub fn new() -> ContainerStateRunning {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerStateRunning {
        static mut instance: ::protobuf::lazy::Lazy<ContainerStateRunning> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerStateRunning,
        };
        unsafe {
            instance.get(ContainerStateRunning::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 1;

    pub fn clear_startedAt(&mut self) {
        self.startedAt.clear();
    }

    pub fn has_startedAt(&self) -> bool {
        self.startedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startedAt(&mut self, v: super::generated::Time) {
        self.startedAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startedAt(&mut self) -> &mut super::generated::Time {
        if self.startedAt.is_none() {
            self.startedAt.set_default();
        }
        self.startedAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_startedAt(&mut self) -> super::generated::Time {
        self.startedAt.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_startedAt(&self) -> &super::generated::Time {
        self.startedAt.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_startedAt_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.startedAt
    }

    fn mut_startedAt_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.startedAt
    }
}

impl ::protobuf::Message for ContainerStateRunning {
    fn is_initialized(&self) -> bool {
        for v in &self.startedAt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startedAt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.startedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.startedAt.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerStateRunning {
    fn new() -> ContainerStateRunning {
        ContainerStateRunning::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerStateRunning>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "startedAt",
                    ContainerStateRunning::get_startedAt_for_reflect,
                    ContainerStateRunning::mut_startedAt_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerStateRunning>(
                    "ContainerStateRunning",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerStateRunning {
    fn clear(&mut self) {
        self.clear_startedAt();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStateRunning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStateRunning {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStateTerminated {
    // message fields
    exitCode: ::std::option::Option<i32>,
    signal: ::std::option::Option<i32>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    startedAt: ::protobuf::SingularPtrField<super::generated::Time>,
    finishedAt: ::protobuf::SingularPtrField<super::generated::Time>,
    containerID: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerStateTerminated {}

impl ContainerStateTerminated {
    pub fn new() -> ContainerStateTerminated {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerStateTerminated {
        static mut instance: ::protobuf::lazy::Lazy<ContainerStateTerminated> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerStateTerminated,
        };
        unsafe {
            instance.get(ContainerStateTerminated::new)
        }
    }

    // optional int32 exitCode = 1;

    pub fn clear_exitCode(&mut self) {
        self.exitCode = ::std::option::Option::None;
    }

    pub fn has_exitCode(&self) -> bool {
        self.exitCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exitCode(&mut self, v: i32) {
        self.exitCode = ::std::option::Option::Some(v);
    }

    pub fn get_exitCode(&self) -> i32 {
        self.exitCode.unwrap_or(0)
    }

    fn get_exitCode_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.exitCode
    }

    fn mut_exitCode_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.exitCode
    }

    // optional int32 signal = 2;

    pub fn clear_signal(&mut self) {
        self.signal = ::std::option::Option::None;
    }

    pub fn has_signal(&self) -> bool {
        self.signal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signal(&mut self, v: i32) {
        self.signal = ::std::option::Option::Some(v);
    }

    pub fn get_signal(&self) -> i32 {
        self.signal.unwrap_or(0)
    }

    fn get_signal_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.signal
    }

    fn mut_signal_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.signal
    }

    // optional string reason = 3;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_reason_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.reason
    }

    // optional string message = 4;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 5;

    pub fn clear_startedAt(&mut self) {
        self.startedAt.clear();
    }

    pub fn has_startedAt(&self) -> bool {
        self.startedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startedAt(&mut self, v: super::generated::Time) {
        self.startedAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startedAt(&mut self) -> &mut super::generated::Time {
        if self.startedAt.is_none() {
            self.startedAt.set_default();
        }
        self.startedAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_startedAt(&mut self) -> super::generated::Time {
        self.startedAt.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_startedAt(&self) -> &super::generated::Time {
        self.startedAt.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_startedAt_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.startedAt
    }

    fn mut_startedAt_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.startedAt
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 6;

    pub fn clear_finishedAt(&mut self) {
        self.finishedAt.clear();
    }

    pub fn has_finishedAt(&self) -> bool {
        self.finishedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finishedAt(&mut self, v: super::generated::Time) {
        self.finishedAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_finishedAt(&mut self) -> &mut super::generated::Time {
        if self.finishedAt.is_none() {
            self.finishedAt.set_default();
        }
        self.finishedAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_finishedAt(&mut self) -> super::generated::Time {
        self.finishedAt.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_finishedAt(&self) -> &super::generated::Time {
        self.finishedAt.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_finishedAt_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.finishedAt
    }

    fn mut_finishedAt_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.finishedAt
    }

    // optional string containerID = 7;

    pub fn clear_containerID(&mut self) {
        self.containerID.clear();
    }

    pub fn has_containerID(&self) -> bool {
        self.containerID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerID(&mut self, v: ::std::string::String) {
        self.containerID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_containerID(&mut self) -> &mut ::std::string::String {
        if self.containerID.is_none() {
            self.containerID.set_default();
        }
        self.containerID.as_mut().unwrap()
    }

    // Take field
    pub fn take_containerID(&mut self) -> ::std::string::String {
        self.containerID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_containerID(&self) -> &str {
        match self.containerID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_containerID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.containerID
    }

    fn mut_containerID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.containerID
    }
}

impl ::protobuf::Message for ContainerStateTerminated {
    fn is_initialized(&self) -> bool {
        for v in &self.startedAt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.finishedAt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.exitCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.signal = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startedAt)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.finishedAt)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.containerID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.exitCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.signal {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.startedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.finishedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.containerID.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.exitCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.signal {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.startedAt.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.finishedAt.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.containerID.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerStateTerminated {
    fn new() -> ContainerStateTerminated {
        ContainerStateTerminated::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerStateTerminated>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "exitCode",
                    ContainerStateTerminated::get_exitCode_for_reflect,
                    ContainerStateTerminated::mut_exitCode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "signal",
                    ContainerStateTerminated::get_signal_for_reflect,
                    ContainerStateTerminated::mut_signal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reason",
                    ContainerStateTerminated::get_reason_for_reflect,
                    ContainerStateTerminated::mut_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    ContainerStateTerminated::get_message_for_reflect,
                    ContainerStateTerminated::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "startedAt",
                    ContainerStateTerminated::get_startedAt_for_reflect,
                    ContainerStateTerminated::mut_startedAt_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "finishedAt",
                    ContainerStateTerminated::get_finishedAt_for_reflect,
                    ContainerStateTerminated::mut_finishedAt_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "containerID",
                    ContainerStateTerminated::get_containerID_for_reflect,
                    ContainerStateTerminated::mut_containerID_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerStateTerminated>(
                    "ContainerStateTerminated",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerStateTerminated {
    fn clear(&mut self) {
        self.clear_exitCode();
        self.clear_signal();
        self.clear_reason();
        self.clear_message();
        self.clear_startedAt();
        self.clear_finishedAt();
        self.clear_containerID();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStateTerminated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStateTerminated {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStateWaiting {
    // message fields
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerStateWaiting {}

impl ContainerStateWaiting {
    pub fn new() -> ContainerStateWaiting {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerStateWaiting {
        static mut instance: ::protobuf::lazy::Lazy<ContainerStateWaiting> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerStateWaiting,
        };
        unsafe {
            instance.get(ContainerStateWaiting::new)
        }
    }

    // optional string reason = 1;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_reason_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.reason
    }

    // optional string message = 2;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }
}

impl ::protobuf::Message for ContainerStateWaiting {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerStateWaiting {
    fn new() -> ContainerStateWaiting {
        ContainerStateWaiting::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerStateWaiting>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reason",
                    ContainerStateWaiting::get_reason_for_reflect,
                    ContainerStateWaiting::mut_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    ContainerStateWaiting::get_message_for_reflect,
                    ContainerStateWaiting::mut_message_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerStateWaiting>(
                    "ContainerStateWaiting",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerStateWaiting {
    fn clear(&mut self) {
        self.clear_reason();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStateWaiting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStateWaiting {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStatus {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    state: ::protobuf::SingularPtrField<ContainerState>,
    lastState: ::protobuf::SingularPtrField<ContainerState>,
    ready: ::std::option::Option<bool>,
    restartCount: ::std::option::Option<i32>,
    image: ::protobuf::SingularField<::std::string::String>,
    imageID: ::protobuf::SingularField<::std::string::String>,
    containerID: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerStatus {}

impl ContainerStatus {
    pub fn new() -> ContainerStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerStatus {
        static mut instance: ::protobuf::lazy::Lazy<ContainerStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerStatus,
        };
        unsafe {
            instance.get(ContainerStatus::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional .k8s.io.api.core.v1.ContainerState state = 2;

    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ContainerState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ContainerState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ContainerState {
        self.state.take().unwrap_or_else(|| ContainerState::new())
    }

    pub fn get_state(&self) -> &ContainerState {
        self.state.as_ref().unwrap_or_else(|| ContainerState::default_instance())
    }

    fn get_state_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerState> {
        &self.state
    }

    fn mut_state_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerState> {
        &mut self.state
    }

    // optional .k8s.io.api.core.v1.ContainerState lastState = 3;

    pub fn clear_lastState(&mut self) {
        self.lastState.clear();
    }

    pub fn has_lastState(&self) -> bool {
        self.lastState.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastState(&mut self, v: ContainerState) {
        self.lastState = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastState(&mut self) -> &mut ContainerState {
        if self.lastState.is_none() {
            self.lastState.set_default();
        }
        self.lastState.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastState(&mut self) -> ContainerState {
        self.lastState.take().unwrap_or_else(|| ContainerState::new())
    }

    pub fn get_lastState(&self) -> &ContainerState {
        self.lastState.as_ref().unwrap_or_else(|| ContainerState::default_instance())
    }

    fn get_lastState_for_reflect(&self) -> &::protobuf::SingularPtrField<ContainerState> {
        &self.lastState
    }

    fn mut_lastState_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ContainerState> {
        &mut self.lastState
    }

    // optional bool ready = 4;

    pub fn clear_ready(&mut self) {
        self.ready = ::std::option::Option::None;
    }

    pub fn has_ready(&self) -> bool {
        self.ready.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ready(&mut self, v: bool) {
        self.ready = ::std::option::Option::Some(v);
    }

    pub fn get_ready(&self) -> bool {
        self.ready.unwrap_or(false)
    }

    fn get_ready_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.ready
    }

    fn mut_ready_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.ready
    }

    // optional int32 restartCount = 5;

    pub fn clear_restartCount(&mut self) {
        self.restartCount = ::std::option::Option::None;
    }

    pub fn has_restartCount(&self) -> bool {
        self.restartCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restartCount(&mut self, v: i32) {
        self.restartCount = ::std::option::Option::Some(v);
    }

    pub fn get_restartCount(&self) -> i32 {
        self.restartCount.unwrap_or(0)
    }

    fn get_restartCount_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.restartCount
    }

    fn mut_restartCount_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.restartCount
    }

    // optional string image = 6;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_image_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.image
    }

    fn mut_image_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.image
    }

    // optional string imageID = 7;

    pub fn clear_imageID(&mut self) {
        self.imageID.clear();
    }

    pub fn has_imageID(&self) -> bool {
        self.imageID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imageID(&mut self, v: ::std::string::String) {
        self.imageID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_imageID(&mut self) -> &mut ::std::string::String {
        if self.imageID.is_none() {
            self.imageID.set_default();
        }
        self.imageID.as_mut().unwrap()
    }

    // Take field
    pub fn take_imageID(&mut self) -> ::std::string::String {
        self.imageID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_imageID(&self) -> &str {
        match self.imageID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_imageID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.imageID
    }

    fn mut_imageID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.imageID
    }

    // optional string containerID = 8;

    pub fn clear_containerID(&mut self) {
        self.containerID.clear();
    }

    pub fn has_containerID(&self) -> bool {
        self.containerID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerID(&mut self, v: ::std::string::String) {
        self.containerID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_containerID(&mut self) -> &mut ::std::string::String {
        if self.containerID.is_none() {
            self.containerID.set_default();
        }
        self.containerID.as_mut().unwrap()
    }

    // Take field
    pub fn take_containerID(&mut self) -> ::std::string::String {
        self.containerID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_containerID(&self) -> &str {
        match self.containerID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_containerID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.containerID
    }

    fn mut_containerID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.containerID
    }
}

impl ::protobuf::Message for ContainerStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lastState {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastState)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ready = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.restartCount = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.imageID)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.containerID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lastState.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ready {
            my_size += 2;
        }
        if let Some(v) = self.restartCount {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.imageID.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.containerID.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lastState.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.ready {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.restartCount {
            os.write_int32(5, v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.imageID.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.containerID.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerStatus {
    fn new() -> ContainerStatus {
        ContainerStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    ContainerStatus::get_name_for_reflect,
                    ContainerStatus::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerState>>(
                    "state",
                    ContainerStatus::get_state_for_reflect,
                    ContainerStatus::mut_state_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerState>>(
                    "lastState",
                    ContainerStatus::get_lastState_for_reflect,
                    ContainerStatus::mut_lastState_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "ready",
                    ContainerStatus::get_ready_for_reflect,
                    ContainerStatus::mut_ready_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "restartCount",
                    ContainerStatus::get_restartCount_for_reflect,
                    ContainerStatus::mut_restartCount_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "image",
                    ContainerStatus::get_image_for_reflect,
                    ContainerStatus::mut_image_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "imageID",
                    ContainerStatus::get_imageID_for_reflect,
                    ContainerStatus::mut_imageID_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "containerID",
                    ContainerStatus::get_containerID_for_reflect,
                    ContainerStatus::mut_containerID_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerStatus>(
                    "ContainerStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerStatus {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_state();
        self.clear_lastState();
        self.clear_ready();
        self.clear_restartCount();
        self.clear_image();
        self.clear_imageID();
        self.clear_containerID();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DaemonEndpoint {
    // message fields
    Port: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DaemonEndpoint {}

impl DaemonEndpoint {
    pub fn new() -> DaemonEndpoint {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DaemonEndpoint {
        static mut instance: ::protobuf::lazy::Lazy<DaemonEndpoint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DaemonEndpoint,
        };
        unsafe {
            instance.get(DaemonEndpoint::new)
        }
    }

    // optional int32 Port = 1;

    pub fn clear_Port(&mut self) {
        self.Port = ::std::option::Option::None;
    }

    pub fn has_Port(&self) -> bool {
        self.Port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Port(&mut self, v: i32) {
        self.Port = ::std::option::Option::Some(v);
    }

    pub fn get_Port(&self) -> i32 {
        self.Port.unwrap_or(0)
    }

    fn get_Port_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.Port
    }

    fn mut_Port_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.Port
    }
}

impl ::protobuf::Message for DaemonEndpoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.Port {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.Port {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DaemonEndpoint {
    fn new() -> DaemonEndpoint {
        DaemonEndpoint::new()
    }

    fn descriptor_static(_: ::std::option::Option<DaemonEndpoint>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Port",
                    DaemonEndpoint::get_Port_for_reflect,
                    DaemonEndpoint::mut_Port_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DaemonEndpoint>(
                    "DaemonEndpoint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DaemonEndpoint {
    fn clear(&mut self) {
        self.clear_Port();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DaemonEndpoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonEndpoint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteOptions {
    // message fields
    gracePeriodSeconds: ::std::option::Option<i64>,
    preconditions: ::protobuf::SingularPtrField<Preconditions>,
    orphanDependents: ::std::option::Option<bool>,
    propagationPolicy: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DeleteOptions {}

impl DeleteOptions {
    pub fn new() -> DeleteOptions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DeleteOptions {
        static mut instance: ::protobuf::lazy::Lazy<DeleteOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteOptions,
        };
        unsafe {
            instance.get(DeleteOptions::new)
        }
    }

    // optional int64 gracePeriodSeconds = 1;

    pub fn clear_gracePeriodSeconds(&mut self) {
        self.gracePeriodSeconds = ::std::option::Option::None;
    }

    pub fn has_gracePeriodSeconds(&self) -> bool {
        self.gracePeriodSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gracePeriodSeconds(&mut self, v: i64) {
        self.gracePeriodSeconds = ::std::option::Option::Some(v);
    }

    pub fn get_gracePeriodSeconds(&self) -> i64 {
        self.gracePeriodSeconds.unwrap_or(0)
    }

    fn get_gracePeriodSeconds_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.gracePeriodSeconds
    }

    fn mut_gracePeriodSeconds_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.gracePeriodSeconds
    }

    // optional .k8s.io.api.core.v1.Preconditions preconditions = 2;

    pub fn clear_preconditions(&mut self) {
        self.preconditions.clear();
    }

    pub fn has_preconditions(&self) -> bool {
        self.preconditions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preconditions(&mut self, v: Preconditions) {
        self.preconditions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preconditions(&mut self) -> &mut Preconditions {
        if self.preconditions.is_none() {
            self.preconditions.set_default();
        }
        self.preconditions.as_mut().unwrap()
    }

    // Take field
    pub fn take_preconditions(&mut self) -> Preconditions {
        self.preconditions.take().unwrap_or_else(|| Preconditions::new())
    }

    pub fn get_preconditions(&self) -> &Preconditions {
        self.preconditions.as_ref().unwrap_or_else(|| Preconditions::default_instance())
    }

    fn get_preconditions_for_reflect(&self) -> &::protobuf::SingularPtrField<Preconditions> {
        &self.preconditions
    }

    fn mut_preconditions_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Preconditions> {
        &mut self.preconditions
    }

    // optional bool orphanDependents = 3;

    pub fn clear_orphanDependents(&mut self) {
        self.orphanDependents = ::std::option::Option::None;
    }

    pub fn has_orphanDependents(&self) -> bool {
        self.orphanDependents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orphanDependents(&mut self, v: bool) {
        self.orphanDependents = ::std::option::Option::Some(v);
    }

    pub fn get_orphanDependents(&self) -> bool {
        self.orphanDependents.unwrap_or(false)
    }

    fn get_orphanDependents_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.orphanDependents
    }

    fn mut_orphanDependents_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.orphanDependents
    }

    // optional string propagationPolicy = 4;

    pub fn clear_propagationPolicy(&mut self) {
        self.propagationPolicy.clear();
    }

    pub fn has_propagationPolicy(&self) -> bool {
        self.propagationPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_propagationPolicy(&mut self, v: ::std::string::String) {
        self.propagationPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_propagationPolicy(&mut self) -> &mut ::std::string::String {
        if self.propagationPolicy.is_none() {
            self.propagationPolicy.set_default();
        }
        self.propagationPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_propagationPolicy(&mut self) -> ::std::string::String {
        self.propagationPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_propagationPolicy(&self) -> &str {
        match self.propagationPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_propagationPolicy_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.propagationPolicy
    }

    fn mut_propagationPolicy_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.propagationPolicy
    }
}

impl ::protobuf::Message for DeleteOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.preconditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.gracePeriodSeconds = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preconditions)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.orphanDependents = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.propagationPolicy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gracePeriodSeconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.preconditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.orphanDependents {
            my_size += 2;
        }
        if let Some(ref v) = self.propagationPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gracePeriodSeconds {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.preconditions.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.orphanDependents {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.propagationPolicy.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DeleteOptions {
    fn new() -> DeleteOptions {
        DeleteOptions::new()
    }

    fn descriptor_static(_: ::std::option::Option<DeleteOptions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "gracePeriodSeconds",
                    DeleteOptions::get_gracePeriodSeconds_for_reflect,
                    DeleteOptions::mut_gracePeriodSeconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preconditions>>(
                    "preconditions",
                    DeleteOptions::get_preconditions_for_reflect,
                    DeleteOptions::mut_preconditions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "orphanDependents",
                    DeleteOptions::get_orphanDependents_for_reflect,
                    DeleteOptions::mut_orphanDependents_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "propagationPolicy",
                    DeleteOptions::get_propagationPolicy_for_reflect,
                    DeleteOptions::mut_propagationPolicy_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteOptions>(
                    "DeleteOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DeleteOptions {
    fn clear(&mut self) {
        self.clear_gracePeriodSeconds();
        self.clear_preconditions();
        self.clear_orphanDependents();
        self.clear_propagationPolicy();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownwardAPIProjection {
    // message fields
    items: ::protobuf::RepeatedField<DownwardAPIVolumeFile>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DownwardAPIProjection {}

impl DownwardAPIProjection {
    pub fn new() -> DownwardAPIProjection {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DownwardAPIProjection {
        static mut instance: ::protobuf::lazy::Lazy<DownwardAPIProjection> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DownwardAPIProjection,
        };
        unsafe {
            instance.get(DownwardAPIProjection::new)
        }
    }

    // repeated .k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<DownwardAPIVolumeFile>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<DownwardAPIVolumeFile> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<DownwardAPIVolumeFile> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[DownwardAPIVolumeFile] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<DownwardAPIVolumeFile> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<DownwardAPIVolumeFile> {
        &mut self.items
    }
}

impl ::protobuf::Message for DownwardAPIProjection {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DownwardAPIProjection {
    fn new() -> DownwardAPIProjection {
        DownwardAPIProjection::new()
    }

    fn descriptor_static(_: ::std::option::Option<DownwardAPIProjection>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownwardAPIVolumeFile>>(
                    "items",
                    DownwardAPIProjection::get_items_for_reflect,
                    DownwardAPIProjection::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DownwardAPIProjection>(
                    "DownwardAPIProjection",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DownwardAPIProjection {
    fn clear(&mut self) {
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownwardAPIProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownwardAPIProjection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownwardAPIVolumeFile {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    fieldRef: ::protobuf::SingularPtrField<ObjectFieldSelector>,
    resourceFieldRef: ::protobuf::SingularPtrField<ResourceFieldSelector>,
    mode: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DownwardAPIVolumeFile {}

impl DownwardAPIVolumeFile {
    pub fn new() -> DownwardAPIVolumeFile {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DownwardAPIVolumeFile {
        static mut instance: ::protobuf::lazy::Lazy<DownwardAPIVolumeFile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DownwardAPIVolumeFile,
        };
        unsafe {
            instance.get(DownwardAPIVolumeFile::new)
        }
    }

    // optional string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional .k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 2;

    pub fn clear_fieldRef(&mut self) {
        self.fieldRef.clear();
    }

    pub fn has_fieldRef(&self) -> bool {
        self.fieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldRef(&mut self, v: ObjectFieldSelector) {
        self.fieldRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldRef(&mut self) -> &mut ObjectFieldSelector {
        if self.fieldRef.is_none() {
            self.fieldRef.set_default();
        }
        self.fieldRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldRef(&mut self) -> ObjectFieldSelector {
        self.fieldRef.take().unwrap_or_else(|| ObjectFieldSelector::new())
    }

    pub fn get_fieldRef(&self) -> &ObjectFieldSelector {
        self.fieldRef.as_ref().unwrap_or_else(|| ObjectFieldSelector::default_instance())
    }

    fn get_fieldRef_for_reflect(&self) -> &::protobuf::SingularPtrField<ObjectFieldSelector> {
        &self.fieldRef
    }

    fn mut_fieldRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ObjectFieldSelector> {
        &mut self.fieldRef
    }

    // optional .k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 3;

    pub fn clear_resourceFieldRef(&mut self) {
        self.resourceFieldRef.clear();
    }

    pub fn has_resourceFieldRef(&self) -> bool {
        self.resourceFieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceFieldRef(&mut self, v: ResourceFieldSelector) {
        self.resourceFieldRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceFieldRef(&mut self) -> &mut ResourceFieldSelector {
        if self.resourceFieldRef.is_none() {
            self.resourceFieldRef.set_default();
        }
        self.resourceFieldRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceFieldRef(&mut self) -> ResourceFieldSelector {
        self.resourceFieldRef.take().unwrap_or_else(|| ResourceFieldSelector::new())
    }

    pub fn get_resourceFieldRef(&self) -> &ResourceFieldSelector {
        self.resourceFieldRef.as_ref().unwrap_or_else(|| ResourceFieldSelector::default_instance())
    }

    fn get_resourceFieldRef_for_reflect(&self) -> &::protobuf::SingularPtrField<ResourceFieldSelector> {
        &self.resourceFieldRef
    }

    fn mut_resourceFieldRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ResourceFieldSelector> {
        &mut self.resourceFieldRef
    }

    // optional int32 mode = 4;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.mode
    }
}

impl ::protobuf::Message for DownwardAPIVolumeFile {
    fn is_initialized(&self) -> bool {
        for v in &self.fieldRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resourceFieldRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fieldRef)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resourceFieldRef)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fieldRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.resourceFieldRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fieldRef.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.resourceFieldRef.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.mode {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DownwardAPIVolumeFile {
    fn new() -> DownwardAPIVolumeFile {
        DownwardAPIVolumeFile::new()
    }

    fn descriptor_static(_: ::std::option::Option<DownwardAPIVolumeFile>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    DownwardAPIVolumeFile::get_path_for_reflect,
                    DownwardAPIVolumeFile::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectFieldSelector>>(
                    "fieldRef",
                    DownwardAPIVolumeFile::get_fieldRef_for_reflect,
                    DownwardAPIVolumeFile::mut_fieldRef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceFieldSelector>>(
                    "resourceFieldRef",
                    DownwardAPIVolumeFile::get_resourceFieldRef_for_reflect,
                    DownwardAPIVolumeFile::mut_resourceFieldRef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mode",
                    DownwardAPIVolumeFile::get_mode_for_reflect,
                    DownwardAPIVolumeFile::mut_mode_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DownwardAPIVolumeFile>(
                    "DownwardAPIVolumeFile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DownwardAPIVolumeFile {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_fieldRef();
        self.clear_resourceFieldRef();
        self.clear_mode();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownwardAPIVolumeFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownwardAPIVolumeFile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownwardAPIVolumeSource {
    // message fields
    items: ::protobuf::RepeatedField<DownwardAPIVolumeFile>,
    defaultMode: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DownwardAPIVolumeSource {}

impl DownwardAPIVolumeSource {
    pub fn new() -> DownwardAPIVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DownwardAPIVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<DownwardAPIVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DownwardAPIVolumeSource,
        };
        unsafe {
            instance.get(DownwardAPIVolumeSource::new)
        }
    }

    // repeated .k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<DownwardAPIVolumeFile>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<DownwardAPIVolumeFile> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<DownwardAPIVolumeFile> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[DownwardAPIVolumeFile] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<DownwardAPIVolumeFile> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<DownwardAPIVolumeFile> {
        &mut self.items
    }

    // optional int32 defaultMode = 2;

    pub fn clear_defaultMode(&mut self) {
        self.defaultMode = ::std::option::Option::None;
    }

    pub fn has_defaultMode(&self) -> bool {
        self.defaultMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultMode(&mut self, v: i32) {
        self.defaultMode = ::std::option::Option::Some(v);
    }

    pub fn get_defaultMode(&self) -> i32 {
        self.defaultMode.unwrap_or(0)
    }

    fn get_defaultMode_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.defaultMode
    }

    fn mut_defaultMode_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.defaultMode
    }
}

impl ::protobuf::Message for DownwardAPIVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.defaultMode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.defaultMode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.defaultMode {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DownwardAPIVolumeSource {
    fn new() -> DownwardAPIVolumeSource {
        DownwardAPIVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<DownwardAPIVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownwardAPIVolumeFile>>(
                    "items",
                    DownwardAPIVolumeSource::get_items_for_reflect,
                    DownwardAPIVolumeSource::mut_items_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "defaultMode",
                    DownwardAPIVolumeSource::get_defaultMode_for_reflect,
                    DownwardAPIVolumeSource::mut_defaultMode_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DownwardAPIVolumeSource>(
                    "DownwardAPIVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DownwardAPIVolumeSource {
    fn clear(&mut self) {
        self.clear_items();
        self.clear_defaultMode();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownwardAPIVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownwardAPIVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EmptyDirVolumeSource {
    // message fields
    medium: ::protobuf::SingularField<::std::string::String>,
    sizeLimit: ::protobuf::SingularPtrField<super::generated::Quantity>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for EmptyDirVolumeSource {}

impl EmptyDirVolumeSource {
    pub fn new() -> EmptyDirVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static EmptyDirVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<EmptyDirVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EmptyDirVolumeSource,
        };
        unsafe {
            instance.get(EmptyDirVolumeSource::new)
        }
    }

    // optional string medium = 1;

    pub fn clear_medium(&mut self) {
        self.medium.clear();
    }

    pub fn has_medium(&self) -> bool {
        self.medium.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medium(&mut self, v: ::std::string::String) {
        self.medium = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_medium(&mut self) -> &mut ::std::string::String {
        if self.medium.is_none() {
            self.medium.set_default();
        }
        self.medium.as_mut().unwrap()
    }

    // Take field
    pub fn take_medium(&mut self) -> ::std::string::String {
        self.medium.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_medium(&self) -> &str {
        match self.medium.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_medium_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.medium
    }

    fn mut_medium_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.medium
    }

    // optional .k8s.io.apimachinery.pkg.api.resource.Quantity sizeLimit = 2;

    pub fn clear_sizeLimit(&mut self) {
        self.sizeLimit.clear();
    }

    pub fn has_sizeLimit(&self) -> bool {
        self.sizeLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sizeLimit(&mut self, v: super::generated::Quantity) {
        self.sizeLimit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sizeLimit(&mut self) -> &mut super::generated::Quantity {
        if self.sizeLimit.is_none() {
            self.sizeLimit.set_default();
        }
        self.sizeLimit.as_mut().unwrap()
    }

    // Take field
    pub fn take_sizeLimit(&mut self) -> super::generated::Quantity {
        self.sizeLimit.take().unwrap_or_else(|| super::generated::Quantity::new())
    }

    pub fn get_sizeLimit(&self) -> &super::generated::Quantity {
        self.sizeLimit.as_ref().unwrap_or_else(|| super::generated::Quantity::default_instance())
    }

    fn get_sizeLimit_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Quantity> {
        &self.sizeLimit
    }

    fn mut_sizeLimit_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Quantity> {
        &mut self.sizeLimit
    }
}

impl ::protobuf::Message for EmptyDirVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.sizeLimit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.medium)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sizeLimit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.medium.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.sizeLimit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.medium.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.sizeLimit.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for EmptyDirVolumeSource {
    fn new() -> EmptyDirVolumeSource {
        EmptyDirVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<EmptyDirVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "medium",
                    EmptyDirVolumeSource::get_medium_for_reflect,
                    EmptyDirVolumeSource::mut_medium_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "sizeLimit",
                    EmptyDirVolumeSource::get_sizeLimit_for_reflect,
                    EmptyDirVolumeSource::mut_sizeLimit_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EmptyDirVolumeSource>(
                    "EmptyDirVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for EmptyDirVolumeSource {
    fn clear(&mut self) {
        self.clear_medium();
        self.clear_sizeLimit();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EmptyDirVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmptyDirVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EndpointAddress {
    // message fields
    ip: ::protobuf::SingularField<::std::string::String>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    nodeName: ::protobuf::SingularField<::std::string::String>,
    targetRef: ::protobuf::SingularPtrField<ObjectReference>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for EndpointAddress {}

impl EndpointAddress {
    pub fn new() -> EndpointAddress {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static EndpointAddress {
        static mut instance: ::protobuf::lazy::Lazy<EndpointAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EndpointAddress,
        };
        unsafe {
            instance.get(EndpointAddress::new)
        }
    }

    // optional string ip = 1;

    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip.set_default();
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_ip_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.ip
    }

    fn mut_ip_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.ip
    }

    // optional string hostname = 3;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hostname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hostname
    }

    fn mut_hostname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hostname
    }

    // optional string nodeName = 4;

    pub fn clear_nodeName(&mut self) {
        self.nodeName.clear();
    }

    pub fn has_nodeName(&self) -> bool {
        self.nodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeName(&mut self, v: ::std::string::String) {
        self.nodeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeName(&mut self) -> &mut ::std::string::String {
        if self.nodeName.is_none() {
            self.nodeName.set_default();
        }
        self.nodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeName(&mut self) -> ::std::string::String {
        self.nodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_nodeName(&self) -> &str {
        match self.nodeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_nodeName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.nodeName
    }

    fn mut_nodeName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.nodeName
    }

    // optional .k8s.io.api.core.v1.ObjectReference targetRef = 2;

    pub fn clear_targetRef(&mut self) {
        self.targetRef.clear();
    }

    pub fn has_targetRef(&self) -> bool {
        self.targetRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetRef(&mut self, v: ObjectReference) {
        self.targetRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetRef(&mut self) -> &mut ObjectReference {
        if self.targetRef.is_none() {
            self.targetRef.set_default();
        }
        self.targetRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetRef(&mut self) -> ObjectReference {
        self.targetRef.take().unwrap_or_else(|| ObjectReference::new())
    }

    pub fn get_targetRef(&self) -> &ObjectReference {
        self.targetRef.as_ref().unwrap_or_else(|| ObjectReference::default_instance())
    }

    fn get_targetRef_for_reflect(&self) -> &::protobuf::SingularPtrField<ObjectReference> {
        &self.targetRef
    }

    fn mut_targetRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ObjectReference> {
        &mut self.targetRef
    }
}

impl ::protobuf::Message for EndpointAddress {
    fn is_initialized(&self) -> bool {
        for v in &self.targetRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nodeName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.targetRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.nodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.targetRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ip.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.nodeName.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.targetRef.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for EndpointAddress {
    fn new() -> EndpointAddress {
        EndpointAddress::new()
    }

    fn descriptor_static(_: ::std::option::Option<EndpointAddress>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip",
                    EndpointAddress::get_ip_for_reflect,
                    EndpointAddress::mut_ip_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostname",
                    EndpointAddress::get_hostname_for_reflect,
                    EndpointAddress::mut_hostname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodeName",
                    EndpointAddress::get_nodeName_for_reflect,
                    EndpointAddress::mut_nodeName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                    "targetRef",
                    EndpointAddress::get_targetRef_for_reflect,
                    EndpointAddress::mut_targetRef_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EndpointAddress>(
                    "EndpointAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for EndpointAddress {
    fn clear(&mut self) {
        self.clear_ip();
        self.clear_hostname();
        self.clear_nodeName();
        self.clear_targetRef();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndpointAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EndpointPort {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for EndpointPort {}

impl EndpointPort {
    pub fn new() -> EndpointPort {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static EndpointPort {
        static mut instance: ::protobuf::lazy::Lazy<EndpointPort> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EndpointPort,
        };
        unsafe {
            instance.get(EndpointPort::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional int32 port = 2;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    fn get_port_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.port
    }

    fn mut_port_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.port
    }

    // optional string protocol = 3;

    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_protocol_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.protocol
    }

    fn mut_protocol_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.protocol
    }
}

impl ::protobuf::Message for EndpointPort {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for EndpointPort {
    fn new() -> EndpointPort {
        EndpointPort::new()
    }

    fn descriptor_static(_: ::std::option::Option<EndpointPort>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    EndpointPort::get_name_for_reflect,
                    EndpointPort::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "port",
                    EndpointPort::get_port_for_reflect,
                    EndpointPort::mut_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "protocol",
                    EndpointPort::get_protocol_for_reflect,
                    EndpointPort::mut_protocol_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EndpointPort>(
                    "EndpointPort",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for EndpointPort {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_port();
        self.clear_protocol();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndpointPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointPort {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EndpointSubset {
    // message fields
    addresses: ::protobuf::RepeatedField<EndpointAddress>,
    notReadyAddresses: ::protobuf::RepeatedField<EndpointAddress>,
    ports: ::protobuf::RepeatedField<EndpointPort>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for EndpointSubset {}

impl EndpointSubset {
    pub fn new() -> EndpointSubset {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static EndpointSubset {
        static mut instance: ::protobuf::lazy::Lazy<EndpointSubset> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EndpointSubset,
        };
        unsafe {
            instance.get(EndpointSubset::new)
        }
    }

    // repeated .k8s.io.api.core.v1.EndpointAddress addresses = 1;

    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<EndpointAddress>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<EndpointAddress> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<EndpointAddress> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    pub fn get_addresses(&self) -> &[EndpointAddress] {
        &self.addresses
    }

    fn get_addresses_for_reflect(&self) -> &::protobuf::RepeatedField<EndpointAddress> {
        &self.addresses
    }

    fn mut_addresses_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<EndpointAddress> {
        &mut self.addresses
    }

    // repeated .k8s.io.api.core.v1.EndpointAddress notReadyAddresses = 2;

    pub fn clear_notReadyAddresses(&mut self) {
        self.notReadyAddresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_notReadyAddresses(&mut self, v: ::protobuf::RepeatedField<EndpointAddress>) {
        self.notReadyAddresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notReadyAddresses(&mut self) -> &mut ::protobuf::RepeatedField<EndpointAddress> {
        &mut self.notReadyAddresses
    }

    // Take field
    pub fn take_notReadyAddresses(&mut self) -> ::protobuf::RepeatedField<EndpointAddress> {
        ::std::mem::replace(&mut self.notReadyAddresses, ::protobuf::RepeatedField::new())
    }

    pub fn get_notReadyAddresses(&self) -> &[EndpointAddress] {
        &self.notReadyAddresses
    }

    fn get_notReadyAddresses_for_reflect(&self) -> &::protobuf::RepeatedField<EndpointAddress> {
        &self.notReadyAddresses
    }

    fn mut_notReadyAddresses_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<EndpointAddress> {
        &mut self.notReadyAddresses
    }

    // repeated .k8s.io.api.core.v1.EndpointPort ports = 3;

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::protobuf::RepeatedField<EndpointPort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::protobuf::RepeatedField<EndpointPort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::protobuf::RepeatedField<EndpointPort> {
        ::std::mem::replace(&mut self.ports, ::protobuf::RepeatedField::new())
    }

    pub fn get_ports(&self) -> &[EndpointPort] {
        &self.ports
    }

    fn get_ports_for_reflect(&self) -> &::protobuf::RepeatedField<EndpointPort> {
        &self.ports
    }

    fn mut_ports_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<EndpointPort> {
        &mut self.ports
    }
}

impl ::protobuf::Message for EndpointSubset {
    fn is_initialized(&self) -> bool {
        for v in &self.addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.notReadyAddresses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addresses)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notReadyAddresses)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.notReadyAddresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.addresses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.notReadyAddresses {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ports {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for EndpointSubset {
    fn new() -> EndpointSubset {
        EndpointSubset::new()
    }

    fn descriptor_static(_: ::std::option::Option<EndpointSubset>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EndpointAddress>>(
                    "addresses",
                    EndpointSubset::get_addresses_for_reflect,
                    EndpointSubset::mut_addresses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EndpointAddress>>(
                    "notReadyAddresses",
                    EndpointSubset::get_notReadyAddresses_for_reflect,
                    EndpointSubset::mut_notReadyAddresses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EndpointPort>>(
                    "ports",
                    EndpointSubset::get_ports_for_reflect,
                    EndpointSubset::mut_ports_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EndpointSubset>(
                    "EndpointSubset",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for EndpointSubset {
    fn clear(&mut self) {
        self.clear_addresses();
        self.clear_notReadyAddresses();
        self.clear_ports();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndpointSubset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointSubset {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Endpoints {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    subsets: ::protobuf::RepeatedField<EndpointSubset>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Endpoints {}

impl Endpoints {
    pub fn new() -> Endpoints {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Endpoints {
        static mut instance: ::protobuf::lazy::Lazy<Endpoints> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Endpoints,
        };
        unsafe {
            instance.get(Endpoints::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.EndpointSubset subsets = 2;

    pub fn clear_subsets(&mut self) {
        self.subsets.clear();
    }

    // Param is passed by value, moved
    pub fn set_subsets(&mut self, v: ::protobuf::RepeatedField<EndpointSubset>) {
        self.subsets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subsets(&mut self) -> &mut ::protobuf::RepeatedField<EndpointSubset> {
        &mut self.subsets
    }

    // Take field
    pub fn take_subsets(&mut self) -> ::protobuf::RepeatedField<EndpointSubset> {
        ::std::mem::replace(&mut self.subsets, ::protobuf::RepeatedField::new())
    }

    pub fn get_subsets(&self) -> &[EndpointSubset] {
        &self.subsets
    }

    fn get_subsets_for_reflect(&self) -> &::protobuf::RepeatedField<EndpointSubset> {
        &self.subsets
    }

    fn mut_subsets_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<EndpointSubset> {
        &mut self.subsets
    }
}

impl ::protobuf::Message for Endpoints {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subsets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subsets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.subsets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.subsets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Endpoints {
    fn new() -> Endpoints {
        Endpoints::new()
    }

    fn descriptor_static(_: ::std::option::Option<Endpoints>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    Endpoints::get_metadata_for_reflect,
                    Endpoints::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EndpointSubset>>(
                    "subsets",
                    Endpoints::get_subsets_for_reflect,
                    Endpoints::mut_subsets_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Endpoints>(
                    "Endpoints",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Endpoints {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_subsets();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Endpoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Endpoints {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EndpointsList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<Endpoints>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for EndpointsList {}

impl EndpointsList {
    pub fn new() -> EndpointsList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static EndpointsList {
        static mut instance: ::protobuf::lazy::Lazy<EndpointsList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EndpointsList,
        };
        unsafe {
            instance.get(EndpointsList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.Endpoints items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Endpoints>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Endpoints> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Endpoints> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[Endpoints] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<Endpoints> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Endpoints> {
        &mut self.items
    }
}

impl ::protobuf::Message for EndpointsList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for EndpointsList {
    fn new() -> EndpointsList {
        EndpointsList::new()
    }

    fn descriptor_static(_: ::std::option::Option<EndpointsList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    EndpointsList::get_metadata_for_reflect,
                    EndpointsList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Endpoints>>(
                    "items",
                    EndpointsList::get_items_for_reflect,
                    EndpointsList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EndpointsList>(
                    "EndpointsList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for EndpointsList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndpointsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointsList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnvFromSource {
    // message fields
    prefix: ::protobuf::SingularField<::std::string::String>,
    configMapRef: ::protobuf::SingularPtrField<ConfigMapEnvSource>,
    secretRef: ::protobuf::SingularPtrField<SecretEnvSource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for EnvFromSource {}

impl EnvFromSource {
    pub fn new() -> EnvFromSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static EnvFromSource {
        static mut instance: ::protobuf::lazy::Lazy<EnvFromSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EnvFromSource,
        };
        unsafe {
            instance.get(EnvFromSource::new)
        }
    }

    // optional string prefix = 1;

    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    pub fn has_prefix(&self) -> bool {
        self.prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        if self.prefix.is_none() {
            self.prefix.set_default();
        }
        self.prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        self.prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_prefix(&self) -> &str {
        match self.prefix.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_prefix_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.prefix
    }

    fn mut_prefix_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.prefix
    }

    // optional .k8s.io.api.core.v1.ConfigMapEnvSource configMapRef = 2;

    pub fn clear_configMapRef(&mut self) {
        self.configMapRef.clear();
    }

    pub fn has_configMapRef(&self) -> bool {
        self.configMapRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMapRef(&mut self, v: ConfigMapEnvSource) {
        self.configMapRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMapRef(&mut self) -> &mut ConfigMapEnvSource {
        if self.configMapRef.is_none() {
            self.configMapRef.set_default();
        }
        self.configMapRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_configMapRef(&mut self) -> ConfigMapEnvSource {
        self.configMapRef.take().unwrap_or_else(|| ConfigMapEnvSource::new())
    }

    pub fn get_configMapRef(&self) -> &ConfigMapEnvSource {
        self.configMapRef.as_ref().unwrap_or_else(|| ConfigMapEnvSource::default_instance())
    }

    fn get_configMapRef_for_reflect(&self) -> &::protobuf::SingularPtrField<ConfigMapEnvSource> {
        &self.configMapRef
    }

    fn mut_configMapRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ConfigMapEnvSource> {
        &mut self.configMapRef
    }

    // optional .k8s.io.api.core.v1.SecretEnvSource secretRef = 3;

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretEnvSource) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretEnvSource {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretEnvSource {
        self.secretRef.take().unwrap_or_else(|| SecretEnvSource::new())
    }

    pub fn get_secretRef(&self) -> &SecretEnvSource {
        self.secretRef.as_ref().unwrap_or_else(|| SecretEnvSource::default_instance())
    }

    fn get_secretRef_for_reflect(&self) -> &::protobuf::SingularPtrField<SecretEnvSource> {
        &self.secretRef
    }

    fn mut_secretRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<SecretEnvSource> {
        &mut self.secretRef
    }
}

impl ::protobuf::Message for EnvFromSource {
    fn is_initialized(&self) -> bool {
        for v in &self.configMapRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.prefix)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configMapRef)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.configMapRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.prefix.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.configMapRef.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for EnvFromSource {
    fn new() -> EnvFromSource {
        EnvFromSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<EnvFromSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prefix",
                    EnvFromSource::get_prefix_for_reflect,
                    EnvFromSource::mut_prefix_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigMapEnvSource>>(
                    "configMapRef",
                    EnvFromSource::get_configMapRef_for_reflect,
                    EnvFromSource::mut_configMapRef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretEnvSource>>(
                    "secretRef",
                    EnvFromSource::get_secretRef_for_reflect,
                    EnvFromSource::mut_secretRef_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EnvFromSource>(
                    "EnvFromSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for EnvFromSource {
    fn clear(&mut self) {
        self.clear_prefix();
        self.clear_configMapRef();
        self.clear_secretRef();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnvFromSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvFromSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnvVar {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    valueFrom: ::protobuf::SingularPtrField<EnvVarSource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for EnvVar {}

impl EnvVar {
    pub fn new() -> EnvVar {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static EnvVar {
        static mut instance: ::protobuf::lazy::Lazy<EnvVar> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EnvVar,
        };
        unsafe {
            instance.get(EnvVar::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }

    // optional .k8s.io.api.core.v1.EnvVarSource valueFrom = 3;

    pub fn clear_valueFrom(&mut self) {
        self.valueFrom.clear();
    }

    pub fn has_valueFrom(&self) -> bool {
        self.valueFrom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valueFrom(&mut self, v: EnvVarSource) {
        self.valueFrom = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_valueFrom(&mut self) -> &mut EnvVarSource {
        if self.valueFrom.is_none() {
            self.valueFrom.set_default();
        }
        self.valueFrom.as_mut().unwrap()
    }

    // Take field
    pub fn take_valueFrom(&mut self) -> EnvVarSource {
        self.valueFrom.take().unwrap_or_else(|| EnvVarSource::new())
    }

    pub fn get_valueFrom(&self) -> &EnvVarSource {
        self.valueFrom.as_ref().unwrap_or_else(|| EnvVarSource::default_instance())
    }

    fn get_valueFrom_for_reflect(&self) -> &::protobuf::SingularPtrField<EnvVarSource> {
        &self.valueFrom
    }

    fn mut_valueFrom_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<EnvVarSource> {
        &mut self.valueFrom
    }
}

impl ::protobuf::Message for EnvVar {
    fn is_initialized(&self) -> bool {
        for v in &self.valueFrom {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.valueFrom)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.valueFrom.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.valueFrom.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for EnvVar {
    fn new() -> EnvVar {
        EnvVar::new()
    }

    fn descriptor_static(_: ::std::option::Option<EnvVar>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    EnvVar::get_name_for_reflect,
                    EnvVar::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    EnvVar::get_value_for_reflect,
                    EnvVar::mut_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EnvVarSource>>(
                    "valueFrom",
                    EnvVar::get_valueFrom_for_reflect,
                    EnvVar::mut_valueFrom_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EnvVar>(
                    "EnvVar",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for EnvVar {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_value();
        self.clear_valueFrom();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnvVar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvVar {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnvVarSource {
    // message fields
    fieldRef: ::protobuf::SingularPtrField<ObjectFieldSelector>,
    resourceFieldRef: ::protobuf::SingularPtrField<ResourceFieldSelector>,
    configMapKeyRef: ::protobuf::SingularPtrField<ConfigMapKeySelector>,
    secretKeyRef: ::protobuf::SingularPtrField<SecretKeySelector>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for EnvVarSource {}

impl EnvVarSource {
    pub fn new() -> EnvVarSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static EnvVarSource {
        static mut instance: ::protobuf::lazy::Lazy<EnvVarSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EnvVarSource,
        };
        unsafe {
            instance.get(EnvVarSource::new)
        }
    }

    // optional .k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 1;

    pub fn clear_fieldRef(&mut self) {
        self.fieldRef.clear();
    }

    pub fn has_fieldRef(&self) -> bool {
        self.fieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldRef(&mut self, v: ObjectFieldSelector) {
        self.fieldRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldRef(&mut self) -> &mut ObjectFieldSelector {
        if self.fieldRef.is_none() {
            self.fieldRef.set_default();
        }
        self.fieldRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldRef(&mut self) -> ObjectFieldSelector {
        self.fieldRef.take().unwrap_or_else(|| ObjectFieldSelector::new())
    }

    pub fn get_fieldRef(&self) -> &ObjectFieldSelector {
        self.fieldRef.as_ref().unwrap_or_else(|| ObjectFieldSelector::default_instance())
    }

    fn get_fieldRef_for_reflect(&self) -> &::protobuf::SingularPtrField<ObjectFieldSelector> {
        &self.fieldRef
    }

    fn mut_fieldRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ObjectFieldSelector> {
        &mut self.fieldRef
    }

    // optional .k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 2;

    pub fn clear_resourceFieldRef(&mut self) {
        self.resourceFieldRef.clear();
    }

    pub fn has_resourceFieldRef(&self) -> bool {
        self.resourceFieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceFieldRef(&mut self, v: ResourceFieldSelector) {
        self.resourceFieldRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceFieldRef(&mut self) -> &mut ResourceFieldSelector {
        if self.resourceFieldRef.is_none() {
            self.resourceFieldRef.set_default();
        }
        self.resourceFieldRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceFieldRef(&mut self) -> ResourceFieldSelector {
        self.resourceFieldRef.take().unwrap_or_else(|| ResourceFieldSelector::new())
    }

    pub fn get_resourceFieldRef(&self) -> &ResourceFieldSelector {
        self.resourceFieldRef.as_ref().unwrap_or_else(|| ResourceFieldSelector::default_instance())
    }

    fn get_resourceFieldRef_for_reflect(&self) -> &::protobuf::SingularPtrField<ResourceFieldSelector> {
        &self.resourceFieldRef
    }

    fn mut_resourceFieldRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ResourceFieldSelector> {
        &mut self.resourceFieldRef
    }

    // optional .k8s.io.api.core.v1.ConfigMapKeySelector configMapKeyRef = 3;

    pub fn clear_configMapKeyRef(&mut self) {
        self.configMapKeyRef.clear();
    }

    pub fn has_configMapKeyRef(&self) -> bool {
        self.configMapKeyRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMapKeyRef(&mut self, v: ConfigMapKeySelector) {
        self.configMapKeyRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMapKeyRef(&mut self) -> &mut ConfigMapKeySelector {
        if self.configMapKeyRef.is_none() {
            self.configMapKeyRef.set_default();
        }
        self.configMapKeyRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_configMapKeyRef(&mut self) -> ConfigMapKeySelector {
        self.configMapKeyRef.take().unwrap_or_else(|| ConfigMapKeySelector::new())
    }

    pub fn get_configMapKeyRef(&self) -> &ConfigMapKeySelector {
        self.configMapKeyRef.as_ref().unwrap_or_else(|| ConfigMapKeySelector::default_instance())
    }

    fn get_configMapKeyRef_for_reflect(&self) -> &::protobuf::SingularPtrField<ConfigMapKeySelector> {
        &self.configMapKeyRef
    }

    fn mut_configMapKeyRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ConfigMapKeySelector> {
        &mut self.configMapKeyRef
    }

    // optional .k8s.io.api.core.v1.SecretKeySelector secretKeyRef = 4;

    pub fn clear_secretKeyRef(&mut self) {
        self.secretKeyRef.clear();
    }

    pub fn has_secretKeyRef(&self) -> bool {
        self.secretKeyRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretKeyRef(&mut self, v: SecretKeySelector) {
        self.secretKeyRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretKeyRef(&mut self) -> &mut SecretKeySelector {
        if self.secretKeyRef.is_none() {
            self.secretKeyRef.set_default();
        }
        self.secretKeyRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretKeyRef(&mut self) -> SecretKeySelector {
        self.secretKeyRef.take().unwrap_or_else(|| SecretKeySelector::new())
    }

    pub fn get_secretKeyRef(&self) -> &SecretKeySelector {
        self.secretKeyRef.as_ref().unwrap_or_else(|| SecretKeySelector::default_instance())
    }

    fn get_secretKeyRef_for_reflect(&self) -> &::protobuf::SingularPtrField<SecretKeySelector> {
        &self.secretKeyRef
    }

    fn mut_secretKeyRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<SecretKeySelector> {
        &mut self.secretKeyRef
    }
}

impl ::protobuf::Message for EnvVarSource {
    fn is_initialized(&self) -> bool {
        for v in &self.fieldRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resourceFieldRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configMapKeyRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secretKeyRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fieldRef)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resourceFieldRef)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configMapKeyRef)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretKeyRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fieldRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.resourceFieldRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.configMapKeyRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.secretKeyRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fieldRef.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.resourceFieldRef.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.configMapKeyRef.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.secretKeyRef.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for EnvVarSource {
    fn new() -> EnvVarSource {
        EnvVarSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<EnvVarSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectFieldSelector>>(
                    "fieldRef",
                    EnvVarSource::get_fieldRef_for_reflect,
                    EnvVarSource::mut_fieldRef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceFieldSelector>>(
                    "resourceFieldRef",
                    EnvVarSource::get_resourceFieldRef_for_reflect,
                    EnvVarSource::mut_resourceFieldRef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigMapKeySelector>>(
                    "configMapKeyRef",
                    EnvVarSource::get_configMapKeyRef_for_reflect,
                    EnvVarSource::mut_configMapKeyRef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretKeySelector>>(
                    "secretKeyRef",
                    EnvVarSource::get_secretKeyRef_for_reflect,
                    EnvVarSource::mut_secretKeyRef_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EnvVarSource>(
                    "EnvVarSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for EnvVarSource {
    fn clear(&mut self) {
        self.clear_fieldRef();
        self.clear_resourceFieldRef();
        self.clear_configMapKeyRef();
        self.clear_secretKeyRef();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnvVarSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvVarSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Event {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    involvedObject: ::protobuf::SingularPtrField<ObjectReference>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    source: ::protobuf::SingularPtrField<EventSource>,
    firstTimestamp: ::protobuf::SingularPtrField<super::generated::Time>,
    lastTimestamp: ::protobuf::SingularPtrField<super::generated::Time>,
    count: ::std::option::Option<i32>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Event {}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Event {
        static mut instance: ::protobuf::lazy::Lazy<Event> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Event,
        };
        unsafe {
            instance.get(Event::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.ObjectReference involvedObject = 2;

    pub fn clear_involvedObject(&mut self) {
        self.involvedObject.clear();
    }

    pub fn has_involvedObject(&self) -> bool {
        self.involvedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_involvedObject(&mut self, v: ObjectReference) {
        self.involvedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_involvedObject(&mut self) -> &mut ObjectReference {
        if self.involvedObject.is_none() {
            self.involvedObject.set_default();
        }
        self.involvedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_involvedObject(&mut self) -> ObjectReference {
        self.involvedObject.take().unwrap_or_else(|| ObjectReference::new())
    }

    pub fn get_involvedObject(&self) -> &ObjectReference {
        self.involvedObject.as_ref().unwrap_or_else(|| ObjectReference::default_instance())
    }

    fn get_involvedObject_for_reflect(&self) -> &::protobuf::SingularPtrField<ObjectReference> {
        &self.involvedObject
    }

    fn mut_involvedObject_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ObjectReference> {
        &mut self.involvedObject
    }

    // optional string reason = 3;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_reason_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.reason
    }

    // optional string message = 4;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // optional .k8s.io.api.core.v1.EventSource source = 5;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: EventSource) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut EventSource {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> EventSource {
        self.source.take().unwrap_or_else(|| EventSource::new())
    }

    pub fn get_source(&self) -> &EventSource {
        self.source.as_ref().unwrap_or_else(|| EventSource::default_instance())
    }

    fn get_source_for_reflect(&self) -> &::protobuf::SingularPtrField<EventSource> {
        &self.source
    }

    fn mut_source_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<EventSource> {
        &mut self.source
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time firstTimestamp = 6;

    pub fn clear_firstTimestamp(&mut self) {
        self.firstTimestamp.clear();
    }

    pub fn has_firstTimestamp(&self) -> bool {
        self.firstTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstTimestamp(&mut self, v: super::generated::Time) {
        self.firstTimestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstTimestamp(&mut self) -> &mut super::generated::Time {
        if self.firstTimestamp.is_none() {
            self.firstTimestamp.set_default();
        }
        self.firstTimestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_firstTimestamp(&mut self) -> super::generated::Time {
        self.firstTimestamp.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_firstTimestamp(&self) -> &super::generated::Time {
        self.firstTimestamp.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_firstTimestamp_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.firstTimestamp
    }

    fn mut_firstTimestamp_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.firstTimestamp
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTimestamp = 7;

    pub fn clear_lastTimestamp(&mut self) {
        self.lastTimestamp.clear();
    }

    pub fn has_lastTimestamp(&self) -> bool {
        self.lastTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTimestamp(&mut self, v: super::generated::Time) {
        self.lastTimestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTimestamp(&mut self) -> &mut super::generated::Time {
        if self.lastTimestamp.is_none() {
            self.lastTimestamp.set_default();
        }
        self.lastTimestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastTimestamp(&mut self) -> super::generated::Time {
        self.lastTimestamp.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_lastTimestamp(&self) -> &super::generated::Time {
        self.lastTimestamp.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_lastTimestamp_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.lastTimestamp
    }

    fn mut_lastTimestamp_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.lastTimestamp
    }

    // optional int32 count = 8;

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    fn get_count_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.count
    }

    fn mut_count_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.count
    }

    // optional string type = 9;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_field_type_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.field_type
    }
}

impl ::protobuf::Message for Event {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.involvedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.firstTimestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lastTimestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.involvedObject)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.firstTimestamp)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastTimestamp)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.involvedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.firstTimestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lastTimestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.involvedObject.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.firstTimestamp.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lastTimestamp.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.count {
            os.write_int32(8, v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Event {
    fn new() -> Event {
        Event::new()
    }

    fn descriptor_static(_: ::std::option::Option<Event>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    Event::get_metadata_for_reflect,
                    Event::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                    "involvedObject",
                    Event::get_involvedObject_for_reflect,
                    Event::mut_involvedObject_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reason",
                    Event::get_reason_for_reflect,
                    Event::mut_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    Event::get_message_for_reflect,
                    Event::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EventSource>>(
                    "source",
                    Event::get_source_for_reflect,
                    Event::mut_source_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "firstTimestamp",
                    Event::get_firstTimestamp_for_reflect,
                    Event::mut_firstTimestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "lastTimestamp",
                    Event::get_lastTimestamp_for_reflect,
                    Event::mut_lastTimestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "count",
                    Event::get_count_for_reflect,
                    Event::mut_count_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    Event::get_field_type_for_reflect,
                    Event::mut_field_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Event>(
                    "Event",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Event {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_involvedObject();
        self.clear_reason();
        self.clear_message();
        self.clear_source();
        self.clear_firstTimestamp();
        self.clear_lastTimestamp();
        self.clear_count();
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<Event>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for EventList {}

impl EventList {
    pub fn new() -> EventList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static EventList {
        static mut instance: ::protobuf::lazy::Lazy<EventList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EventList,
        };
        unsafe {
            instance.get(EventList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.Event items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Event>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Event> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Event> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[Event] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<Event> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Event> {
        &mut self.items
    }
}

impl ::protobuf::Message for EventList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for EventList {
    fn new() -> EventList {
        EventList::new()
    }

    fn descriptor_static(_: ::std::option::Option<EventList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    EventList::get_metadata_for_reflect,
                    EventList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Event>>(
                    "items",
                    EventList::get_items_for_reflect,
                    EventList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EventList>(
                    "EventList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for EventList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventSource {
    // message fields
    component: ::protobuf::SingularField<::std::string::String>,
    host: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for EventSource {}

impl EventSource {
    pub fn new() -> EventSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static EventSource {
        static mut instance: ::protobuf::lazy::Lazy<EventSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EventSource,
        };
        unsafe {
            instance.get(EventSource::new)
        }
    }

    // optional string component = 1;

    pub fn clear_component(&mut self) {
        self.component.clear();
    }

    pub fn has_component(&self) -> bool {
        self.component.is_some()
    }

    // Param is passed by value, moved
    pub fn set_component(&mut self, v: ::std::string::String) {
        self.component = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_component(&mut self) -> &mut ::std::string::String {
        if self.component.is_none() {
            self.component.set_default();
        }
        self.component.as_mut().unwrap()
    }

    // Take field
    pub fn take_component(&mut self) -> ::std::string::String {
        self.component.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_component(&self) -> &str {
        match self.component.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_component_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.component
    }

    fn mut_component_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.component
    }

    // optional string host = 2;

    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host.set_default();
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_host_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.host
    }

    fn mut_host_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.host
    }
}

impl ::protobuf::Message for EventSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.component)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.component.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.component.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.host.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for EventSource {
    fn new() -> EventSource {
        EventSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<EventSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "component",
                    EventSource::get_component_for_reflect,
                    EventSource::mut_component_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host",
                    EventSource::get_host_for_reflect,
                    EventSource::mut_host_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EventSource>(
                    "EventSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for EventSource {
    fn clear(&mut self) {
        self.clear_component();
        self.clear_host();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecAction {
    // message fields
    command: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ExecAction {}

impl ExecAction {
    pub fn new() -> ExecAction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ExecAction {
        static mut instance: ::protobuf::lazy::Lazy<ExecAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecAction,
        };
        unsafe {
            instance.get(ExecAction::new)
        }
    }

    // repeated string command = 1;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    pub fn get_command(&self) -> &[::std::string::String] {
        &self.command
    }

    fn get_command_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.command
    }

    fn mut_command_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }
}

impl ::protobuf::Message for ExecAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.command)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.command {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ExecAction {
    fn new() -> ExecAction {
        ExecAction::new()
    }

    fn descriptor_static(_: ::std::option::Option<ExecAction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "command",
                    ExecAction::get_command_for_reflect,
                    ExecAction::mut_command_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExecAction>(
                    "ExecAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ExecAction {
    fn clear(&mut self) {
        self.clear_command();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FCVolumeSource {
    // message fields
    targetWWNs: ::protobuf::RepeatedField<::std::string::String>,
    lun: ::std::option::Option<i32>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FCVolumeSource {}

impl FCVolumeSource {
    pub fn new() -> FCVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FCVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<FCVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FCVolumeSource,
        };
        unsafe {
            instance.get(FCVolumeSource::new)
        }
    }

    // repeated string targetWWNs = 1;

    pub fn clear_targetWWNs(&mut self) {
        self.targetWWNs.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetWWNs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.targetWWNs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetWWNs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.targetWWNs
    }

    // Take field
    pub fn take_targetWWNs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.targetWWNs, ::protobuf::RepeatedField::new())
    }

    pub fn get_targetWWNs(&self) -> &[::std::string::String] {
        &self.targetWWNs
    }

    fn get_targetWWNs_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.targetWWNs
    }

    fn mut_targetWWNs_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.targetWWNs
    }

    // optional int32 lun = 2;

    pub fn clear_lun(&mut self) {
        self.lun = ::std::option::Option::None;
    }

    pub fn has_lun(&self) -> bool {
        self.lun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lun(&mut self, v: i32) {
        self.lun = ::std::option::Option::Some(v);
    }

    pub fn get_lun(&self) -> i32 {
        self.lun.unwrap_or(0)
    }

    fn get_lun_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.lun
    }

    fn mut_lun_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.lun
    }

    // optional string fsType = 3;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }

    // optional bool readOnly = 4;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }
}

impl ::protobuf::Message for FCVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.targetWWNs)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lun = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.targetWWNs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.lun {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.targetWWNs {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.lun {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FCVolumeSource {
    fn new() -> FCVolumeSource {
        FCVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<FCVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "targetWWNs",
                    FCVolumeSource::get_targetWWNs_for_reflect,
                    FCVolumeSource::mut_targetWWNs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "lun",
                    FCVolumeSource::get_lun_for_reflect,
                    FCVolumeSource::mut_lun_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    FCVolumeSource::get_fsType_for_reflect,
                    FCVolumeSource::mut_fsType_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    FCVolumeSource::get_readOnly_for_reflect,
                    FCVolumeSource::mut_readOnly_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FCVolumeSource>(
                    "FCVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FCVolumeSource {
    fn clear(&mut self) {
        self.clear_targetWWNs();
        self.clear_lun();
        self.clear_fsType();
        self.clear_readOnly();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FCVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FCVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlexVolumeSource {
    // message fields
    driver: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    secretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    readOnly: ::std::option::Option<bool>,
    pub options: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FlexVolumeSource {}

impl FlexVolumeSource {
    pub fn new() -> FlexVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FlexVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<FlexVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlexVolumeSource,
        };
        unsafe {
            instance.get(FlexVolumeSource::new)
        }
    }

    // optional string driver = 1;

    pub fn clear_driver(&mut self) {
        self.driver.clear();
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver.set_default();
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_driver_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.driver
    }

    fn mut_driver_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.driver
    }

    // optional string fsType = 2;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 3;

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    pub fn get_secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| LocalObjectReference::default_instance())
    }

    fn get_secretRef_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalObjectReference> {
        &self.secretRef
    }

    fn mut_secretRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalObjectReference> {
        &mut self.secretRef
    }

    // optional bool readOnly = 4;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }

    // repeated .k8s.io.api.core.v1.FlexVolumeSource.OptionsEntry options = 5;

    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.options, ::std::collections::HashMap::new())
    }

    pub fn get_options(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.options
    }

    fn get_options_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.options
    }

    fn mut_options_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.options
    }
}

impl ::protobuf::Message for FlexVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.driver)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.options);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.driver.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.options, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FlexVolumeSource {
    fn new() -> FlexVolumeSource {
        FlexVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<FlexVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "driver",
                    FlexVolumeSource::get_driver_for_reflect,
                    FlexVolumeSource::mut_driver_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    FlexVolumeSource::get_fsType_for_reflect,
                    FlexVolumeSource::mut_fsType_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "secretRef",
                    FlexVolumeSource::get_secretRef_for_reflect,
                    FlexVolumeSource::mut_secretRef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    FlexVolumeSource::get_readOnly_for_reflect,
                    FlexVolumeSource::mut_readOnly_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "options",
                    FlexVolumeSource::get_options_for_reflect,
                    FlexVolumeSource::mut_options_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FlexVolumeSource>(
                    "FlexVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FlexVolumeSource {
    fn clear(&mut self) {
        self.clear_driver();
        self.clear_fsType();
        self.clear_secretRef();
        self.clear_readOnly();
        self.clear_options();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlexVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlexVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlockerVolumeSource {
    // message fields
    datasetName: ::protobuf::SingularField<::std::string::String>,
    datasetUUID: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FlockerVolumeSource {}

impl FlockerVolumeSource {
    pub fn new() -> FlockerVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FlockerVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<FlockerVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlockerVolumeSource,
        };
        unsafe {
            instance.get(FlockerVolumeSource::new)
        }
    }

    // optional string datasetName = 1;

    pub fn clear_datasetName(&mut self) {
        self.datasetName.clear();
    }

    pub fn has_datasetName(&self) -> bool {
        self.datasetName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datasetName(&mut self, v: ::std::string::String) {
        self.datasetName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datasetName(&mut self) -> &mut ::std::string::String {
        if self.datasetName.is_none() {
            self.datasetName.set_default();
        }
        self.datasetName.as_mut().unwrap()
    }

    // Take field
    pub fn take_datasetName(&mut self) -> ::std::string::String {
        self.datasetName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_datasetName(&self) -> &str {
        match self.datasetName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_datasetName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.datasetName
    }

    fn mut_datasetName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.datasetName
    }

    // optional string datasetUUID = 2;

    pub fn clear_datasetUUID(&mut self) {
        self.datasetUUID.clear();
    }

    pub fn has_datasetUUID(&self) -> bool {
        self.datasetUUID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datasetUUID(&mut self, v: ::std::string::String) {
        self.datasetUUID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datasetUUID(&mut self) -> &mut ::std::string::String {
        if self.datasetUUID.is_none() {
            self.datasetUUID.set_default();
        }
        self.datasetUUID.as_mut().unwrap()
    }

    // Take field
    pub fn take_datasetUUID(&mut self) -> ::std::string::String {
        self.datasetUUID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_datasetUUID(&self) -> &str {
        match self.datasetUUID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_datasetUUID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.datasetUUID
    }

    fn mut_datasetUUID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.datasetUUID
    }
}

impl ::protobuf::Message for FlockerVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.datasetName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.datasetUUID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.datasetName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.datasetUUID.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.datasetName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.datasetUUID.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FlockerVolumeSource {
    fn new() -> FlockerVolumeSource {
        FlockerVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<FlockerVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "datasetName",
                    FlockerVolumeSource::get_datasetName_for_reflect,
                    FlockerVolumeSource::mut_datasetName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "datasetUUID",
                    FlockerVolumeSource::get_datasetUUID_for_reflect,
                    FlockerVolumeSource::mut_datasetUUID_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FlockerVolumeSource>(
                    "FlockerVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FlockerVolumeSource {
    fn clear(&mut self) {
        self.clear_datasetName();
        self.clear_datasetUUID();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlockerVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlockerVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GCEPersistentDiskVolumeSource {
    // message fields
    pdName: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    partition: ::std::option::Option<i32>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GCEPersistentDiskVolumeSource {}

impl GCEPersistentDiskVolumeSource {
    pub fn new() -> GCEPersistentDiskVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GCEPersistentDiskVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<GCEPersistentDiskVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GCEPersistentDiskVolumeSource,
        };
        unsafe {
            instance.get(GCEPersistentDiskVolumeSource::new)
        }
    }

    // optional string pdName = 1;

    pub fn clear_pdName(&mut self) {
        self.pdName.clear();
    }

    pub fn has_pdName(&self) -> bool {
        self.pdName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pdName(&mut self, v: ::std::string::String) {
        self.pdName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pdName(&mut self) -> &mut ::std::string::String {
        if self.pdName.is_none() {
            self.pdName.set_default();
        }
        self.pdName.as_mut().unwrap()
    }

    // Take field
    pub fn take_pdName(&mut self) -> ::std::string::String {
        self.pdName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_pdName(&self) -> &str {
        match self.pdName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_pdName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.pdName
    }

    fn mut_pdName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.pdName
    }

    // optional string fsType = 2;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }

    // optional int32 partition = 3;

    pub fn clear_partition(&mut self) {
        self.partition = ::std::option::Option::None;
    }

    pub fn has_partition(&self) -> bool {
        self.partition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition(&mut self, v: i32) {
        self.partition = ::std::option::Option::Some(v);
    }

    pub fn get_partition(&self) -> i32 {
        self.partition.unwrap_or(0)
    }

    fn get_partition_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.partition
    }

    fn mut_partition_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.partition
    }

    // optional bool readOnly = 4;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }
}

impl ::protobuf::Message for GCEPersistentDiskVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pdName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.partition = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pdName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.partition {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pdName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.partition {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GCEPersistentDiskVolumeSource {
    fn new() -> GCEPersistentDiskVolumeSource {
        GCEPersistentDiskVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<GCEPersistentDiskVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pdName",
                    GCEPersistentDiskVolumeSource::get_pdName_for_reflect,
                    GCEPersistentDiskVolumeSource::mut_pdName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    GCEPersistentDiskVolumeSource::get_fsType_for_reflect,
                    GCEPersistentDiskVolumeSource::mut_fsType_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "partition",
                    GCEPersistentDiskVolumeSource::get_partition_for_reflect,
                    GCEPersistentDiskVolumeSource::mut_partition_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    GCEPersistentDiskVolumeSource::get_readOnly_for_reflect,
                    GCEPersistentDiskVolumeSource::mut_readOnly_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GCEPersistentDiskVolumeSource>(
                    "GCEPersistentDiskVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GCEPersistentDiskVolumeSource {
    fn clear(&mut self) {
        self.clear_pdName();
        self.clear_fsType();
        self.clear_partition();
        self.clear_readOnly();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GCEPersistentDiskVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GCEPersistentDiskVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GitRepoVolumeSource {
    // message fields
    repository: ::protobuf::SingularField<::std::string::String>,
    revision: ::protobuf::SingularField<::std::string::String>,
    directory: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GitRepoVolumeSource {}

impl GitRepoVolumeSource {
    pub fn new() -> GitRepoVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GitRepoVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<GitRepoVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GitRepoVolumeSource,
        };
        unsafe {
            instance.get(GitRepoVolumeSource::new)
        }
    }

    // optional string repository = 1;

    pub fn clear_repository(&mut self) {
        self.repository.clear();
    }

    pub fn has_repository(&self) -> bool {
        self.repository.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repository(&mut self, v: ::std::string::String) {
        self.repository = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_repository(&mut self) -> &mut ::std::string::String {
        if self.repository.is_none() {
            self.repository.set_default();
        }
        self.repository.as_mut().unwrap()
    }

    // Take field
    pub fn take_repository(&mut self) -> ::std::string::String {
        self.repository.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_repository(&self) -> &str {
        match self.repository.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_repository_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.repository
    }

    fn mut_repository_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.repository
    }

    // optional string revision = 2;

    pub fn clear_revision(&mut self) {
        self.revision.clear();
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::string::String) {
        self.revision = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::string::String {
        if self.revision.is_none() {
            self.revision.set_default();
        }
        self.revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::string::String {
        self.revision.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_revision(&self) -> &str {
        match self.revision.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_revision_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.revision
    }

    fn mut_revision_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.revision
    }

    // optional string directory = 3;

    pub fn clear_directory(&mut self) {
        self.directory.clear();
    }

    pub fn has_directory(&self) -> bool {
        self.directory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directory(&mut self, v: ::std::string::String) {
        self.directory = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directory(&mut self) -> &mut ::std::string::String {
        if self.directory.is_none() {
            self.directory.set_default();
        }
        self.directory.as_mut().unwrap()
    }

    // Take field
    pub fn take_directory(&mut self) -> ::std::string::String {
        self.directory.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_directory(&self) -> &str {
        match self.directory.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_directory_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.directory
    }

    fn mut_directory_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.directory
    }
}

impl ::protobuf::Message for GitRepoVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.repository)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.revision)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.directory)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.repository.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.revision.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.directory.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.repository.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.revision.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.directory.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GitRepoVolumeSource {
    fn new() -> GitRepoVolumeSource {
        GitRepoVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<GitRepoVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "repository",
                    GitRepoVolumeSource::get_repository_for_reflect,
                    GitRepoVolumeSource::mut_repository_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "revision",
                    GitRepoVolumeSource::get_revision_for_reflect,
                    GitRepoVolumeSource::mut_revision_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "directory",
                    GitRepoVolumeSource::get_directory_for_reflect,
                    GitRepoVolumeSource::mut_directory_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GitRepoVolumeSource>(
                    "GitRepoVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GitRepoVolumeSource {
    fn clear(&mut self) {
        self.clear_repository();
        self.clear_revision();
        self.clear_directory();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GitRepoVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GitRepoVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlusterfsVolumeSource {
    // message fields
    endpoints: ::protobuf::SingularField<::std::string::String>,
    path: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for GlusterfsVolumeSource {}

impl GlusterfsVolumeSource {
    pub fn new() -> GlusterfsVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static GlusterfsVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<GlusterfsVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GlusterfsVolumeSource,
        };
        unsafe {
            instance.get(GlusterfsVolumeSource::new)
        }
    }

    // optional string endpoints = 1;

    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    pub fn has_endpoints(&self) -> bool {
        self.endpoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::std::string::String) {
        self.endpoints = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoints(&mut self) -> &mut ::std::string::String {
        if self.endpoints.is_none() {
            self.endpoints.set_default();
        }
        self.endpoints.as_mut().unwrap()
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::std::string::String {
        self.endpoints.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_endpoints(&self) -> &str {
        match self.endpoints.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_endpoints_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.endpoints
    }

    fn mut_endpoints_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.endpoints
    }

    // optional string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional bool readOnly = 3;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }
}

impl ::protobuf::Message for GlusterfsVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.endpoints)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.endpoints.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.endpoints.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for GlusterfsVolumeSource {
    fn new() -> GlusterfsVolumeSource {
        GlusterfsVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<GlusterfsVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "endpoints",
                    GlusterfsVolumeSource::get_endpoints_for_reflect,
                    GlusterfsVolumeSource::mut_endpoints_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    GlusterfsVolumeSource::get_path_for_reflect,
                    GlusterfsVolumeSource::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    GlusterfsVolumeSource::get_readOnly_for_reflect,
                    GlusterfsVolumeSource::mut_readOnly_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GlusterfsVolumeSource>(
                    "GlusterfsVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for GlusterfsVolumeSource {
    fn clear(&mut self) {
        self.clear_endpoints();
        self.clear_path();
        self.clear_readOnly();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlusterfsVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlusterfsVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPGetAction {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    port: ::protobuf::SingularPtrField<super::generated::IntOrString>,
    host: ::protobuf::SingularField<::std::string::String>,
    scheme: ::protobuf::SingularField<::std::string::String>,
    httpHeaders: ::protobuf::RepeatedField<HTTPHeader>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for HTTPGetAction {}

impl HTTPGetAction {
    pub fn new() -> HTTPGetAction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HTTPGetAction {
        static mut instance: ::protobuf::lazy::Lazy<HTTPGetAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HTTPGetAction,
        };
        unsafe {
            instance.get(HTTPGetAction::new)
        }
    }

    // optional string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;

    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: super::generated::IntOrString) {
        self.port = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut super::generated::IntOrString {
        if self.port.is_none() {
            self.port.set_default();
        }
        self.port.as_mut().unwrap()
    }

    // Take field
    pub fn take_port(&mut self) -> super::generated::IntOrString {
        self.port.take().unwrap_or_else(|| super::generated::IntOrString::new())
    }

    pub fn get_port(&self) -> &super::generated::IntOrString {
        self.port.as_ref().unwrap_or_else(|| super::generated::IntOrString::default_instance())
    }

    fn get_port_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::IntOrString> {
        &self.port
    }

    fn mut_port_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::IntOrString> {
        &mut self.port
    }

    // optional string host = 3;

    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host.set_default();
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_host_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.host
    }

    fn mut_host_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.host
    }

    // optional string scheme = 4;

    pub fn clear_scheme(&mut self) {
        self.scheme.clear();
    }

    pub fn has_scheme(&self) -> bool {
        self.scheme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheme(&mut self, v: ::std::string::String) {
        self.scheme = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheme(&mut self) -> &mut ::std::string::String {
        if self.scheme.is_none() {
            self.scheme.set_default();
        }
        self.scheme.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheme(&mut self) -> ::std::string::String {
        self.scheme.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_scheme(&self) -> &str {
        match self.scheme.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_scheme_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.scheme
    }

    fn mut_scheme_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.scheme
    }

    // repeated .k8s.io.api.core.v1.HTTPHeader httpHeaders = 5;

    pub fn clear_httpHeaders(&mut self) {
        self.httpHeaders.clear();
    }

    // Param is passed by value, moved
    pub fn set_httpHeaders(&mut self, v: ::protobuf::RepeatedField<HTTPHeader>) {
        self.httpHeaders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_httpHeaders(&mut self) -> &mut ::protobuf::RepeatedField<HTTPHeader> {
        &mut self.httpHeaders
    }

    // Take field
    pub fn take_httpHeaders(&mut self) -> ::protobuf::RepeatedField<HTTPHeader> {
        ::std::mem::replace(&mut self.httpHeaders, ::protobuf::RepeatedField::new())
    }

    pub fn get_httpHeaders(&self) -> &[HTTPHeader] {
        &self.httpHeaders
    }

    fn get_httpHeaders_for_reflect(&self) -> &::protobuf::RepeatedField<HTTPHeader> {
        &self.httpHeaders
    }

    fn mut_httpHeaders_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<HTTPHeader> {
        &mut self.httpHeaders
    }
}

impl ::protobuf::Message for HTTPGetAction {
    fn is_initialized(&self) -> bool {
        for v in &self.port {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.httpHeaders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.port)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.scheme)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.httpHeaders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.scheme.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.httpHeaders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.port.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.host.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.scheme.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.httpHeaders {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for HTTPGetAction {
    fn new() -> HTTPGetAction {
        HTTPGetAction::new()
    }

    fn descriptor_static(_: ::std::option::Option<HTTPGetAction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    HTTPGetAction::get_path_for_reflect,
                    HTTPGetAction::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::IntOrString>>(
                    "port",
                    HTTPGetAction::get_port_for_reflect,
                    HTTPGetAction::mut_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host",
                    HTTPGetAction::get_host_for_reflect,
                    HTTPGetAction::mut_host_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "scheme",
                    HTTPGetAction::get_scheme_for_reflect,
                    HTTPGetAction::mut_scheme_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPHeader>>(
                    "httpHeaders",
                    HTTPGetAction::get_httpHeaders_for_reflect,
                    HTTPGetAction::mut_httpHeaders_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HTTPGetAction>(
                    "HTTPGetAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for HTTPGetAction {
    fn clear(&mut self) {
        self.clear_path();
        self.clear_port();
        self.clear_host();
        self.clear_scheme();
        self.clear_httpHeaders();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPGetAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPGetAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPHeader {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for HTTPHeader {}

impl HTTPHeader {
    pub fn new() -> HTTPHeader {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HTTPHeader {
        static mut instance: ::protobuf::lazy::Lazy<HTTPHeader> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HTTPHeader,
        };
        unsafe {
            instance.get(HTTPHeader::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for HTTPHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for HTTPHeader {
    fn new() -> HTTPHeader {
        HTTPHeader::new()
    }

    fn descriptor_static(_: ::std::option::Option<HTTPHeader>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    HTTPHeader::get_name_for_reflect,
                    HTTPHeader::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    HTTPHeader::get_value_for_reflect,
                    HTTPHeader::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HTTPHeader>(
                    "HTTPHeader",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for HTTPHeader {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Handler {
    // message fields
    exec: ::protobuf::SingularPtrField<ExecAction>,
    httpGet: ::protobuf::SingularPtrField<HTTPGetAction>,
    tcpSocket: ::protobuf::SingularPtrField<TCPSocketAction>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Handler {}

impl Handler {
    pub fn new() -> Handler {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Handler {
        static mut instance: ::protobuf::lazy::Lazy<Handler> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Handler,
        };
        unsafe {
            instance.get(Handler::new)
        }
    }

    // optional .k8s.io.api.core.v1.ExecAction exec = 1;

    pub fn clear_exec(&mut self) {
        self.exec.clear();
    }

    pub fn has_exec(&self) -> bool {
        self.exec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec(&mut self, v: ExecAction) {
        self.exec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec(&mut self) -> &mut ExecAction {
        if self.exec.is_none() {
            self.exec.set_default();
        }
        self.exec.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec(&mut self) -> ExecAction {
        self.exec.take().unwrap_or_else(|| ExecAction::new())
    }

    pub fn get_exec(&self) -> &ExecAction {
        self.exec.as_ref().unwrap_or_else(|| ExecAction::default_instance())
    }

    fn get_exec_for_reflect(&self) -> &::protobuf::SingularPtrField<ExecAction> {
        &self.exec
    }

    fn mut_exec_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ExecAction> {
        &mut self.exec
    }

    // optional .k8s.io.api.core.v1.HTTPGetAction httpGet = 2;

    pub fn clear_httpGet(&mut self) {
        self.httpGet.clear();
    }

    pub fn has_httpGet(&self) -> bool {
        self.httpGet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_httpGet(&mut self, v: HTTPGetAction) {
        self.httpGet = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_httpGet(&mut self) -> &mut HTTPGetAction {
        if self.httpGet.is_none() {
            self.httpGet.set_default();
        }
        self.httpGet.as_mut().unwrap()
    }

    // Take field
    pub fn take_httpGet(&mut self) -> HTTPGetAction {
        self.httpGet.take().unwrap_or_else(|| HTTPGetAction::new())
    }

    pub fn get_httpGet(&self) -> &HTTPGetAction {
        self.httpGet.as_ref().unwrap_or_else(|| HTTPGetAction::default_instance())
    }

    fn get_httpGet_for_reflect(&self) -> &::protobuf::SingularPtrField<HTTPGetAction> {
        &self.httpGet
    }

    fn mut_httpGet_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<HTTPGetAction> {
        &mut self.httpGet
    }

    // optional .k8s.io.api.core.v1.TCPSocketAction tcpSocket = 3;

    pub fn clear_tcpSocket(&mut self) {
        self.tcpSocket.clear();
    }

    pub fn has_tcpSocket(&self) -> bool {
        self.tcpSocket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcpSocket(&mut self, v: TCPSocketAction) {
        self.tcpSocket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tcpSocket(&mut self) -> &mut TCPSocketAction {
        if self.tcpSocket.is_none() {
            self.tcpSocket.set_default();
        }
        self.tcpSocket.as_mut().unwrap()
    }

    // Take field
    pub fn take_tcpSocket(&mut self) -> TCPSocketAction {
        self.tcpSocket.take().unwrap_or_else(|| TCPSocketAction::new())
    }

    pub fn get_tcpSocket(&self) -> &TCPSocketAction {
        self.tcpSocket.as_ref().unwrap_or_else(|| TCPSocketAction::default_instance())
    }

    fn get_tcpSocket_for_reflect(&self) -> &::protobuf::SingularPtrField<TCPSocketAction> {
        &self.tcpSocket
    }

    fn mut_tcpSocket_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<TCPSocketAction> {
        &mut self.tcpSocket
    }
}

impl ::protobuf::Message for Handler {
    fn is_initialized(&self) -> bool {
        for v in &self.exec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.httpGet {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tcpSocket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.httpGet)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tcpSocket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.exec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.httpGet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tcpSocket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.exec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.httpGet.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tcpSocket.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Handler {
    fn new() -> Handler {
        Handler::new()
    }

    fn descriptor_static(_: ::std::option::Option<Handler>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecAction>>(
                    "exec",
                    Handler::get_exec_for_reflect,
                    Handler::mut_exec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPGetAction>>(
                    "httpGet",
                    Handler::get_httpGet_for_reflect,
                    Handler::mut_httpGet_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TCPSocketAction>>(
                    "tcpSocket",
                    Handler::get_tcpSocket_for_reflect,
                    Handler::mut_tcpSocket_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Handler>(
                    "Handler",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Handler {
    fn clear(&mut self) {
        self.clear_exec();
        self.clear_httpGet();
        self.clear_tcpSocket();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Handler {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Handler {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HostAlias {
    // message fields
    ip: ::protobuf::SingularField<::std::string::String>,
    hostnames: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for HostAlias {}

impl HostAlias {
    pub fn new() -> HostAlias {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HostAlias {
        static mut instance: ::protobuf::lazy::Lazy<HostAlias> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HostAlias,
        };
        unsafe {
            instance.get(HostAlias::new)
        }
    }

    // optional string ip = 1;

    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip.set_default();
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_ip_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.ip
    }

    fn mut_ip_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.ip
    }

    // repeated string hostnames = 2;

    pub fn clear_hostnames(&mut self) {
        self.hostnames.clear();
    }

    // Param is passed by value, moved
    pub fn set_hostnames(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.hostnames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hostnames(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.hostnames
    }

    // Take field
    pub fn take_hostnames(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.hostnames, ::protobuf::RepeatedField::new())
    }

    pub fn get_hostnames(&self) -> &[::std::string::String] {
        &self.hostnames
    }

    fn get_hostnames_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.hostnames
    }

    fn mut_hostnames_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.hostnames
    }
}

impl ::protobuf::Message for HostAlias {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.hostnames)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.hostnames {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ip.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.hostnames {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for HostAlias {
    fn new() -> HostAlias {
        HostAlias::new()
    }

    fn descriptor_static(_: ::std::option::Option<HostAlias>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip",
                    HostAlias::get_ip_for_reflect,
                    HostAlias::mut_ip_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostnames",
                    HostAlias::get_hostnames_for_reflect,
                    HostAlias::mut_hostnames_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HostAlias>(
                    "HostAlias",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for HostAlias {
    fn clear(&mut self) {
        self.clear_ip();
        self.clear_hostnames();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HostAlias {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HostAlias {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HostPathVolumeSource {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for HostPathVolumeSource {}

impl HostPathVolumeSource {
    pub fn new() -> HostPathVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HostPathVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<HostPathVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HostPathVolumeSource,
        };
        unsafe {
            instance.get(HostPathVolumeSource::new)
        }
    }

    // optional string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }
}

impl ::protobuf::Message for HostPathVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for HostPathVolumeSource {
    fn new() -> HostPathVolumeSource {
        HostPathVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<HostPathVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    HostPathVolumeSource::get_path_for_reflect,
                    HostPathVolumeSource::mut_path_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HostPathVolumeSource>(
                    "HostPathVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for HostPathVolumeSource {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HostPathVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HostPathVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ISCSIVolumeSource {
    // message fields
    targetPortal: ::protobuf::SingularField<::std::string::String>,
    iqn: ::protobuf::SingularField<::std::string::String>,
    lun: ::std::option::Option<i32>,
    iscsiInterface: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    portals: ::protobuf::RepeatedField<::std::string::String>,
    chapAuthDiscovery: ::std::option::Option<bool>,
    chapAuthSession: ::std::option::Option<bool>,
    secretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ISCSIVolumeSource {}

impl ISCSIVolumeSource {
    pub fn new() -> ISCSIVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ISCSIVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<ISCSIVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ISCSIVolumeSource,
        };
        unsafe {
            instance.get(ISCSIVolumeSource::new)
        }
    }

    // optional string targetPortal = 1;

    pub fn clear_targetPortal(&mut self) {
        self.targetPortal.clear();
    }

    pub fn has_targetPortal(&self) -> bool {
        self.targetPortal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPortal(&mut self, v: ::std::string::String) {
        self.targetPortal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPortal(&mut self) -> &mut ::std::string::String {
        if self.targetPortal.is_none() {
            self.targetPortal.set_default();
        }
        self.targetPortal.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPortal(&mut self) -> ::std::string::String {
        self.targetPortal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_targetPortal(&self) -> &str {
        match self.targetPortal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_targetPortal_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.targetPortal
    }

    fn mut_targetPortal_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.targetPortal
    }

    // optional string iqn = 2;

    pub fn clear_iqn(&mut self) {
        self.iqn.clear();
    }

    pub fn has_iqn(&self) -> bool {
        self.iqn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iqn(&mut self, v: ::std::string::String) {
        self.iqn = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iqn(&mut self) -> &mut ::std::string::String {
        if self.iqn.is_none() {
            self.iqn.set_default();
        }
        self.iqn.as_mut().unwrap()
    }

    // Take field
    pub fn take_iqn(&mut self) -> ::std::string::String {
        self.iqn.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_iqn(&self) -> &str {
        match self.iqn.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_iqn_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.iqn
    }

    fn mut_iqn_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.iqn
    }

    // optional int32 lun = 3;

    pub fn clear_lun(&mut self) {
        self.lun = ::std::option::Option::None;
    }

    pub fn has_lun(&self) -> bool {
        self.lun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lun(&mut self, v: i32) {
        self.lun = ::std::option::Option::Some(v);
    }

    pub fn get_lun(&self) -> i32 {
        self.lun.unwrap_or(0)
    }

    fn get_lun_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.lun
    }

    fn mut_lun_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.lun
    }

    // optional string iscsiInterface = 4;

    pub fn clear_iscsiInterface(&mut self) {
        self.iscsiInterface.clear();
    }

    pub fn has_iscsiInterface(&self) -> bool {
        self.iscsiInterface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iscsiInterface(&mut self, v: ::std::string::String) {
        self.iscsiInterface = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iscsiInterface(&mut self) -> &mut ::std::string::String {
        if self.iscsiInterface.is_none() {
            self.iscsiInterface.set_default();
        }
        self.iscsiInterface.as_mut().unwrap()
    }

    // Take field
    pub fn take_iscsiInterface(&mut self) -> ::std::string::String {
        self.iscsiInterface.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_iscsiInterface(&self) -> &str {
        match self.iscsiInterface.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_iscsiInterface_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.iscsiInterface
    }

    fn mut_iscsiInterface_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.iscsiInterface
    }

    // optional string fsType = 5;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }

    // optional bool readOnly = 6;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }

    // repeated string portals = 7;

    pub fn clear_portals(&mut self) {
        self.portals.clear();
    }

    // Param is passed by value, moved
    pub fn set_portals(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.portals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_portals(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.portals
    }

    // Take field
    pub fn take_portals(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.portals, ::protobuf::RepeatedField::new())
    }

    pub fn get_portals(&self) -> &[::std::string::String] {
        &self.portals
    }

    fn get_portals_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.portals
    }

    fn mut_portals_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.portals
    }

    // optional bool chapAuthDiscovery = 8;

    pub fn clear_chapAuthDiscovery(&mut self) {
        self.chapAuthDiscovery = ::std::option::Option::None;
    }

    pub fn has_chapAuthDiscovery(&self) -> bool {
        self.chapAuthDiscovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chapAuthDiscovery(&mut self, v: bool) {
        self.chapAuthDiscovery = ::std::option::Option::Some(v);
    }

    pub fn get_chapAuthDiscovery(&self) -> bool {
        self.chapAuthDiscovery.unwrap_or(false)
    }

    fn get_chapAuthDiscovery_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.chapAuthDiscovery
    }

    fn mut_chapAuthDiscovery_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.chapAuthDiscovery
    }

    // optional bool chapAuthSession = 11;

    pub fn clear_chapAuthSession(&mut self) {
        self.chapAuthSession = ::std::option::Option::None;
    }

    pub fn has_chapAuthSession(&self) -> bool {
        self.chapAuthSession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chapAuthSession(&mut self, v: bool) {
        self.chapAuthSession = ::std::option::Option::Some(v);
    }

    pub fn get_chapAuthSession(&self) -> bool {
        self.chapAuthSession.unwrap_or(false)
    }

    fn get_chapAuthSession_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.chapAuthSession
    }

    fn mut_chapAuthSession_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.chapAuthSession
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 10;

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    pub fn get_secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| LocalObjectReference::default_instance())
    }

    fn get_secretRef_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalObjectReference> {
        &self.secretRef
    }

    fn mut_secretRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalObjectReference> {
        &mut self.secretRef
    }
}

impl ::protobuf::Message for ISCSIVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetPortal)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iqn)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lun = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iscsiInterface)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.portals)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chapAuthDiscovery = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chapAuthSession = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.targetPortal.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.iqn.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lun {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.iscsiInterface.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        for value in &self.portals {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.chapAuthDiscovery {
            my_size += 2;
        }
        if let Some(v) = self.chapAuthSession {
            my_size += 2;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.targetPortal.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.iqn.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.lun {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.iscsiInterface.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(6, v)?;
        }
        for v in &self.portals {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.chapAuthDiscovery {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.chapAuthSession {
            os.write_bool(11, v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ISCSIVolumeSource {
    fn new() -> ISCSIVolumeSource {
        ISCSIVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<ISCSIVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "targetPortal",
                    ISCSIVolumeSource::get_targetPortal_for_reflect,
                    ISCSIVolumeSource::mut_targetPortal_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "iqn",
                    ISCSIVolumeSource::get_iqn_for_reflect,
                    ISCSIVolumeSource::mut_iqn_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "lun",
                    ISCSIVolumeSource::get_lun_for_reflect,
                    ISCSIVolumeSource::mut_lun_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "iscsiInterface",
                    ISCSIVolumeSource::get_iscsiInterface_for_reflect,
                    ISCSIVolumeSource::mut_iscsiInterface_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    ISCSIVolumeSource::get_fsType_for_reflect,
                    ISCSIVolumeSource::mut_fsType_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    ISCSIVolumeSource::get_readOnly_for_reflect,
                    ISCSIVolumeSource::mut_readOnly_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "portals",
                    ISCSIVolumeSource::get_portals_for_reflect,
                    ISCSIVolumeSource::mut_portals_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "chapAuthDiscovery",
                    ISCSIVolumeSource::get_chapAuthDiscovery_for_reflect,
                    ISCSIVolumeSource::mut_chapAuthDiscovery_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "chapAuthSession",
                    ISCSIVolumeSource::get_chapAuthSession_for_reflect,
                    ISCSIVolumeSource::mut_chapAuthSession_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "secretRef",
                    ISCSIVolumeSource::get_secretRef_for_reflect,
                    ISCSIVolumeSource::mut_secretRef_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ISCSIVolumeSource>(
                    "ISCSIVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ISCSIVolumeSource {
    fn clear(&mut self) {
        self.clear_targetPortal();
        self.clear_iqn();
        self.clear_lun();
        self.clear_iscsiInterface();
        self.clear_fsType();
        self.clear_readOnly();
        self.clear_portals();
        self.clear_chapAuthDiscovery();
        self.clear_chapAuthSession();
        self.clear_secretRef();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ISCSIVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ISCSIVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyToPath {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    path: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for KeyToPath {}

impl KeyToPath {
    pub fn new() -> KeyToPath {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static KeyToPath {
        static mut instance: ::protobuf::lazy::Lazy<KeyToPath> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeyToPath,
        };
        unsafe {
            instance.get(KeyToPath::new)
        }
    }

    // optional string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_key_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.key
    }

    fn mut_key_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.key
    }

    // optional string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional int32 mode = 3;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }

    fn get_mode_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.mode
    }

    fn mut_mode_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.mode
    }
}

impl ::protobuf::Message for KeyToPath {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.mode {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for KeyToPath {
    fn new() -> KeyToPath {
        KeyToPath::new()
    }

    fn descriptor_static(_: ::std::option::Option<KeyToPath>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    KeyToPath::get_key_for_reflect,
                    KeyToPath::mut_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    KeyToPath::get_path_for_reflect,
                    KeyToPath::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mode",
                    KeyToPath::get_mode_for_reflect,
                    KeyToPath::mut_mode_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeyToPath>(
                    "KeyToPath",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for KeyToPath {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_path();
        self.clear_mode();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyToPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyToPath {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Lifecycle {
    // message fields
    postStart: ::protobuf::SingularPtrField<Handler>,
    preStop: ::protobuf::SingularPtrField<Handler>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Lifecycle {}

impl Lifecycle {
    pub fn new() -> Lifecycle {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Lifecycle {
        static mut instance: ::protobuf::lazy::Lazy<Lifecycle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Lifecycle,
        };
        unsafe {
            instance.get(Lifecycle::new)
        }
    }

    // optional .k8s.io.api.core.v1.Handler postStart = 1;

    pub fn clear_postStart(&mut self) {
        self.postStart.clear();
    }

    pub fn has_postStart(&self) -> bool {
        self.postStart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postStart(&mut self, v: Handler) {
        self.postStart = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postStart(&mut self) -> &mut Handler {
        if self.postStart.is_none() {
            self.postStart.set_default();
        }
        self.postStart.as_mut().unwrap()
    }

    // Take field
    pub fn take_postStart(&mut self) -> Handler {
        self.postStart.take().unwrap_or_else(|| Handler::new())
    }

    pub fn get_postStart(&self) -> &Handler {
        self.postStart.as_ref().unwrap_or_else(|| Handler::default_instance())
    }

    fn get_postStart_for_reflect(&self) -> &::protobuf::SingularPtrField<Handler> {
        &self.postStart
    }

    fn mut_postStart_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Handler> {
        &mut self.postStart
    }

    // optional .k8s.io.api.core.v1.Handler preStop = 2;

    pub fn clear_preStop(&mut self) {
        self.preStop.clear();
    }

    pub fn has_preStop(&self) -> bool {
        self.preStop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preStop(&mut self, v: Handler) {
        self.preStop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preStop(&mut self) -> &mut Handler {
        if self.preStop.is_none() {
            self.preStop.set_default();
        }
        self.preStop.as_mut().unwrap()
    }

    // Take field
    pub fn take_preStop(&mut self) -> Handler {
        self.preStop.take().unwrap_or_else(|| Handler::new())
    }

    pub fn get_preStop(&self) -> &Handler {
        self.preStop.as_ref().unwrap_or_else(|| Handler::default_instance())
    }

    fn get_preStop_for_reflect(&self) -> &::protobuf::SingularPtrField<Handler> {
        &self.preStop
    }

    fn mut_preStop_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Handler> {
        &mut self.preStop
    }
}

impl ::protobuf::Message for Lifecycle {
    fn is_initialized(&self) -> bool {
        for v in &self.postStart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preStop {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postStart)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preStop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.postStart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.preStop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.postStart.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.preStop.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Lifecycle {
    fn new() -> Lifecycle {
        Lifecycle::new()
    }

    fn descriptor_static(_: ::std::option::Option<Lifecycle>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Handler>>(
                    "postStart",
                    Lifecycle::get_postStart_for_reflect,
                    Lifecycle::mut_postStart_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Handler>>(
                    "preStop",
                    Lifecycle::get_preStop_for_reflect,
                    Lifecycle::mut_preStop_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Lifecycle>(
                    "Lifecycle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Lifecycle {
    fn clear(&mut self) {
        self.clear_postStart();
        self.clear_preStop();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Lifecycle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Lifecycle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LimitRange {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    spec: ::protobuf::SingularPtrField<LimitRangeSpec>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for LimitRange {}

impl LimitRange {
    pub fn new() -> LimitRange {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static LimitRange {
        static mut instance: ::protobuf::lazy::Lazy<LimitRange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LimitRange,
        };
        unsafe {
            instance.get(LimitRange::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.LimitRangeSpec spec = 2;

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: LimitRangeSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut LimitRangeSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> LimitRangeSpec {
        self.spec.take().unwrap_or_else(|| LimitRangeSpec::new())
    }

    pub fn get_spec(&self) -> &LimitRangeSpec {
        self.spec.as_ref().unwrap_or_else(|| LimitRangeSpec::default_instance())
    }

    fn get_spec_for_reflect(&self) -> &::protobuf::SingularPtrField<LimitRangeSpec> {
        &self.spec
    }

    fn mut_spec_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LimitRangeSpec> {
        &mut self.spec
    }
}

impl ::protobuf::Message for LimitRange {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for LimitRange {
    fn new() -> LimitRange {
        LimitRange::new()
    }

    fn descriptor_static(_: ::std::option::Option<LimitRange>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    LimitRange::get_metadata_for_reflect,
                    LimitRange::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LimitRangeSpec>>(
                    "spec",
                    LimitRange::get_spec_for_reflect,
                    LimitRange::mut_spec_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LimitRange>(
                    "LimitRange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for LimitRange {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_spec();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LimitRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitRange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LimitRangeItem {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    pub max: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    pub min: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    pub default: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    pub defaultRequest: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    pub maxLimitRequestRatio: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for LimitRangeItem {}

impl LimitRangeItem {
    pub fn new() -> LimitRangeItem {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static LimitRangeItem {
        static mut instance: ::protobuf::lazy::Lazy<LimitRangeItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LimitRangeItem,
        };
        unsafe {
            instance.get(LimitRangeItem::new)
        }
    }

    // optional string type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_field_type_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.field_type
    }

    // repeated .k8s.io.api.core.v1.LimitRangeItem.MaxEntry max = 2;

    pub fn clear_max(&mut self) {
        self.max.clear();
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.max = v;
    }

    // Mutable pointer to the field.
    pub fn mut_max(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.max
    }

    // Take field
    pub fn take_max(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.max, ::std::collections::HashMap::new())
    }

    pub fn get_max(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.max
    }

    fn get_max_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.max
    }

    fn mut_max_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.max
    }

    // repeated .k8s.io.api.core.v1.LimitRangeItem.MinEntry min = 3;

    pub fn clear_min(&mut self) {
        self.min.clear();
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.min = v;
    }

    // Mutable pointer to the field.
    pub fn mut_min(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.min
    }

    // Take field
    pub fn take_min(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.min, ::std::collections::HashMap::new())
    }

    pub fn get_min(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.min
    }

    fn get_min_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.min
    }

    fn mut_min_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.min
    }

    // repeated .k8s.io.api.core.v1.LimitRangeItem.DefaultEntry default = 4;

    pub fn clear_default(&mut self) {
        self.default.clear();
    }

    // Param is passed by value, moved
    pub fn set_default(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.default = v;
    }

    // Mutable pointer to the field.
    pub fn mut_default(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.default
    }

    // Take field
    pub fn take_default(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.default, ::std::collections::HashMap::new())
    }

    pub fn get_default(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.default
    }

    fn get_default_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.default
    }

    fn mut_default_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.default
    }

    // repeated .k8s.io.api.core.v1.LimitRangeItem.DefaultRequestEntry defaultRequest = 5;

    pub fn clear_defaultRequest(&mut self) {
        self.defaultRequest.clear();
    }

    // Param is passed by value, moved
    pub fn set_defaultRequest(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.defaultRequest = v;
    }

    // Mutable pointer to the field.
    pub fn mut_defaultRequest(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.defaultRequest
    }

    // Take field
    pub fn take_defaultRequest(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.defaultRequest, ::std::collections::HashMap::new())
    }

    pub fn get_defaultRequest(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.defaultRequest
    }

    fn get_defaultRequest_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.defaultRequest
    }

    fn mut_defaultRequest_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.defaultRequest
    }

    // repeated .k8s.io.api.core.v1.LimitRangeItem.MaxLimitRequestRatioEntry maxLimitRequestRatio = 6;

    pub fn clear_maxLimitRequestRatio(&mut self) {
        self.maxLimitRequestRatio.clear();
    }

    // Param is passed by value, moved
    pub fn set_maxLimitRequestRatio(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.maxLimitRequestRatio = v;
    }

    // Mutable pointer to the field.
    pub fn mut_maxLimitRequestRatio(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.maxLimitRequestRatio
    }

    // Take field
    pub fn take_maxLimitRequestRatio(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.maxLimitRequestRatio, ::std::collections::HashMap::new())
    }

    pub fn get_maxLimitRequestRatio(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.maxLimitRequestRatio
    }

    fn get_maxLimitRequestRatio_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.maxLimitRequestRatio
    }

    fn mut_maxLimitRequestRatio_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.maxLimitRequestRatio
    }
}

impl ::protobuf::Message for LimitRangeItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.max)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.min)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.default)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.defaultRequest)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.maxLimitRequestRatio)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(2, &self.max);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(3, &self.min);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(4, &self.default);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(5, &self.defaultRequest);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(6, &self.maxLimitRequestRatio);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(2, &self.max, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(3, &self.min, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(4, &self.default, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(5, &self.defaultRequest, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(6, &self.maxLimitRequestRatio, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for LimitRangeItem {
    fn new() -> LimitRangeItem {
        LimitRangeItem::new()
    }

    fn descriptor_static(_: ::std::option::Option<LimitRangeItem>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    LimitRangeItem::get_field_type_for_reflect,
                    LimitRangeItem::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "max",
                    LimitRangeItem::get_max_for_reflect,
                    LimitRangeItem::mut_max_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "min",
                    LimitRangeItem::get_min_for_reflect,
                    LimitRangeItem::mut_min_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "default",
                    LimitRangeItem::get_default_for_reflect,
                    LimitRangeItem::mut_default_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "defaultRequest",
                    LimitRangeItem::get_defaultRequest_for_reflect,
                    LimitRangeItem::mut_defaultRequest_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "maxLimitRequestRatio",
                    LimitRangeItem::get_maxLimitRequestRatio_for_reflect,
                    LimitRangeItem::mut_maxLimitRequestRatio_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LimitRangeItem>(
                    "LimitRangeItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for LimitRangeItem {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_max();
        self.clear_min();
        self.clear_default();
        self.clear_defaultRequest();
        self.clear_maxLimitRequestRatio();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LimitRangeItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitRangeItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LimitRangeList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<LimitRange>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for LimitRangeList {}

impl LimitRangeList {
    pub fn new() -> LimitRangeList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static LimitRangeList {
        static mut instance: ::protobuf::lazy::Lazy<LimitRangeList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LimitRangeList,
        };
        unsafe {
            instance.get(LimitRangeList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.LimitRange items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<LimitRange>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<LimitRange> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<LimitRange> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[LimitRange] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<LimitRange> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<LimitRange> {
        &mut self.items
    }
}

impl ::protobuf::Message for LimitRangeList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for LimitRangeList {
    fn new() -> LimitRangeList {
        LimitRangeList::new()
    }

    fn descriptor_static(_: ::std::option::Option<LimitRangeList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    LimitRangeList::get_metadata_for_reflect,
                    LimitRangeList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LimitRange>>(
                    "items",
                    LimitRangeList::get_items_for_reflect,
                    LimitRangeList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LimitRangeList>(
                    "LimitRangeList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for LimitRangeList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LimitRangeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitRangeList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LimitRangeSpec {
    // message fields
    limits: ::protobuf::RepeatedField<LimitRangeItem>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for LimitRangeSpec {}

impl LimitRangeSpec {
    pub fn new() -> LimitRangeSpec {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static LimitRangeSpec {
        static mut instance: ::protobuf::lazy::Lazy<LimitRangeSpec> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LimitRangeSpec,
        };
        unsafe {
            instance.get(LimitRangeSpec::new)
        }
    }

    // repeated .k8s.io.api.core.v1.LimitRangeItem limits = 1;

    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: ::protobuf::RepeatedField<LimitRangeItem>) {
        self.limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limits(&mut self) -> &mut ::protobuf::RepeatedField<LimitRangeItem> {
        &mut self.limits
    }

    // Take field
    pub fn take_limits(&mut self) -> ::protobuf::RepeatedField<LimitRangeItem> {
        ::std::mem::replace(&mut self.limits, ::protobuf::RepeatedField::new())
    }

    pub fn get_limits(&self) -> &[LimitRangeItem] {
        &self.limits
    }

    fn get_limits_for_reflect(&self) -> &::protobuf::RepeatedField<LimitRangeItem> {
        &self.limits
    }

    fn mut_limits_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<LimitRangeItem> {
        &mut self.limits
    }
}

impl ::protobuf::Message for LimitRangeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.limits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.limits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.limits {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for LimitRangeSpec {
    fn new() -> LimitRangeSpec {
        LimitRangeSpec::new()
    }

    fn descriptor_static(_: ::std::option::Option<LimitRangeSpec>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LimitRangeItem>>(
                    "limits",
                    LimitRangeSpec::get_limits_for_reflect,
                    LimitRangeSpec::mut_limits_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LimitRangeSpec>(
                    "LimitRangeSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for LimitRangeSpec {
    fn clear(&mut self) {
        self.clear_limits();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LimitRangeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitRangeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct List {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<super::generated::RawExtension>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for List {}

impl List {
    pub fn new() -> List {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static List {
        static mut instance: ::protobuf::lazy::Lazy<List> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const List,
        };
        unsafe {
            instance.get(List::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<super::generated::RawExtension>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<super::generated::RawExtension> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<super::generated::RawExtension> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[super::generated::RawExtension] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<super::generated::RawExtension> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::generated::RawExtension> {
        &mut self.items
    }
}

impl ::protobuf::Message for List {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for List {
    fn new() -> List {
        List::new()
    }

    fn descriptor_static(_: ::std::option::Option<List>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    List::get_metadata_for_reflect,
                    List::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::RawExtension>>(
                    "items",
                    List::get_items_for_reflect,
                    List::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<List>(
                    "List",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for List {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for List {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOptions {
    // message fields
    labelSelector: ::protobuf::SingularField<::std::string::String>,
    fieldSelector: ::protobuf::SingularField<::std::string::String>,
    includeUninitialized: ::std::option::Option<bool>,
    watch: ::std::option::Option<bool>,
    resourceVersion: ::protobuf::SingularField<::std::string::String>,
    timeoutSeconds: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ListOptions {}

impl ListOptions {
    pub fn new() -> ListOptions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ListOptions {
        static mut instance: ::protobuf::lazy::Lazy<ListOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListOptions,
        };
        unsafe {
            instance.get(ListOptions::new)
        }
    }

    // optional string labelSelector = 1;

    pub fn clear_labelSelector(&mut self) {
        self.labelSelector.clear();
    }

    pub fn has_labelSelector(&self) -> bool {
        self.labelSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelSelector(&mut self, v: ::std::string::String) {
        self.labelSelector = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelSelector(&mut self) -> &mut ::std::string::String {
        if self.labelSelector.is_none() {
            self.labelSelector.set_default();
        }
        self.labelSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_labelSelector(&mut self) -> ::std::string::String {
        self.labelSelector.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_labelSelector(&self) -> &str {
        match self.labelSelector.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_labelSelector_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.labelSelector
    }

    fn mut_labelSelector_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.labelSelector
    }

    // optional string fieldSelector = 2;

    pub fn clear_fieldSelector(&mut self) {
        self.fieldSelector.clear();
    }

    pub fn has_fieldSelector(&self) -> bool {
        self.fieldSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldSelector(&mut self, v: ::std::string::String) {
        self.fieldSelector = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldSelector(&mut self) -> &mut ::std::string::String {
        if self.fieldSelector.is_none() {
            self.fieldSelector.set_default();
        }
        self.fieldSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldSelector(&mut self) -> ::std::string::String {
        self.fieldSelector.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fieldSelector(&self) -> &str {
        match self.fieldSelector.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fieldSelector_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fieldSelector
    }

    fn mut_fieldSelector_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fieldSelector
    }

    // optional bool includeUninitialized = 6;

    pub fn clear_includeUninitialized(&mut self) {
        self.includeUninitialized = ::std::option::Option::None;
    }

    pub fn has_includeUninitialized(&self) -> bool {
        self.includeUninitialized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includeUninitialized(&mut self, v: bool) {
        self.includeUninitialized = ::std::option::Option::Some(v);
    }

    pub fn get_includeUninitialized(&self) -> bool {
        self.includeUninitialized.unwrap_or(false)
    }

    fn get_includeUninitialized_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.includeUninitialized
    }

    fn mut_includeUninitialized_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.includeUninitialized
    }

    // optional bool watch = 3;

    pub fn clear_watch(&mut self) {
        self.watch = ::std::option::Option::None;
    }

    pub fn has_watch(&self) -> bool {
        self.watch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watch(&mut self, v: bool) {
        self.watch = ::std::option::Option::Some(v);
    }

    pub fn get_watch(&self) -> bool {
        self.watch.unwrap_or(false)
    }

    fn get_watch_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.watch
    }

    fn mut_watch_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.watch
    }

    // optional string resourceVersion = 4;

    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion.clear();
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion.set_default();
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_resourceVersion_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.resourceVersion
    }

    fn mut_resourceVersion_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.resourceVersion
    }

    // optional int64 timeoutSeconds = 5;

    pub fn clear_timeoutSeconds(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
    }

    pub fn has_timeoutSeconds(&self) -> bool {
        self.timeoutSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeoutSeconds(&mut self, v: i64) {
        self.timeoutSeconds = ::std::option::Option::Some(v);
    }

    pub fn get_timeoutSeconds(&self) -> i64 {
        self.timeoutSeconds.unwrap_or(0)
    }

    fn get_timeoutSeconds_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.timeoutSeconds
    }

    fn mut_timeoutSeconds_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.timeoutSeconds
    }
}

impl ::protobuf::Message for ListOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.labelSelector)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fieldSelector)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.includeUninitialized = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.watch = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resourceVersion)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timeoutSeconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.labelSelector.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fieldSelector.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.includeUninitialized {
            my_size += 2;
        }
        if let Some(v) = self.watch {
            my_size += 2;
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.timeoutSeconds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.labelSelector.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fieldSelector.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.includeUninitialized {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.watch {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.timeoutSeconds {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ListOptions {
    fn new() -> ListOptions {
        ListOptions::new()
    }

    fn descriptor_static(_: ::std::option::Option<ListOptions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "labelSelector",
                    ListOptions::get_labelSelector_for_reflect,
                    ListOptions::mut_labelSelector_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fieldSelector",
                    ListOptions::get_fieldSelector_for_reflect,
                    ListOptions::mut_fieldSelector_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "includeUninitialized",
                    ListOptions::get_includeUninitialized_for_reflect,
                    ListOptions::mut_includeUninitialized_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "watch",
                    ListOptions::get_watch_for_reflect,
                    ListOptions::mut_watch_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "resourceVersion",
                    ListOptions::get_resourceVersion_for_reflect,
                    ListOptions::mut_resourceVersion_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timeoutSeconds",
                    ListOptions::get_timeoutSeconds_for_reflect,
                    ListOptions::mut_timeoutSeconds_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListOptions>(
                    "ListOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ListOptions {
    fn clear(&mut self) {
        self.clear_labelSelector();
        self.clear_fieldSelector();
        self.clear_includeUninitialized();
        self.clear_watch();
        self.clear_resourceVersion();
        self.clear_timeoutSeconds();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadBalancerIngress {
    // message fields
    ip: ::protobuf::SingularField<::std::string::String>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for LoadBalancerIngress {}

impl LoadBalancerIngress {
    pub fn new() -> LoadBalancerIngress {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static LoadBalancerIngress {
        static mut instance: ::protobuf::lazy::Lazy<LoadBalancerIngress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LoadBalancerIngress,
        };
        unsafe {
            instance.get(LoadBalancerIngress::new)
        }
    }

    // optional string ip = 1;

    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip.set_default();
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_ip_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.ip
    }

    fn mut_ip_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.ip
    }

    // optional string hostname = 2;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hostname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hostname
    }

    fn mut_hostname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hostname
    }
}

impl ::protobuf::Message for LoadBalancerIngress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ip.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for LoadBalancerIngress {
    fn new() -> LoadBalancerIngress {
        LoadBalancerIngress::new()
    }

    fn descriptor_static(_: ::std::option::Option<LoadBalancerIngress>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ip",
                    LoadBalancerIngress::get_ip_for_reflect,
                    LoadBalancerIngress::mut_ip_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostname",
                    LoadBalancerIngress::get_hostname_for_reflect,
                    LoadBalancerIngress::mut_hostname_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LoadBalancerIngress>(
                    "LoadBalancerIngress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for LoadBalancerIngress {
    fn clear(&mut self) {
        self.clear_ip();
        self.clear_hostname();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadBalancerIngress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadBalancerIngress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadBalancerStatus {
    // message fields
    ingress: ::protobuf::RepeatedField<LoadBalancerIngress>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for LoadBalancerStatus {}

impl LoadBalancerStatus {
    pub fn new() -> LoadBalancerStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static LoadBalancerStatus {
        static mut instance: ::protobuf::lazy::Lazy<LoadBalancerStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LoadBalancerStatus,
        };
        unsafe {
            instance.get(LoadBalancerStatus::new)
        }
    }

    // repeated .k8s.io.api.core.v1.LoadBalancerIngress ingress = 1;

    pub fn clear_ingress(&mut self) {
        self.ingress.clear();
    }

    // Param is passed by value, moved
    pub fn set_ingress(&mut self, v: ::protobuf::RepeatedField<LoadBalancerIngress>) {
        self.ingress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ingress(&mut self) -> &mut ::protobuf::RepeatedField<LoadBalancerIngress> {
        &mut self.ingress
    }

    // Take field
    pub fn take_ingress(&mut self) -> ::protobuf::RepeatedField<LoadBalancerIngress> {
        ::std::mem::replace(&mut self.ingress, ::protobuf::RepeatedField::new())
    }

    pub fn get_ingress(&self) -> &[LoadBalancerIngress] {
        &self.ingress
    }

    fn get_ingress_for_reflect(&self) -> &::protobuf::RepeatedField<LoadBalancerIngress> {
        &self.ingress
    }

    fn mut_ingress_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<LoadBalancerIngress> {
        &mut self.ingress
    }
}

impl ::protobuf::Message for LoadBalancerStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.ingress {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ingress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ingress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ingress {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for LoadBalancerStatus {
    fn new() -> LoadBalancerStatus {
        LoadBalancerStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<LoadBalancerStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadBalancerIngress>>(
                    "ingress",
                    LoadBalancerStatus::get_ingress_for_reflect,
                    LoadBalancerStatus::mut_ingress_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LoadBalancerStatus>(
                    "LoadBalancerStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for LoadBalancerStatus {
    fn clear(&mut self) {
        self.clear_ingress();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadBalancerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadBalancerStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalObjectReference {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for LocalObjectReference {}

impl LocalObjectReference {
    pub fn new() -> LocalObjectReference {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static LocalObjectReference {
        static mut instance: ::protobuf::lazy::Lazy<LocalObjectReference> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocalObjectReference,
        };
        unsafe {
            instance.get(LocalObjectReference::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }
}

impl ::protobuf::Message for LocalObjectReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for LocalObjectReference {
    fn new() -> LocalObjectReference {
        LocalObjectReference::new()
    }

    fn descriptor_static(_: ::std::option::Option<LocalObjectReference>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    LocalObjectReference::get_name_for_reflect,
                    LocalObjectReference::mut_name_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocalObjectReference>(
                    "LocalObjectReference",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for LocalObjectReference {
    fn clear(&mut self) {
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalObjectReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalObjectReference {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalVolumeSource {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for LocalVolumeSource {}

impl LocalVolumeSource {
    pub fn new() -> LocalVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static LocalVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<LocalVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LocalVolumeSource,
        };
        unsafe {
            instance.get(LocalVolumeSource::new)
        }
    }

    // optional string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }
}

impl ::protobuf::Message for LocalVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for LocalVolumeSource {
    fn new() -> LocalVolumeSource {
        LocalVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<LocalVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    LocalVolumeSource::get_path_for_reflect,
                    LocalVolumeSource::mut_path_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LocalVolumeSource>(
                    "LocalVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for LocalVolumeSource {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NFSVolumeSource {
    // message fields
    server: ::protobuf::SingularField<::std::string::String>,
    path: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NFSVolumeSource {}

impl NFSVolumeSource {
    pub fn new() -> NFSVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NFSVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<NFSVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NFSVolumeSource,
        };
        unsafe {
            instance.get(NFSVolumeSource::new)
        }
    }

    // optional string server = 1;

    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: ::std::string::String) {
        self.server = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut ::std::string::String {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> ::std::string::String {
        self.server.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_server(&self) -> &str {
        match self.server.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_server_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.server
    }

    fn mut_server_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.server
    }

    // optional string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }

    // optional bool readOnly = 3;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }
}

impl ::protobuf::Message for NFSVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NFSVolumeSource {
    fn new() -> NFSVolumeSource {
        NFSVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<NFSVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "server",
                    NFSVolumeSource::get_server_for_reflect,
                    NFSVolumeSource::mut_server_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    NFSVolumeSource::get_path_for_reflect,
                    NFSVolumeSource::mut_path_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    NFSVolumeSource::get_readOnly_for_reflect,
                    NFSVolumeSource::mut_readOnly_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NFSVolumeSource>(
                    "NFSVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NFSVolumeSource {
    fn clear(&mut self) {
        self.clear_server();
        self.clear_path();
        self.clear_readOnly();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NFSVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NFSVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Namespace {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    spec: ::protobuf::SingularPtrField<NamespaceSpec>,
    status: ::protobuf::SingularPtrField<NamespaceStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Namespace {}

impl Namespace {
    pub fn new() -> Namespace {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Namespace {
        static mut instance: ::protobuf::lazy::Lazy<Namespace> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Namespace,
        };
        unsafe {
            instance.get(Namespace::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.NamespaceSpec spec = 2;

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: NamespaceSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut NamespaceSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> NamespaceSpec {
        self.spec.take().unwrap_or_else(|| NamespaceSpec::new())
    }

    pub fn get_spec(&self) -> &NamespaceSpec {
        self.spec.as_ref().unwrap_or_else(|| NamespaceSpec::default_instance())
    }

    fn get_spec_for_reflect(&self) -> &::protobuf::SingularPtrField<NamespaceSpec> {
        &self.spec
    }

    fn mut_spec_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<NamespaceSpec> {
        &mut self.spec
    }

    // optional .k8s.io.api.core.v1.NamespaceStatus status = 3;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: NamespaceStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut NamespaceStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> NamespaceStatus {
        self.status.take().unwrap_or_else(|| NamespaceStatus::new())
    }

    pub fn get_status(&self) -> &NamespaceStatus {
        self.status.as_ref().unwrap_or_else(|| NamespaceStatus::default_instance())
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularPtrField<NamespaceStatus> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<NamespaceStatus> {
        &mut self.status
    }
}

impl ::protobuf::Message for Namespace {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Namespace {
    fn new() -> Namespace {
        Namespace::new()
    }

    fn descriptor_static(_: ::std::option::Option<Namespace>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    Namespace::get_metadata_for_reflect,
                    Namespace::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NamespaceSpec>>(
                    "spec",
                    Namespace::get_spec_for_reflect,
                    Namespace::mut_spec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NamespaceStatus>>(
                    "status",
                    Namespace::get_status_for_reflect,
                    Namespace::mut_status_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Namespace>(
                    "Namespace",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Namespace {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_spec();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Namespace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Namespace {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamespaceList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<Namespace>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NamespaceList {}

impl NamespaceList {
    pub fn new() -> NamespaceList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NamespaceList {
        static mut instance: ::protobuf::lazy::Lazy<NamespaceList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NamespaceList,
        };
        unsafe {
            instance.get(NamespaceList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.Namespace items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Namespace>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Namespace> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Namespace> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[Namespace] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<Namespace> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Namespace> {
        &mut self.items
    }
}

impl ::protobuf::Message for NamespaceList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NamespaceList {
    fn new() -> NamespaceList {
        NamespaceList::new()
    }

    fn descriptor_static(_: ::std::option::Option<NamespaceList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    NamespaceList::get_metadata_for_reflect,
                    NamespaceList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Namespace>>(
                    "items",
                    NamespaceList::get_items_for_reflect,
                    NamespaceList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NamespaceList>(
                    "NamespaceList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NamespaceList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamespaceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamespaceSpec {
    // message fields
    finalizers: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NamespaceSpec {}

impl NamespaceSpec {
    pub fn new() -> NamespaceSpec {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NamespaceSpec {
        static mut instance: ::protobuf::lazy::Lazy<NamespaceSpec> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NamespaceSpec,
        };
        unsafe {
            instance.get(NamespaceSpec::new)
        }
    }

    // repeated string finalizers = 1;

    pub fn clear_finalizers(&mut self) {
        self.finalizers.clear();
    }

    // Param is passed by value, moved
    pub fn set_finalizers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.finalizers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_finalizers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.finalizers
    }

    // Take field
    pub fn take_finalizers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.finalizers, ::protobuf::RepeatedField::new())
    }

    pub fn get_finalizers(&self) -> &[::std::string::String] {
        &self.finalizers
    }

    fn get_finalizers_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.finalizers
    }

    fn mut_finalizers_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.finalizers
    }
}

impl ::protobuf::Message for NamespaceSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.finalizers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.finalizers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.finalizers {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NamespaceSpec {
    fn new() -> NamespaceSpec {
        NamespaceSpec::new()
    }

    fn descriptor_static(_: ::std::option::Option<NamespaceSpec>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "finalizers",
                    NamespaceSpec::get_finalizers_for_reflect,
                    NamespaceSpec::mut_finalizers_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NamespaceSpec>(
                    "NamespaceSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NamespaceSpec {
    fn clear(&mut self) {
        self.clear_finalizers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamespaceSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamespaceStatus {
    // message fields
    phase: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NamespaceStatus {}

impl NamespaceStatus {
    pub fn new() -> NamespaceStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NamespaceStatus {
        static mut instance: ::protobuf::lazy::Lazy<NamespaceStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NamespaceStatus,
        };
        unsafe {
            instance.get(NamespaceStatus::new)
        }
    }

    // optional string phase = 1;

    pub fn clear_phase(&mut self) {
        self.phase.clear();
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase.set_default();
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_phase_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.phase
    }

    fn mut_phase_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.phase
    }
}

impl ::protobuf::Message for NamespaceStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phase)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.phase.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NamespaceStatus {
    fn new() -> NamespaceStatus {
        NamespaceStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<NamespaceStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "phase",
                    NamespaceStatus::get_phase_for_reflect,
                    NamespaceStatus::mut_phase_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NamespaceStatus>(
                    "NamespaceStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NamespaceStatus {
    fn clear(&mut self) {
        self.clear_phase();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamespaceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Node {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    spec: ::protobuf::SingularPtrField<NodeSpec>,
    status: ::protobuf::SingularPtrField<NodeStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Node {}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Node {
        static mut instance: ::protobuf::lazy::Lazy<Node> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Node,
        };
        unsafe {
            instance.get(Node::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.NodeSpec spec = 2;

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: NodeSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut NodeSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> NodeSpec {
        self.spec.take().unwrap_or_else(|| NodeSpec::new())
    }

    pub fn get_spec(&self) -> &NodeSpec {
        self.spec.as_ref().unwrap_or_else(|| NodeSpec::default_instance())
    }

    fn get_spec_for_reflect(&self) -> &::protobuf::SingularPtrField<NodeSpec> {
        &self.spec
    }

    fn mut_spec_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<NodeSpec> {
        &mut self.spec
    }

    // optional .k8s.io.api.core.v1.NodeStatus status = 3;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: NodeStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut NodeStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> NodeStatus {
        self.status.take().unwrap_or_else(|| NodeStatus::new())
    }

    pub fn get_status(&self) -> &NodeStatus {
        self.status.as_ref().unwrap_or_else(|| NodeStatus::default_instance())
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularPtrField<NodeStatus> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<NodeStatus> {
        &mut self.status
    }
}

impl ::protobuf::Message for Node {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Node {
    fn new() -> Node {
        Node::new()
    }

    fn descriptor_static(_: ::std::option::Option<Node>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    Node::get_metadata_for_reflect,
                    Node::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSpec>>(
                    "spec",
                    Node::get_spec_for_reflect,
                    Node::mut_spec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeStatus>>(
                    "status",
                    Node::get_status_for_reflect,
                    Node::mut_status_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Node>(
                    "Node",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Node {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_spec();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeAddress {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NodeAddress {}

impl NodeAddress {
    pub fn new() -> NodeAddress {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NodeAddress {
        static mut instance: ::protobuf::lazy::Lazy<NodeAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeAddress,
        };
        unsafe {
            instance.get(NodeAddress::new)
        }
    }

    // optional string type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_field_type_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.field_type
    }

    // optional string address = 2;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_address_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.address
    }

    fn mut_address_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.address
    }
}

impl ::protobuf::Message for NodeAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NodeAddress {
    fn new() -> NodeAddress {
        NodeAddress::new()
    }

    fn descriptor_static(_: ::std::option::Option<NodeAddress>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    NodeAddress::get_field_type_for_reflect,
                    NodeAddress::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    NodeAddress::get_address_for_reflect,
                    NodeAddress::mut_address_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeAddress>(
                    "NodeAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NodeAddress {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_address();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeAffinity {
    // message fields
    requiredDuringSchedulingIgnoredDuringExecution: ::protobuf::SingularPtrField<NodeSelector>,
    preferredDuringSchedulingIgnoredDuringExecution: ::protobuf::RepeatedField<PreferredSchedulingTerm>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NodeAffinity {}

impl NodeAffinity {
    pub fn new() -> NodeAffinity {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NodeAffinity {
        static mut instance: ::protobuf::lazy::Lazy<NodeAffinity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeAffinity,
        };
        unsafe {
            instance.get(NodeAffinity::new)
        }
    }

    // optional .k8s.io.api.core.v1.NodeSelector requiredDuringSchedulingIgnoredDuringExecution = 1;

    pub fn clear_requiredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
    }

    pub fn has_requiredDuringSchedulingIgnoredDuringExecution(&self) -> bool {
        self.requiredDuringSchedulingIgnoredDuringExecution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requiredDuringSchedulingIgnoredDuringExecution(&mut self, v: NodeSelector) {
        self.requiredDuringSchedulingIgnoredDuringExecution = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut NodeSelector {
        if self.requiredDuringSchedulingIgnoredDuringExecution.is_none() {
            self.requiredDuringSchedulingIgnoredDuringExecution.set_default();
        }
        self.requiredDuringSchedulingIgnoredDuringExecution.as_mut().unwrap()
    }

    // Take field
    pub fn take_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> NodeSelector {
        self.requiredDuringSchedulingIgnoredDuringExecution.take().unwrap_or_else(|| NodeSelector::new())
    }

    pub fn get_requiredDuringSchedulingIgnoredDuringExecution(&self) -> &NodeSelector {
        self.requiredDuringSchedulingIgnoredDuringExecution.as_ref().unwrap_or_else(|| NodeSelector::default_instance())
    }

    fn get_requiredDuringSchedulingIgnoredDuringExecution_for_reflect(&self) -> &::protobuf::SingularPtrField<NodeSelector> {
        &self.requiredDuringSchedulingIgnoredDuringExecution
    }

    fn mut_requiredDuringSchedulingIgnoredDuringExecution_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<NodeSelector> {
        &mut self.requiredDuringSchedulingIgnoredDuringExecution
    }

    // repeated .k8s.io.api.core.v1.PreferredSchedulingTerm preferredDuringSchedulingIgnoredDuringExecution = 2;

    pub fn clear_preferredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::protobuf::RepeatedField<PreferredSchedulingTerm>) {
        self.preferredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::protobuf::RepeatedField<PreferredSchedulingTerm> {
        &mut self.preferredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::protobuf::RepeatedField<PreferredSchedulingTerm> {
        ::std::mem::replace(&mut self.preferredDuringSchedulingIgnoredDuringExecution, ::protobuf::RepeatedField::new())
    }

    pub fn get_preferredDuringSchedulingIgnoredDuringExecution(&self) -> &[PreferredSchedulingTerm] {
        &self.preferredDuringSchedulingIgnoredDuringExecution
    }

    fn get_preferredDuringSchedulingIgnoredDuringExecution_for_reflect(&self) -> &::protobuf::RepeatedField<PreferredSchedulingTerm> {
        &self.preferredDuringSchedulingIgnoredDuringExecution
    }

    fn mut_preferredDuringSchedulingIgnoredDuringExecution_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<PreferredSchedulingTerm> {
        &mut self.preferredDuringSchedulingIgnoredDuringExecution
    }
}

impl ::protobuf::Message for NodeAffinity {
    fn is_initialized(&self) -> bool {
        for v in &self.requiredDuringSchedulingIgnoredDuringExecution {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.requiredDuringSchedulingIgnoredDuringExecution)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preferredDuringSchedulingIgnoredDuringExecution)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.requiredDuringSchedulingIgnoredDuringExecution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.preferredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.requiredDuringSchedulingIgnoredDuringExecution.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NodeAffinity {
    fn new() -> NodeAffinity {
        NodeAffinity::new()
    }

    fn descriptor_static(_: ::std::option::Option<NodeAffinity>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSelector>>(
                    "requiredDuringSchedulingIgnoredDuringExecution",
                    NodeAffinity::get_requiredDuringSchedulingIgnoredDuringExecution_for_reflect,
                    NodeAffinity::mut_requiredDuringSchedulingIgnoredDuringExecution_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PreferredSchedulingTerm>>(
                    "preferredDuringSchedulingIgnoredDuringExecution",
                    NodeAffinity::get_preferredDuringSchedulingIgnoredDuringExecution_for_reflect,
                    NodeAffinity::mut_preferredDuringSchedulingIgnoredDuringExecution_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeAffinity>(
                    "NodeAffinity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NodeAffinity {
    fn clear(&mut self) {
        self.clear_requiredDuringSchedulingIgnoredDuringExecution();
        self.clear_preferredDuringSchedulingIgnoredDuringExecution();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeAffinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAffinity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeCondition {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    status: ::protobuf::SingularField<::std::string::String>,
    lastHeartbeatTime: ::protobuf::SingularPtrField<super::generated::Time>,
    lastTransitionTime: ::protobuf::SingularPtrField<super::generated::Time>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NodeCondition {}

impl NodeCondition {
    pub fn new() -> NodeCondition {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NodeCondition {
        static mut instance: ::protobuf::lazy::Lazy<NodeCondition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeCondition,
        };
        unsafe {
            instance.get(NodeCondition::new)
        }
    }

    // optional string type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_field_type_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.field_type
    }

    // optional string status = 2;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.status
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastHeartbeatTime = 3;

    pub fn clear_lastHeartbeatTime(&mut self) {
        self.lastHeartbeatTime.clear();
    }

    pub fn has_lastHeartbeatTime(&self) -> bool {
        self.lastHeartbeatTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastHeartbeatTime(&mut self, v: super::generated::Time) {
        self.lastHeartbeatTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastHeartbeatTime(&mut self) -> &mut super::generated::Time {
        if self.lastHeartbeatTime.is_none() {
            self.lastHeartbeatTime.set_default();
        }
        self.lastHeartbeatTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastHeartbeatTime(&mut self) -> super::generated::Time {
        self.lastHeartbeatTime.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_lastHeartbeatTime(&self) -> &super::generated::Time {
        self.lastHeartbeatTime.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_lastHeartbeatTime_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.lastHeartbeatTime
    }

    fn mut_lastHeartbeatTime_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.lastHeartbeatTime
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: super::generated::Time) {
        self.lastTransitionTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut super::generated::Time {
        if self.lastTransitionTime.is_none() {
            self.lastTransitionTime.set_default();
        }
        self.lastTransitionTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> super::generated::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_lastTransitionTime(&self) -> &super::generated::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_lastTransitionTime_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.lastTransitionTime
    }

    fn mut_lastTransitionTime_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.lastTransitionTime
    }

    // optional string reason = 5;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_reason_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.reason
    }

    // optional string message = 6;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }
}

impl ::protobuf::Message for NodeCondition {
    fn is_initialized(&self) -> bool {
        for v in &self.lastHeartbeatTime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lastTransitionTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastHeartbeatTime)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastTransitionTime)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.lastHeartbeatTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.lastHeartbeatTime.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NodeCondition {
    fn new() -> NodeCondition {
        NodeCondition::new()
    }

    fn descriptor_static(_: ::std::option::Option<NodeCondition>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    NodeCondition::get_field_type_for_reflect,
                    NodeCondition::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "status",
                    NodeCondition::get_status_for_reflect,
                    NodeCondition::mut_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "lastHeartbeatTime",
                    NodeCondition::get_lastHeartbeatTime_for_reflect,
                    NodeCondition::mut_lastHeartbeatTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "lastTransitionTime",
                    NodeCondition::get_lastTransitionTime_for_reflect,
                    NodeCondition::mut_lastTransitionTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reason",
                    NodeCondition::get_reason_for_reflect,
                    NodeCondition::mut_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    NodeCondition::get_message_for_reflect,
                    NodeCondition::mut_message_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeCondition>(
                    "NodeCondition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NodeCondition {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_status();
        self.clear_lastHeartbeatTime();
        self.clear_lastTransitionTime();
        self.clear_reason();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeDaemonEndpoints {
    // message fields
    kubeletEndpoint: ::protobuf::SingularPtrField<DaemonEndpoint>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NodeDaemonEndpoints {}

impl NodeDaemonEndpoints {
    pub fn new() -> NodeDaemonEndpoints {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NodeDaemonEndpoints {
        static mut instance: ::protobuf::lazy::Lazy<NodeDaemonEndpoints> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeDaemonEndpoints,
        };
        unsafe {
            instance.get(NodeDaemonEndpoints::new)
        }
    }

    // optional .k8s.io.api.core.v1.DaemonEndpoint kubeletEndpoint = 1;

    pub fn clear_kubeletEndpoint(&mut self) {
        self.kubeletEndpoint.clear();
    }

    pub fn has_kubeletEndpoint(&self) -> bool {
        self.kubeletEndpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kubeletEndpoint(&mut self, v: DaemonEndpoint) {
        self.kubeletEndpoint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kubeletEndpoint(&mut self) -> &mut DaemonEndpoint {
        if self.kubeletEndpoint.is_none() {
            self.kubeletEndpoint.set_default();
        }
        self.kubeletEndpoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_kubeletEndpoint(&mut self) -> DaemonEndpoint {
        self.kubeletEndpoint.take().unwrap_or_else(|| DaemonEndpoint::new())
    }

    pub fn get_kubeletEndpoint(&self) -> &DaemonEndpoint {
        self.kubeletEndpoint.as_ref().unwrap_or_else(|| DaemonEndpoint::default_instance())
    }

    fn get_kubeletEndpoint_for_reflect(&self) -> &::protobuf::SingularPtrField<DaemonEndpoint> {
        &self.kubeletEndpoint
    }

    fn mut_kubeletEndpoint_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DaemonEndpoint> {
        &mut self.kubeletEndpoint
    }
}

impl ::protobuf::Message for NodeDaemonEndpoints {
    fn is_initialized(&self) -> bool {
        for v in &self.kubeletEndpoint {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.kubeletEndpoint)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.kubeletEndpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.kubeletEndpoint.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NodeDaemonEndpoints {
    fn new() -> NodeDaemonEndpoints {
        NodeDaemonEndpoints::new()
    }

    fn descriptor_static(_: ::std::option::Option<NodeDaemonEndpoints>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DaemonEndpoint>>(
                    "kubeletEndpoint",
                    NodeDaemonEndpoints::get_kubeletEndpoint_for_reflect,
                    NodeDaemonEndpoints::mut_kubeletEndpoint_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeDaemonEndpoints>(
                    "NodeDaemonEndpoints",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NodeDaemonEndpoints {
    fn clear(&mut self) {
        self.clear_kubeletEndpoint();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeDaemonEndpoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeDaemonEndpoints {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<Node>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NodeList {}

impl NodeList {
    pub fn new() -> NodeList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NodeList {
        static mut instance: ::protobuf::lazy::Lazy<NodeList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeList,
        };
        unsafe {
            instance.get(NodeList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.Node items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Node>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Node> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Node> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[Node] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<Node> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Node> {
        &mut self.items
    }
}

impl ::protobuf::Message for NodeList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NodeList {
    fn new() -> NodeList {
        NodeList::new()
    }

    fn descriptor_static(_: ::std::option::Option<NodeList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    NodeList::get_metadata_for_reflect,
                    NodeList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Node>>(
                    "items",
                    NodeList::get_items_for_reflect,
                    NodeList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeList>(
                    "NodeList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NodeList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeProxyOptions {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NodeProxyOptions {}

impl NodeProxyOptions {
    pub fn new() -> NodeProxyOptions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NodeProxyOptions {
        static mut instance: ::protobuf::lazy::Lazy<NodeProxyOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeProxyOptions,
        };
        unsafe {
            instance.get(NodeProxyOptions::new)
        }
    }

    // optional string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }
}

impl ::protobuf::Message for NodeProxyOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NodeProxyOptions {
    fn new() -> NodeProxyOptions {
        NodeProxyOptions::new()
    }

    fn descriptor_static(_: ::std::option::Option<NodeProxyOptions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    NodeProxyOptions::get_path_for_reflect,
                    NodeProxyOptions::mut_path_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeProxyOptions>(
                    "NodeProxyOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NodeProxyOptions {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeProxyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeProxyOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeResources {
    // message fields
    pub capacity: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NodeResources {}

impl NodeResources {
    pub fn new() -> NodeResources {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NodeResources {
        static mut instance: ::protobuf::lazy::Lazy<NodeResources> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeResources,
        };
        unsafe {
            instance.get(NodeResources::new)
        }
    }

    // repeated .k8s.io.api.core.v1.NodeResources.CapacityEntry capacity = 1;

    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.capacity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capacity(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.capacity
    }

    // Take field
    pub fn take_capacity(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.capacity, ::std::collections::HashMap::new())
    }

    pub fn get_capacity(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.capacity
    }

    fn get_capacity_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.capacity
    }

    fn mut_capacity_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.capacity
    }
}

impl ::protobuf::Message for NodeResources {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.capacity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(1, &self.capacity);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(1, &self.capacity, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NodeResources {
    fn new() -> NodeResources {
        NodeResources::new()
    }

    fn descriptor_static(_: ::std::option::Option<NodeResources>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "capacity",
                    NodeResources::get_capacity_for_reflect,
                    NodeResources::mut_capacity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeResources>(
                    "NodeResources",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NodeResources {
    fn clear(&mut self) {
        self.clear_capacity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeResources {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeSelector {
    // message fields
    nodeSelectorTerms: ::protobuf::RepeatedField<NodeSelectorTerm>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NodeSelector {}

impl NodeSelector {
    pub fn new() -> NodeSelector {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NodeSelector {
        static mut instance: ::protobuf::lazy::Lazy<NodeSelector> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeSelector,
        };
        unsafe {
            instance.get(NodeSelector::new)
        }
    }

    // repeated .k8s.io.api.core.v1.NodeSelectorTerm nodeSelectorTerms = 1;

    pub fn clear_nodeSelectorTerms(&mut self) {
        self.nodeSelectorTerms.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeSelectorTerms(&mut self, v: ::protobuf::RepeatedField<NodeSelectorTerm>) {
        self.nodeSelectorTerms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodeSelectorTerms(&mut self) -> &mut ::protobuf::RepeatedField<NodeSelectorTerm> {
        &mut self.nodeSelectorTerms
    }

    // Take field
    pub fn take_nodeSelectorTerms(&mut self) -> ::protobuf::RepeatedField<NodeSelectorTerm> {
        ::std::mem::replace(&mut self.nodeSelectorTerms, ::protobuf::RepeatedField::new())
    }

    pub fn get_nodeSelectorTerms(&self) -> &[NodeSelectorTerm] {
        &self.nodeSelectorTerms
    }

    fn get_nodeSelectorTerms_for_reflect(&self) -> &::protobuf::RepeatedField<NodeSelectorTerm> {
        &self.nodeSelectorTerms
    }

    fn mut_nodeSelectorTerms_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<NodeSelectorTerm> {
        &mut self.nodeSelectorTerms
    }
}

impl ::protobuf::Message for NodeSelector {
    fn is_initialized(&self) -> bool {
        for v in &self.nodeSelectorTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodeSelectorTerms)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodeSelectorTerms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodeSelectorTerms {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NodeSelector {
    fn new() -> NodeSelector {
        NodeSelector::new()
    }

    fn descriptor_static(_: ::std::option::Option<NodeSelector>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSelectorTerm>>(
                    "nodeSelectorTerms",
                    NodeSelector::get_nodeSelectorTerms_for_reflect,
                    NodeSelector::mut_nodeSelectorTerms_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeSelector>(
                    "NodeSelector",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NodeSelector {
    fn clear(&mut self) {
        self.clear_nodeSelectorTerms();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeSelectorRequirement {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    operator: ::protobuf::SingularField<::std::string::String>,
    values: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NodeSelectorRequirement {}

impl NodeSelectorRequirement {
    pub fn new() -> NodeSelectorRequirement {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NodeSelectorRequirement {
        static mut instance: ::protobuf::lazy::Lazy<NodeSelectorRequirement> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeSelectorRequirement,
        };
        unsafe {
            instance.get(NodeSelectorRequirement::new)
        }
    }

    // optional string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_key_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.key
    }

    fn mut_key_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.key
    }

    // optional string operator = 2;

    pub fn clear_operator(&mut self) {
        self.operator.clear();
    }

    pub fn has_operator(&self) -> bool {
        self.operator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operator(&mut self, v: ::std::string::String) {
        self.operator = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator(&mut self) -> &mut ::std::string::String {
        if self.operator.is_none() {
            self.operator.set_default();
        }
        self.operator.as_mut().unwrap()
    }

    // Take field
    pub fn take_operator(&mut self) -> ::std::string::String {
        self.operator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_operator(&self) -> &str {
        match self.operator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_operator_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.operator
    }

    fn mut_operator_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.operator
    }

    // repeated string values = 3;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }

    pub fn get_values(&self) -> &[::std::string::String] {
        &self.values
    }

    fn get_values_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.values
    }

    fn mut_values_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.values
    }
}

impl ::protobuf::Message for NodeSelectorRequirement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operator)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.operator.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.operator.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.values {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NodeSelectorRequirement {
    fn new() -> NodeSelectorRequirement {
        NodeSelectorRequirement::new()
    }

    fn descriptor_static(_: ::std::option::Option<NodeSelectorRequirement>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    NodeSelectorRequirement::get_key_for_reflect,
                    NodeSelectorRequirement::mut_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "operator",
                    NodeSelectorRequirement::get_operator_for_reflect,
                    NodeSelectorRequirement::mut_operator_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "values",
                    NodeSelectorRequirement::get_values_for_reflect,
                    NodeSelectorRequirement::mut_values_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeSelectorRequirement>(
                    "NodeSelectorRequirement",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NodeSelectorRequirement {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_operator();
        self.clear_values();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeSelectorRequirement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSelectorRequirement {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeSelectorTerm {
    // message fields
    matchExpressions: ::protobuf::RepeatedField<NodeSelectorRequirement>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NodeSelectorTerm {}

impl NodeSelectorTerm {
    pub fn new() -> NodeSelectorTerm {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NodeSelectorTerm {
        static mut instance: ::protobuf::lazy::Lazy<NodeSelectorTerm> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeSelectorTerm,
        };
        unsafe {
            instance.get(NodeSelectorTerm::new)
        }
    }

    // repeated .k8s.io.api.core.v1.NodeSelectorRequirement matchExpressions = 1;

    pub fn clear_matchExpressions(&mut self) {
        self.matchExpressions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchExpressions(&mut self, v: ::protobuf::RepeatedField<NodeSelectorRequirement>) {
        self.matchExpressions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchExpressions(&mut self) -> &mut ::protobuf::RepeatedField<NodeSelectorRequirement> {
        &mut self.matchExpressions
    }

    // Take field
    pub fn take_matchExpressions(&mut self) -> ::protobuf::RepeatedField<NodeSelectorRequirement> {
        ::std::mem::replace(&mut self.matchExpressions, ::protobuf::RepeatedField::new())
    }

    pub fn get_matchExpressions(&self) -> &[NodeSelectorRequirement] {
        &self.matchExpressions
    }

    fn get_matchExpressions_for_reflect(&self) -> &::protobuf::RepeatedField<NodeSelectorRequirement> {
        &self.matchExpressions
    }

    fn mut_matchExpressions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<NodeSelectorRequirement> {
        &mut self.matchExpressions
    }
}

impl ::protobuf::Message for NodeSelectorTerm {
    fn is_initialized(&self) -> bool {
        for v in &self.matchExpressions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matchExpressions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matchExpressions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matchExpressions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NodeSelectorTerm {
    fn new() -> NodeSelectorTerm {
        NodeSelectorTerm::new()
    }

    fn descriptor_static(_: ::std::option::Option<NodeSelectorTerm>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSelectorRequirement>>(
                    "matchExpressions",
                    NodeSelectorTerm::get_matchExpressions_for_reflect,
                    NodeSelectorTerm::mut_matchExpressions_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeSelectorTerm>(
                    "NodeSelectorTerm",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NodeSelectorTerm {
    fn clear(&mut self) {
        self.clear_matchExpressions();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeSelectorTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSelectorTerm {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeSpec {
    // message fields
    podCIDR: ::protobuf::SingularField<::std::string::String>,
    externalID: ::protobuf::SingularField<::std::string::String>,
    providerID: ::protobuf::SingularField<::std::string::String>,
    unschedulable: ::std::option::Option<bool>,
    taints: ::protobuf::RepeatedField<Taint>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NodeSpec {}

impl NodeSpec {
    pub fn new() -> NodeSpec {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NodeSpec {
        static mut instance: ::protobuf::lazy::Lazy<NodeSpec> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeSpec,
        };
        unsafe {
            instance.get(NodeSpec::new)
        }
    }

    // optional string podCIDR = 1;

    pub fn clear_podCIDR(&mut self) {
        self.podCIDR.clear();
    }

    pub fn has_podCIDR(&self) -> bool {
        self.podCIDR.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podCIDR(&mut self, v: ::std::string::String) {
        self.podCIDR = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podCIDR(&mut self) -> &mut ::std::string::String {
        if self.podCIDR.is_none() {
            self.podCIDR.set_default();
        }
        self.podCIDR.as_mut().unwrap()
    }

    // Take field
    pub fn take_podCIDR(&mut self) -> ::std::string::String {
        self.podCIDR.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_podCIDR(&self) -> &str {
        match self.podCIDR.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_podCIDR_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.podCIDR
    }

    fn mut_podCIDR_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.podCIDR
    }

    // optional string externalID = 2;

    pub fn clear_externalID(&mut self) {
        self.externalID.clear();
    }

    pub fn has_externalID(&self) -> bool {
        self.externalID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalID(&mut self, v: ::std::string::String) {
        self.externalID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_externalID(&mut self) -> &mut ::std::string::String {
        if self.externalID.is_none() {
            self.externalID.set_default();
        }
        self.externalID.as_mut().unwrap()
    }

    // Take field
    pub fn take_externalID(&mut self) -> ::std::string::String {
        self.externalID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_externalID(&self) -> &str {
        match self.externalID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_externalID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.externalID
    }

    fn mut_externalID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.externalID
    }

    // optional string providerID = 3;

    pub fn clear_providerID(&mut self) {
        self.providerID.clear();
    }

    pub fn has_providerID(&self) -> bool {
        self.providerID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_providerID(&mut self, v: ::std::string::String) {
        self.providerID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_providerID(&mut self) -> &mut ::std::string::String {
        if self.providerID.is_none() {
            self.providerID.set_default();
        }
        self.providerID.as_mut().unwrap()
    }

    // Take field
    pub fn take_providerID(&mut self) -> ::std::string::String {
        self.providerID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_providerID(&self) -> &str {
        match self.providerID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_providerID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.providerID
    }

    fn mut_providerID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.providerID
    }

    // optional bool unschedulable = 4;

    pub fn clear_unschedulable(&mut self) {
        self.unschedulable = ::std::option::Option::None;
    }

    pub fn has_unschedulable(&self) -> bool {
        self.unschedulable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unschedulable(&mut self, v: bool) {
        self.unschedulable = ::std::option::Option::Some(v);
    }

    pub fn get_unschedulable(&self) -> bool {
        self.unschedulable.unwrap_or(false)
    }

    fn get_unschedulable_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.unschedulable
    }

    fn mut_unschedulable_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.unschedulable
    }

    // repeated .k8s.io.api.core.v1.Taint taints = 5;

    pub fn clear_taints(&mut self) {
        self.taints.clear();
    }

    // Param is passed by value, moved
    pub fn set_taints(&mut self, v: ::protobuf::RepeatedField<Taint>) {
        self.taints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_taints(&mut self) -> &mut ::protobuf::RepeatedField<Taint> {
        &mut self.taints
    }

    // Take field
    pub fn take_taints(&mut self) -> ::protobuf::RepeatedField<Taint> {
        ::std::mem::replace(&mut self.taints, ::protobuf::RepeatedField::new())
    }

    pub fn get_taints(&self) -> &[Taint] {
        &self.taints
    }

    fn get_taints_for_reflect(&self) -> &::protobuf::RepeatedField<Taint> {
        &self.taints
    }

    fn mut_taints_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Taint> {
        &mut self.taints
    }
}

impl ::protobuf::Message for NodeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.taints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.podCIDR)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.externalID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.providerID)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unschedulable = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.taints)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.podCIDR.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.externalID.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.providerID.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.unschedulable {
            my_size += 2;
        }
        for value in &self.taints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.podCIDR.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.externalID.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.providerID.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.unschedulable {
            os.write_bool(4, v)?;
        }
        for v in &self.taints {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NodeSpec {
    fn new() -> NodeSpec {
        NodeSpec::new()
    }

    fn descriptor_static(_: ::std::option::Option<NodeSpec>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "podCIDR",
                    NodeSpec::get_podCIDR_for_reflect,
                    NodeSpec::mut_podCIDR_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "externalID",
                    NodeSpec::get_externalID_for_reflect,
                    NodeSpec::mut_externalID_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "providerID",
                    NodeSpec::get_providerID_for_reflect,
                    NodeSpec::mut_providerID_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "unschedulable",
                    NodeSpec::get_unschedulable_for_reflect,
                    NodeSpec::mut_unschedulable_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Taint>>(
                    "taints",
                    NodeSpec::get_taints_for_reflect,
                    NodeSpec::mut_taints_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeSpec>(
                    "NodeSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NodeSpec {
    fn clear(&mut self) {
        self.clear_podCIDR();
        self.clear_externalID();
        self.clear_providerID();
        self.clear_unschedulable();
        self.clear_taints();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeStatus {
    // message fields
    pub capacity: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    pub allocatable: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    phase: ::protobuf::SingularField<::std::string::String>,
    conditions: ::protobuf::RepeatedField<NodeCondition>,
    addresses: ::protobuf::RepeatedField<NodeAddress>,
    daemonEndpoints: ::protobuf::SingularPtrField<NodeDaemonEndpoints>,
    nodeInfo: ::protobuf::SingularPtrField<NodeSystemInfo>,
    images: ::protobuf::RepeatedField<ContainerImage>,
    volumesInUse: ::protobuf::RepeatedField<::std::string::String>,
    volumesAttached: ::protobuf::RepeatedField<AttachedVolume>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NodeStatus {}

impl NodeStatus {
    pub fn new() -> NodeStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NodeStatus {
        static mut instance: ::protobuf::lazy::Lazy<NodeStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeStatus,
        };
        unsafe {
            instance.get(NodeStatus::new)
        }
    }

    // repeated .k8s.io.api.core.v1.NodeStatus.CapacityEntry capacity = 1;

    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.capacity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capacity(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.capacity
    }

    // Take field
    pub fn take_capacity(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.capacity, ::std::collections::HashMap::new())
    }

    pub fn get_capacity(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.capacity
    }

    fn get_capacity_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.capacity
    }

    fn mut_capacity_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.capacity
    }

    // repeated .k8s.io.api.core.v1.NodeStatus.AllocatableEntry allocatable = 2;

    pub fn clear_allocatable(&mut self) {
        self.allocatable.clear();
    }

    // Param is passed by value, moved
    pub fn set_allocatable(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.allocatable = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allocatable(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.allocatable
    }

    // Take field
    pub fn take_allocatable(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.allocatable, ::std::collections::HashMap::new())
    }

    pub fn get_allocatable(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.allocatable
    }

    fn get_allocatable_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.allocatable
    }

    fn mut_allocatable_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.allocatable
    }

    // optional string phase = 3;

    pub fn clear_phase(&mut self) {
        self.phase.clear();
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase.set_default();
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_phase_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.phase
    }

    fn mut_phase_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.phase
    }

    // repeated .k8s.io.api.core.v1.NodeCondition conditions = 4;

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<NodeCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<NodeCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<NodeCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }

    pub fn get_conditions(&self) -> &[NodeCondition] {
        &self.conditions
    }

    fn get_conditions_for_reflect(&self) -> &::protobuf::RepeatedField<NodeCondition> {
        &self.conditions
    }

    fn mut_conditions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<NodeCondition> {
        &mut self.conditions
    }

    // repeated .k8s.io.api.core.v1.NodeAddress addresses = 5;

    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<NodeAddress>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<NodeAddress> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    pub fn get_addresses(&self) -> &[NodeAddress] {
        &self.addresses
    }

    fn get_addresses_for_reflect(&self) -> &::protobuf::RepeatedField<NodeAddress> {
        &self.addresses
    }

    fn mut_addresses_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.addresses
    }

    // optional .k8s.io.api.core.v1.NodeDaemonEndpoints daemonEndpoints = 6;

    pub fn clear_daemonEndpoints(&mut self) {
        self.daemonEndpoints.clear();
    }

    pub fn has_daemonEndpoints(&self) -> bool {
        self.daemonEndpoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_daemonEndpoints(&mut self, v: NodeDaemonEndpoints) {
        self.daemonEndpoints = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_daemonEndpoints(&mut self) -> &mut NodeDaemonEndpoints {
        if self.daemonEndpoints.is_none() {
            self.daemonEndpoints.set_default();
        }
        self.daemonEndpoints.as_mut().unwrap()
    }

    // Take field
    pub fn take_daemonEndpoints(&mut self) -> NodeDaemonEndpoints {
        self.daemonEndpoints.take().unwrap_or_else(|| NodeDaemonEndpoints::new())
    }

    pub fn get_daemonEndpoints(&self) -> &NodeDaemonEndpoints {
        self.daemonEndpoints.as_ref().unwrap_or_else(|| NodeDaemonEndpoints::default_instance())
    }

    fn get_daemonEndpoints_for_reflect(&self) -> &::protobuf::SingularPtrField<NodeDaemonEndpoints> {
        &self.daemonEndpoints
    }

    fn mut_daemonEndpoints_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<NodeDaemonEndpoints> {
        &mut self.daemonEndpoints
    }

    // optional .k8s.io.api.core.v1.NodeSystemInfo nodeInfo = 7;

    pub fn clear_nodeInfo(&mut self) {
        self.nodeInfo.clear();
    }

    pub fn has_nodeInfo(&self) -> bool {
        self.nodeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeInfo(&mut self, v: NodeSystemInfo) {
        self.nodeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeInfo(&mut self) -> &mut NodeSystemInfo {
        if self.nodeInfo.is_none() {
            self.nodeInfo.set_default();
        }
        self.nodeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeInfo(&mut self) -> NodeSystemInfo {
        self.nodeInfo.take().unwrap_or_else(|| NodeSystemInfo::new())
    }

    pub fn get_nodeInfo(&self) -> &NodeSystemInfo {
        self.nodeInfo.as_ref().unwrap_or_else(|| NodeSystemInfo::default_instance())
    }

    fn get_nodeInfo_for_reflect(&self) -> &::protobuf::SingularPtrField<NodeSystemInfo> {
        &self.nodeInfo
    }

    fn mut_nodeInfo_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<NodeSystemInfo> {
        &mut self.nodeInfo
    }

    // repeated .k8s.io.api.core.v1.ContainerImage images = 8;

    pub fn clear_images(&mut self) {
        self.images.clear();
    }

    // Param is passed by value, moved
    pub fn set_images(&mut self, v: ::protobuf::RepeatedField<ContainerImage>) {
        self.images = v;
    }

    // Mutable pointer to the field.
    pub fn mut_images(&mut self) -> &mut ::protobuf::RepeatedField<ContainerImage> {
        &mut self.images
    }

    // Take field
    pub fn take_images(&mut self) -> ::protobuf::RepeatedField<ContainerImage> {
        ::std::mem::replace(&mut self.images, ::protobuf::RepeatedField::new())
    }

    pub fn get_images(&self) -> &[ContainerImage] {
        &self.images
    }

    fn get_images_for_reflect(&self) -> &::protobuf::RepeatedField<ContainerImage> {
        &self.images
    }

    fn mut_images_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ContainerImage> {
        &mut self.images
    }

    // repeated string volumesInUse = 9;

    pub fn clear_volumesInUse(&mut self) {
        self.volumesInUse.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumesInUse(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.volumesInUse = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumesInUse(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.volumesInUse
    }

    // Take field
    pub fn take_volumesInUse(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.volumesInUse, ::protobuf::RepeatedField::new())
    }

    pub fn get_volumesInUse(&self) -> &[::std::string::String] {
        &self.volumesInUse
    }

    fn get_volumesInUse_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.volumesInUse
    }

    fn mut_volumesInUse_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.volumesInUse
    }

    // repeated .k8s.io.api.core.v1.AttachedVolume volumesAttached = 10;

    pub fn clear_volumesAttached(&mut self) {
        self.volumesAttached.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumesAttached(&mut self, v: ::protobuf::RepeatedField<AttachedVolume>) {
        self.volumesAttached = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumesAttached(&mut self) -> &mut ::protobuf::RepeatedField<AttachedVolume> {
        &mut self.volumesAttached
    }

    // Take field
    pub fn take_volumesAttached(&mut self) -> ::protobuf::RepeatedField<AttachedVolume> {
        ::std::mem::replace(&mut self.volumesAttached, ::protobuf::RepeatedField::new())
    }

    pub fn get_volumesAttached(&self) -> &[AttachedVolume] {
        &self.volumesAttached
    }

    fn get_volumesAttached_for_reflect(&self) -> &::protobuf::RepeatedField<AttachedVolume> {
        &self.volumesAttached
    }

    fn mut_volumesAttached_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<AttachedVolume> {
        &mut self.volumesAttached
    }
}

impl ::protobuf::Message for NodeStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.daemonEndpoints {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nodeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.images {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.volumesAttached {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.capacity)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.allocatable)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phase)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addresses)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.daemonEndpoints)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nodeInfo)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.images)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.volumesInUse)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumesAttached)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(1, &self.capacity);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(2, &self.allocatable);
        if let Some(ref v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.daemonEndpoints.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nodeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.images {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.volumesInUse {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.volumesAttached {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(1, &self.capacity, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(2, &self.allocatable, os)?;
        if let Some(ref v) = self.phase.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.conditions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.addresses {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.daemonEndpoints.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nodeInfo.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.images {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.volumesInUse {
            os.write_string(9, &v)?;
        };
        for v in &self.volumesAttached {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NodeStatus {
    fn new() -> NodeStatus {
        NodeStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<NodeStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "capacity",
                    NodeStatus::get_capacity_for_reflect,
                    NodeStatus::mut_capacity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "allocatable",
                    NodeStatus::get_allocatable_for_reflect,
                    NodeStatus::mut_allocatable_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "phase",
                    NodeStatus::get_phase_for_reflect,
                    NodeStatus::mut_phase_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeCondition>>(
                    "conditions",
                    NodeStatus::get_conditions_for_reflect,
                    NodeStatus::mut_conditions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeAddress>>(
                    "addresses",
                    NodeStatus::get_addresses_for_reflect,
                    NodeStatus::mut_addresses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeDaemonEndpoints>>(
                    "daemonEndpoints",
                    NodeStatus::get_daemonEndpoints_for_reflect,
                    NodeStatus::mut_daemonEndpoints_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSystemInfo>>(
                    "nodeInfo",
                    NodeStatus::get_nodeInfo_for_reflect,
                    NodeStatus::mut_nodeInfo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerImage>>(
                    "images",
                    NodeStatus::get_images_for_reflect,
                    NodeStatus::mut_images_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volumesInUse",
                    NodeStatus::get_volumesInUse_for_reflect,
                    NodeStatus::mut_volumesInUse_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachedVolume>>(
                    "volumesAttached",
                    NodeStatus::get_volumesAttached_for_reflect,
                    NodeStatus::mut_volumesAttached_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeStatus>(
                    "NodeStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NodeStatus {
    fn clear(&mut self) {
        self.clear_capacity();
        self.clear_allocatable();
        self.clear_phase();
        self.clear_conditions();
        self.clear_addresses();
        self.clear_daemonEndpoints();
        self.clear_nodeInfo();
        self.clear_images();
        self.clear_volumesInUse();
        self.clear_volumesAttached();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeSystemInfo {
    // message fields
    machineID: ::protobuf::SingularField<::std::string::String>,
    systemUUID: ::protobuf::SingularField<::std::string::String>,
    bootID: ::protobuf::SingularField<::std::string::String>,
    kernelVersion: ::protobuf::SingularField<::std::string::String>,
    osImage: ::protobuf::SingularField<::std::string::String>,
    containerRuntimeVersion: ::protobuf::SingularField<::std::string::String>,
    kubeletVersion: ::protobuf::SingularField<::std::string::String>,
    kubeProxyVersion: ::protobuf::SingularField<::std::string::String>,
    operatingSystem: ::protobuf::SingularField<::std::string::String>,
    architecture: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NodeSystemInfo {}

impl NodeSystemInfo {
    pub fn new() -> NodeSystemInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NodeSystemInfo {
        static mut instance: ::protobuf::lazy::Lazy<NodeSystemInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeSystemInfo,
        };
        unsafe {
            instance.get(NodeSystemInfo::new)
        }
    }

    // optional string machineID = 1;

    pub fn clear_machineID(&mut self) {
        self.machineID.clear();
    }

    pub fn has_machineID(&self) -> bool {
        self.machineID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machineID(&mut self, v: ::std::string::String) {
        self.machineID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machineID(&mut self) -> &mut ::std::string::String {
        if self.machineID.is_none() {
            self.machineID.set_default();
        }
        self.machineID.as_mut().unwrap()
    }

    // Take field
    pub fn take_machineID(&mut self) -> ::std::string::String {
        self.machineID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_machineID(&self) -> &str {
        match self.machineID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_machineID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.machineID
    }

    fn mut_machineID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.machineID
    }

    // optional string systemUUID = 2;

    pub fn clear_systemUUID(&mut self) {
        self.systemUUID.clear();
    }

    pub fn has_systemUUID(&self) -> bool {
        self.systemUUID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_systemUUID(&mut self, v: ::std::string::String) {
        self.systemUUID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_systemUUID(&mut self) -> &mut ::std::string::String {
        if self.systemUUID.is_none() {
            self.systemUUID.set_default();
        }
        self.systemUUID.as_mut().unwrap()
    }

    // Take field
    pub fn take_systemUUID(&mut self) -> ::std::string::String {
        self.systemUUID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_systemUUID(&self) -> &str {
        match self.systemUUID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_systemUUID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.systemUUID
    }

    fn mut_systemUUID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.systemUUID
    }

    // optional string bootID = 3;

    pub fn clear_bootID(&mut self) {
        self.bootID.clear();
    }

    pub fn has_bootID(&self) -> bool {
        self.bootID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bootID(&mut self, v: ::std::string::String) {
        self.bootID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bootID(&mut self) -> &mut ::std::string::String {
        if self.bootID.is_none() {
            self.bootID.set_default();
        }
        self.bootID.as_mut().unwrap()
    }

    // Take field
    pub fn take_bootID(&mut self) -> ::std::string::String {
        self.bootID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_bootID(&self) -> &str {
        match self.bootID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_bootID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.bootID
    }

    fn mut_bootID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.bootID
    }

    // optional string kernelVersion = 4;

    pub fn clear_kernelVersion(&mut self) {
        self.kernelVersion.clear();
    }

    pub fn has_kernelVersion(&self) -> bool {
        self.kernelVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kernelVersion(&mut self, v: ::std::string::String) {
        self.kernelVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kernelVersion(&mut self) -> &mut ::std::string::String {
        if self.kernelVersion.is_none() {
            self.kernelVersion.set_default();
        }
        self.kernelVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_kernelVersion(&mut self) -> ::std::string::String {
        self.kernelVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_kernelVersion(&self) -> &str {
        match self.kernelVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_kernelVersion_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.kernelVersion
    }

    fn mut_kernelVersion_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.kernelVersion
    }

    // optional string osImage = 5;

    pub fn clear_osImage(&mut self) {
        self.osImage.clear();
    }

    pub fn has_osImage(&self) -> bool {
        self.osImage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osImage(&mut self, v: ::std::string::String) {
        self.osImage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_osImage(&mut self) -> &mut ::std::string::String {
        if self.osImage.is_none() {
            self.osImage.set_default();
        }
        self.osImage.as_mut().unwrap()
    }

    // Take field
    pub fn take_osImage(&mut self) -> ::std::string::String {
        self.osImage.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_osImage(&self) -> &str {
        match self.osImage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_osImage_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.osImage
    }

    fn mut_osImage_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.osImage
    }

    // optional string containerRuntimeVersion = 6;

    pub fn clear_containerRuntimeVersion(&mut self) {
        self.containerRuntimeVersion.clear();
    }

    pub fn has_containerRuntimeVersion(&self) -> bool {
        self.containerRuntimeVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerRuntimeVersion(&mut self, v: ::std::string::String) {
        self.containerRuntimeVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_containerRuntimeVersion(&mut self) -> &mut ::std::string::String {
        if self.containerRuntimeVersion.is_none() {
            self.containerRuntimeVersion.set_default();
        }
        self.containerRuntimeVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_containerRuntimeVersion(&mut self) -> ::std::string::String {
        self.containerRuntimeVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_containerRuntimeVersion(&self) -> &str {
        match self.containerRuntimeVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_containerRuntimeVersion_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.containerRuntimeVersion
    }

    fn mut_containerRuntimeVersion_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.containerRuntimeVersion
    }

    // optional string kubeletVersion = 7;

    pub fn clear_kubeletVersion(&mut self) {
        self.kubeletVersion.clear();
    }

    pub fn has_kubeletVersion(&self) -> bool {
        self.kubeletVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kubeletVersion(&mut self, v: ::std::string::String) {
        self.kubeletVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kubeletVersion(&mut self) -> &mut ::std::string::String {
        if self.kubeletVersion.is_none() {
            self.kubeletVersion.set_default();
        }
        self.kubeletVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_kubeletVersion(&mut self) -> ::std::string::String {
        self.kubeletVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_kubeletVersion(&self) -> &str {
        match self.kubeletVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_kubeletVersion_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.kubeletVersion
    }

    fn mut_kubeletVersion_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.kubeletVersion
    }

    // optional string kubeProxyVersion = 8;

    pub fn clear_kubeProxyVersion(&mut self) {
        self.kubeProxyVersion.clear();
    }

    pub fn has_kubeProxyVersion(&self) -> bool {
        self.kubeProxyVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kubeProxyVersion(&mut self, v: ::std::string::String) {
        self.kubeProxyVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kubeProxyVersion(&mut self) -> &mut ::std::string::String {
        if self.kubeProxyVersion.is_none() {
            self.kubeProxyVersion.set_default();
        }
        self.kubeProxyVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_kubeProxyVersion(&mut self) -> ::std::string::String {
        self.kubeProxyVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_kubeProxyVersion(&self) -> &str {
        match self.kubeProxyVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_kubeProxyVersion_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.kubeProxyVersion
    }

    fn mut_kubeProxyVersion_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.kubeProxyVersion
    }

    // optional string operatingSystem = 9;

    pub fn clear_operatingSystem(&mut self) {
        self.operatingSystem.clear();
    }

    pub fn has_operatingSystem(&self) -> bool {
        self.operatingSystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operatingSystem(&mut self, v: ::std::string::String) {
        self.operatingSystem = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operatingSystem(&mut self) -> &mut ::std::string::String {
        if self.operatingSystem.is_none() {
            self.operatingSystem.set_default();
        }
        self.operatingSystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_operatingSystem(&mut self) -> ::std::string::String {
        self.operatingSystem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_operatingSystem(&self) -> &str {
        match self.operatingSystem.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_operatingSystem_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.operatingSystem
    }

    fn mut_operatingSystem_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.operatingSystem
    }

    // optional string architecture = 10;

    pub fn clear_architecture(&mut self) {
        self.architecture.clear();
    }

    pub fn has_architecture(&self) -> bool {
        self.architecture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_architecture(&mut self, v: ::std::string::String) {
        self.architecture = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_architecture(&mut self) -> &mut ::std::string::String {
        if self.architecture.is_none() {
            self.architecture.set_default();
        }
        self.architecture.as_mut().unwrap()
    }

    // Take field
    pub fn take_architecture(&mut self) -> ::std::string::String {
        self.architecture.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_architecture(&self) -> &str {
        match self.architecture.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_architecture_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.architecture
    }

    fn mut_architecture_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.architecture
    }
}

impl ::protobuf::Message for NodeSystemInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.machineID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.systemUUID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bootID)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kernelVersion)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osImage)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.containerRuntimeVersion)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kubeletVersion)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kubeProxyVersion)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operatingSystem)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.architecture)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.machineID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.systemUUID.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.bootID.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.kernelVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.osImage.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.containerRuntimeVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.kubeletVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.kubeProxyVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.operatingSystem.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.architecture.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.machineID.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.systemUUID.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.bootID.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.kernelVersion.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.osImage.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.containerRuntimeVersion.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.kubeletVersion.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.kubeProxyVersion.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.operatingSystem.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.architecture.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NodeSystemInfo {
    fn new() -> NodeSystemInfo {
        NodeSystemInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<NodeSystemInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "machineID",
                    NodeSystemInfo::get_machineID_for_reflect,
                    NodeSystemInfo::mut_machineID_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "systemUUID",
                    NodeSystemInfo::get_systemUUID_for_reflect,
                    NodeSystemInfo::mut_systemUUID_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bootID",
                    NodeSystemInfo::get_bootID_for_reflect,
                    NodeSystemInfo::mut_bootID_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kernelVersion",
                    NodeSystemInfo::get_kernelVersion_for_reflect,
                    NodeSystemInfo::mut_kernelVersion_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "osImage",
                    NodeSystemInfo::get_osImage_for_reflect,
                    NodeSystemInfo::mut_osImage_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "containerRuntimeVersion",
                    NodeSystemInfo::get_containerRuntimeVersion_for_reflect,
                    NodeSystemInfo::mut_containerRuntimeVersion_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kubeletVersion",
                    NodeSystemInfo::get_kubeletVersion_for_reflect,
                    NodeSystemInfo::mut_kubeletVersion_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kubeProxyVersion",
                    NodeSystemInfo::get_kubeProxyVersion_for_reflect,
                    NodeSystemInfo::mut_kubeProxyVersion_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "operatingSystem",
                    NodeSystemInfo::get_operatingSystem_for_reflect,
                    NodeSystemInfo::mut_operatingSystem_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "architecture",
                    NodeSystemInfo::get_architecture_for_reflect,
                    NodeSystemInfo::mut_architecture_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeSystemInfo>(
                    "NodeSystemInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NodeSystemInfo {
    fn clear(&mut self) {
        self.clear_machineID();
        self.clear_systemUUID();
        self.clear_bootID();
        self.clear_kernelVersion();
        self.clear_osImage();
        self.clear_containerRuntimeVersion();
        self.clear_kubeletVersion();
        self.clear_kubeProxyVersion();
        self.clear_operatingSystem();
        self.clear_architecture();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeSystemInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSystemInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObjectFieldSelector {
    // message fields
    apiVersion: ::protobuf::SingularField<::std::string::String>,
    fieldPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ObjectFieldSelector {}

impl ObjectFieldSelector {
    pub fn new() -> ObjectFieldSelector {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ObjectFieldSelector {
        static mut instance: ::protobuf::lazy::Lazy<ObjectFieldSelector> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ObjectFieldSelector,
        };
        unsafe {
            instance.get(ObjectFieldSelector::new)
        }
    }

    // optional string apiVersion = 1;

    pub fn clear_apiVersion(&mut self) {
        self.apiVersion.clear();
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion.set_default();
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_apiVersion_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.apiVersion
    }

    fn mut_apiVersion_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.apiVersion
    }

    // optional string fieldPath = 2;

    pub fn clear_fieldPath(&mut self) {
        self.fieldPath.clear();
    }

    pub fn has_fieldPath(&self) -> bool {
        self.fieldPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldPath(&mut self, v: ::std::string::String) {
        self.fieldPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldPath(&mut self) -> &mut ::std::string::String {
        if self.fieldPath.is_none() {
            self.fieldPath.set_default();
        }
        self.fieldPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldPath(&mut self) -> ::std::string::String {
        self.fieldPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fieldPath(&self) -> &str {
        match self.fieldPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fieldPath_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fieldPath
    }

    fn mut_fieldPath_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fieldPath
    }
}

impl ::protobuf::Message for ObjectFieldSelector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.apiVersion)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fieldPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fieldPath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.apiVersion.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fieldPath.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ObjectFieldSelector {
    fn new() -> ObjectFieldSelector {
        ObjectFieldSelector::new()
    }

    fn descriptor_static(_: ::std::option::Option<ObjectFieldSelector>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "apiVersion",
                    ObjectFieldSelector::get_apiVersion_for_reflect,
                    ObjectFieldSelector::mut_apiVersion_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fieldPath",
                    ObjectFieldSelector::get_fieldPath_for_reflect,
                    ObjectFieldSelector::mut_fieldPath_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ObjectFieldSelector>(
                    "ObjectFieldSelector",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ObjectFieldSelector {
    fn clear(&mut self) {
        self.clear_apiVersion();
        self.clear_fieldPath();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObjectFieldSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectFieldSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObjectMeta {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    generateName: ::protobuf::SingularField<::std::string::String>,
    namespace: ::protobuf::SingularField<::std::string::String>,
    selfLink: ::protobuf::SingularField<::std::string::String>,
    uid: ::protobuf::SingularField<::std::string::String>,
    resourceVersion: ::protobuf::SingularField<::std::string::String>,
    generation: ::std::option::Option<i64>,
    creationTimestamp: ::protobuf::SingularPtrField<super::generated::Time>,
    deletionTimestamp: ::protobuf::SingularPtrField<super::generated::Time>,
    deletionGracePeriodSeconds: ::std::option::Option<i64>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ownerReferences: ::protobuf::RepeatedField<super::generated::OwnerReference>,
    initializers: ::protobuf::SingularPtrField<super::generated::Initializers>,
    finalizers: ::protobuf::RepeatedField<::std::string::String>,
    clusterName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ObjectMeta {}

impl ObjectMeta {
    pub fn new() -> ObjectMeta {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ObjectMeta {
        static mut instance: ::protobuf::lazy::Lazy<ObjectMeta> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ObjectMeta,
        };
        unsafe {
            instance.get(ObjectMeta::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string generateName = 2;

    pub fn clear_generateName(&mut self) {
        self.generateName.clear();
    }

    pub fn has_generateName(&self) -> bool {
        self.generateName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generateName(&mut self, v: ::std::string::String) {
        self.generateName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generateName(&mut self) -> &mut ::std::string::String {
        if self.generateName.is_none() {
            self.generateName.set_default();
        }
        self.generateName.as_mut().unwrap()
    }

    // Take field
    pub fn take_generateName(&mut self) -> ::std::string::String {
        self.generateName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_generateName(&self) -> &str {
        match self.generateName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_generateName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.generateName
    }

    fn mut_generateName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.generateName
    }

    // optional string namespace = 3;

    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace.set_default();
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_namespace_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.namespace
    }

    fn mut_namespace_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.namespace
    }

    // optional string selfLink = 4;

    pub fn clear_selfLink(&mut self) {
        self.selfLink.clear();
    }

    pub fn has_selfLink(&self) -> bool {
        self.selfLink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selfLink(&mut self, v: ::std::string::String) {
        self.selfLink = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selfLink(&mut self) -> &mut ::std::string::String {
        if self.selfLink.is_none() {
            self.selfLink.set_default();
        }
        self.selfLink.as_mut().unwrap()
    }

    // Take field
    pub fn take_selfLink(&mut self) -> ::std::string::String {
        self.selfLink.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_selfLink(&self) -> &str {
        match self.selfLink.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_selfLink_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.selfLink
    }

    fn mut_selfLink_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.selfLink
    }

    // optional string uid = 5;

    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid.set_default();
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_uid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.uid
    }

    fn mut_uid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.uid
    }

    // optional string resourceVersion = 6;

    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion.clear();
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion.set_default();
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_resourceVersion_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.resourceVersion
    }

    fn mut_resourceVersion_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.resourceVersion
    }

    // optional int64 generation = 7;

    pub fn clear_generation(&mut self) {
        self.generation = ::std::option::Option::None;
    }

    pub fn has_generation(&self) -> bool {
        self.generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = ::std::option::Option::Some(v);
    }

    pub fn get_generation(&self) -> i64 {
        self.generation.unwrap_or(0)
    }

    fn get_generation_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.generation
    }

    fn mut_generation_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.generation
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;

    pub fn clear_creationTimestamp(&mut self) {
        self.creationTimestamp.clear();
    }

    pub fn has_creationTimestamp(&self) -> bool {
        self.creationTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creationTimestamp(&mut self, v: super::generated::Time) {
        self.creationTimestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creationTimestamp(&mut self) -> &mut super::generated::Time {
        if self.creationTimestamp.is_none() {
            self.creationTimestamp.set_default();
        }
        self.creationTimestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_creationTimestamp(&mut self) -> super::generated::Time {
        self.creationTimestamp.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_creationTimestamp(&self) -> &super::generated::Time {
        self.creationTimestamp.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_creationTimestamp_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.creationTimestamp
    }

    fn mut_creationTimestamp_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.creationTimestamp
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;

    pub fn clear_deletionTimestamp(&mut self) {
        self.deletionTimestamp.clear();
    }

    pub fn has_deletionTimestamp(&self) -> bool {
        self.deletionTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deletionTimestamp(&mut self, v: super::generated::Time) {
        self.deletionTimestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deletionTimestamp(&mut self) -> &mut super::generated::Time {
        if self.deletionTimestamp.is_none() {
            self.deletionTimestamp.set_default();
        }
        self.deletionTimestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_deletionTimestamp(&mut self) -> super::generated::Time {
        self.deletionTimestamp.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_deletionTimestamp(&self) -> &super::generated::Time {
        self.deletionTimestamp.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_deletionTimestamp_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.deletionTimestamp
    }

    fn mut_deletionTimestamp_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.deletionTimestamp
    }

    // optional int64 deletionGracePeriodSeconds = 10;

    pub fn clear_deletionGracePeriodSeconds(&mut self) {
        self.deletionGracePeriodSeconds = ::std::option::Option::None;
    }

    pub fn has_deletionGracePeriodSeconds(&self) -> bool {
        self.deletionGracePeriodSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deletionGracePeriodSeconds(&mut self, v: i64) {
        self.deletionGracePeriodSeconds = ::std::option::Option::Some(v);
    }

    pub fn get_deletionGracePeriodSeconds(&self) -> i64 {
        self.deletionGracePeriodSeconds.unwrap_or(0)
    }

    fn get_deletionGracePeriodSeconds_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.deletionGracePeriodSeconds
    }

    fn mut_deletionGracePeriodSeconds_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.deletionGracePeriodSeconds
    }

    // repeated .k8s.io.api.core.v1.ObjectMeta.LabelsEntry labels = 11;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }

    fn get_labels_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }

    fn mut_labels_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // repeated .k8s.io.api.core.v1.ObjectMeta.AnnotationsEntry annotations = 12;

    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::std::collections::HashMap::new())
    }

    pub fn get_annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }

    fn get_annotations_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }

    fn mut_annotations_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;

    pub fn clear_ownerReferences(&mut self) {
        self.ownerReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_ownerReferences(&mut self, v: ::protobuf::RepeatedField<super::generated::OwnerReference>) {
        self.ownerReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ownerReferences(&mut self) -> &mut ::protobuf::RepeatedField<super::generated::OwnerReference> {
        &mut self.ownerReferences
    }

    // Take field
    pub fn take_ownerReferences(&mut self) -> ::protobuf::RepeatedField<super::generated::OwnerReference> {
        ::std::mem::replace(&mut self.ownerReferences, ::protobuf::RepeatedField::new())
    }

    pub fn get_ownerReferences(&self) -> &[super::generated::OwnerReference] {
        &self.ownerReferences
    }

    fn get_ownerReferences_for_reflect(&self) -> &::protobuf::RepeatedField<super::generated::OwnerReference> {
        &self.ownerReferences
    }

    fn mut_ownerReferences_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<super::generated::OwnerReference> {
        &mut self.ownerReferences
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Initializers initializers = 16;

    pub fn clear_initializers(&mut self) {
        self.initializers.clear();
    }

    pub fn has_initializers(&self) -> bool {
        self.initializers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initializers(&mut self, v: super::generated::Initializers) {
        self.initializers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initializers(&mut self) -> &mut super::generated::Initializers {
        if self.initializers.is_none() {
            self.initializers.set_default();
        }
        self.initializers.as_mut().unwrap()
    }

    // Take field
    pub fn take_initializers(&mut self) -> super::generated::Initializers {
        self.initializers.take().unwrap_or_else(|| super::generated::Initializers::new())
    }

    pub fn get_initializers(&self) -> &super::generated::Initializers {
        self.initializers.as_ref().unwrap_or_else(|| super::generated::Initializers::default_instance())
    }

    fn get_initializers_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Initializers> {
        &self.initializers
    }

    fn mut_initializers_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Initializers> {
        &mut self.initializers
    }

    // repeated string finalizers = 14;

    pub fn clear_finalizers(&mut self) {
        self.finalizers.clear();
    }

    // Param is passed by value, moved
    pub fn set_finalizers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.finalizers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_finalizers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.finalizers
    }

    // Take field
    pub fn take_finalizers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.finalizers, ::protobuf::RepeatedField::new())
    }

    pub fn get_finalizers(&self) -> &[::std::string::String] {
        &self.finalizers
    }

    fn get_finalizers_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.finalizers
    }

    fn mut_finalizers_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.finalizers
    }

    // optional string clusterName = 15;

    pub fn clear_clusterName(&mut self) {
        self.clusterName.clear();
    }

    pub fn has_clusterName(&self) -> bool {
        self.clusterName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clusterName(&mut self, v: ::std::string::String) {
        self.clusterName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clusterName(&mut self) -> &mut ::std::string::String {
        if self.clusterName.is_none() {
            self.clusterName.set_default();
        }
        self.clusterName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clusterName(&mut self) -> ::std::string::String {
        self.clusterName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clusterName(&self) -> &str {
        match self.clusterName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clusterName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clusterName
    }

    fn mut_clusterName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clusterName
    }
}

impl ::protobuf::Message for ObjectMeta {
    fn is_initialized(&self) -> bool {
        for v in &self.creationTimestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deletionTimestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ownerReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initializers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.generateName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.namespace)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.selfLink)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uid)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resourceVersion)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creationTimestamp)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deletionTimestamp)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.deletionGracePeriodSeconds = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                12 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.annotations)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ownerReferences)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initializers)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.finalizers)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clusterName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.generateName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.selfLink.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.generation {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.creationTimestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.deletionTimestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.deletionGracePeriodSeconds {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(12, &self.annotations);
        for value in &self.ownerReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.initializers.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.finalizers {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        if let Some(ref v) = self.clusterName.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.generateName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.namespace.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.selfLink.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.uid.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.generation {
            os.write_int64(7, v)?;
        }
        if let Some(ref v) = self.creationTimestamp.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.deletionTimestamp.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.deletionGracePeriodSeconds {
            os.write_int64(10, v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(12, &self.annotations, os)?;
        for v in &self.ownerReferences {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.initializers.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.finalizers {
            os.write_string(14, &v)?;
        };
        if let Some(ref v) = self.clusterName.as_ref() {
            os.write_string(15, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ObjectMeta {
    fn new() -> ObjectMeta {
        ObjectMeta::new()
    }

    fn descriptor_static(_: ::std::option::Option<ObjectMeta>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    ObjectMeta::get_name_for_reflect,
                    ObjectMeta::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "generateName",
                    ObjectMeta::get_generateName_for_reflect,
                    ObjectMeta::mut_generateName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespace",
                    ObjectMeta::get_namespace_for_reflect,
                    ObjectMeta::mut_namespace_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "selfLink",
                    ObjectMeta::get_selfLink_for_reflect,
                    ObjectMeta::mut_selfLink_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    ObjectMeta::get_uid_for_reflect,
                    ObjectMeta::mut_uid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "resourceVersion",
                    ObjectMeta::get_resourceVersion_for_reflect,
                    ObjectMeta::mut_resourceVersion_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "generation",
                    ObjectMeta::get_generation_for_reflect,
                    ObjectMeta::mut_generation_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "creationTimestamp",
                    ObjectMeta::get_creationTimestamp_for_reflect,
                    ObjectMeta::mut_creationTimestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "deletionTimestamp",
                    ObjectMeta::get_deletionTimestamp_for_reflect,
                    ObjectMeta::mut_deletionTimestamp_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "deletionGracePeriodSeconds",
                    ObjectMeta::get_deletionGracePeriodSeconds_for_reflect,
                    ObjectMeta::mut_deletionGracePeriodSeconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    ObjectMeta::get_labels_for_reflect,
                    ObjectMeta::mut_labels_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "annotations",
                    ObjectMeta::get_annotations_for_reflect,
                    ObjectMeta::mut_annotations_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::OwnerReference>>(
                    "ownerReferences",
                    ObjectMeta::get_ownerReferences_for_reflect,
                    ObjectMeta::mut_ownerReferences_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Initializers>>(
                    "initializers",
                    ObjectMeta::get_initializers_for_reflect,
                    ObjectMeta::mut_initializers_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "finalizers",
                    ObjectMeta::get_finalizers_for_reflect,
                    ObjectMeta::mut_finalizers_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clusterName",
                    ObjectMeta::get_clusterName_for_reflect,
                    ObjectMeta::mut_clusterName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ObjectMeta>(
                    "ObjectMeta",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ObjectMeta {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_generateName();
        self.clear_namespace();
        self.clear_selfLink();
        self.clear_uid();
        self.clear_resourceVersion();
        self.clear_generation();
        self.clear_creationTimestamp();
        self.clear_deletionTimestamp();
        self.clear_deletionGracePeriodSeconds();
        self.clear_labels();
        self.clear_annotations();
        self.clear_ownerReferences();
        self.clear_initializers();
        self.clear_finalizers();
        self.clear_clusterName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObjectMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObjectReference {
    // message fields
    kind: ::protobuf::SingularField<::std::string::String>,
    namespace: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    uid: ::protobuf::SingularField<::std::string::String>,
    apiVersion: ::protobuf::SingularField<::std::string::String>,
    resourceVersion: ::protobuf::SingularField<::std::string::String>,
    fieldPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ObjectReference {}

impl ObjectReference {
    pub fn new() -> ObjectReference {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ObjectReference {
        static mut instance: ::protobuf::lazy::Lazy<ObjectReference> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ObjectReference,
        };
        unsafe {
            instance.get(ObjectReference::new)
        }
    }

    // optional string kind = 1;

    pub fn clear_kind(&mut self) {
        self.kind.clear();
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind.set_default();
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_kind_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.kind
    }

    fn mut_kind_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.kind
    }

    // optional string namespace = 2;

    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace.set_default();
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_namespace_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.namespace
    }

    fn mut_namespace_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.namespace
    }

    // optional string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string uid = 4;

    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid.set_default();
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_uid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.uid
    }

    fn mut_uid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.uid
    }

    // optional string apiVersion = 5;

    pub fn clear_apiVersion(&mut self) {
        self.apiVersion.clear();
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion.set_default();
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_apiVersion_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.apiVersion
    }

    fn mut_apiVersion_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.apiVersion
    }

    // optional string resourceVersion = 6;

    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion.clear();
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion.set_default();
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_resourceVersion_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.resourceVersion
    }

    fn mut_resourceVersion_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.resourceVersion
    }

    // optional string fieldPath = 7;

    pub fn clear_fieldPath(&mut self) {
        self.fieldPath.clear();
    }

    pub fn has_fieldPath(&self) -> bool {
        self.fieldPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldPath(&mut self, v: ::std::string::String) {
        self.fieldPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldPath(&mut self) -> &mut ::std::string::String {
        if self.fieldPath.is_none() {
            self.fieldPath.set_default();
        }
        self.fieldPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldPath(&mut self) -> ::std::string::String {
        self.fieldPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fieldPath(&self) -> &str {
        match self.fieldPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fieldPath_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fieldPath
    }

    fn mut_fieldPath_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fieldPath
    }
}

impl ::protobuf::Message for ObjectReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kind)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.namespace)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uid)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.apiVersion)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resourceVersion)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fieldPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.fieldPath.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.kind.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.namespace.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.uid.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.apiVersion.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.fieldPath.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ObjectReference {
    fn new() -> ObjectReference {
        ObjectReference::new()
    }

    fn descriptor_static(_: ::std::option::Option<ObjectReference>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kind",
                    ObjectReference::get_kind_for_reflect,
                    ObjectReference::mut_kind_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespace",
                    ObjectReference::get_namespace_for_reflect,
                    ObjectReference::mut_namespace_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    ObjectReference::get_name_for_reflect,
                    ObjectReference::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    ObjectReference::get_uid_for_reflect,
                    ObjectReference::mut_uid_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "apiVersion",
                    ObjectReference::get_apiVersion_for_reflect,
                    ObjectReference::mut_apiVersion_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "resourceVersion",
                    ObjectReference::get_resourceVersion_for_reflect,
                    ObjectReference::mut_resourceVersion_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fieldPath",
                    ObjectReference::get_fieldPath_for_reflect,
                    ObjectReference::mut_fieldPath_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ObjectReference>(
                    "ObjectReference",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ObjectReference {
    fn clear(&mut self) {
        self.clear_kind();
        self.clear_namespace();
        self.clear_name();
        self.clear_uid();
        self.clear_apiVersion();
        self.clear_resourceVersion();
        self.clear_fieldPath();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObjectReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectReference {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolume {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    spec: ::protobuf::SingularPtrField<PersistentVolumeSpec>,
    status: ::protobuf::SingularPtrField<PersistentVolumeStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PersistentVolume {}

impl PersistentVolume {
    pub fn new() -> PersistentVolume {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PersistentVolume {
        static mut instance: ::protobuf::lazy::Lazy<PersistentVolume> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentVolume,
        };
        unsafe {
            instance.get(PersistentVolume::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeSpec spec = 2;

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PersistentVolumeSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PersistentVolumeSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> PersistentVolumeSpec {
        self.spec.take().unwrap_or_else(|| PersistentVolumeSpec::new())
    }

    pub fn get_spec(&self) -> &PersistentVolumeSpec {
        self.spec.as_ref().unwrap_or_else(|| PersistentVolumeSpec::default_instance())
    }

    fn get_spec_for_reflect(&self) -> &::protobuf::SingularPtrField<PersistentVolumeSpec> {
        &self.spec
    }

    fn mut_spec_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PersistentVolumeSpec> {
        &mut self.spec
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeStatus status = 3;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PersistentVolumeStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PersistentVolumeStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> PersistentVolumeStatus {
        self.status.take().unwrap_or_else(|| PersistentVolumeStatus::new())
    }

    pub fn get_status(&self) -> &PersistentVolumeStatus {
        self.status.as_ref().unwrap_or_else(|| PersistentVolumeStatus::default_instance())
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularPtrField<PersistentVolumeStatus> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PersistentVolumeStatus> {
        &mut self.status
    }
}

impl ::protobuf::Message for PersistentVolume {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PersistentVolume {
    fn new() -> PersistentVolume {
        PersistentVolume::new()
    }

    fn descriptor_static(_: ::std::option::Option<PersistentVolume>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    PersistentVolume::get_metadata_for_reflect,
                    PersistentVolume::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeSpec>>(
                    "spec",
                    PersistentVolume::get_spec_for_reflect,
                    PersistentVolume::mut_spec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeStatus>>(
                    "status",
                    PersistentVolume::get_status_for_reflect,
                    PersistentVolume::mut_status_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentVolume>(
                    "PersistentVolume",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PersistentVolume {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_spec();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolume {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeClaim {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    spec: ::protobuf::SingularPtrField<PersistentVolumeClaimSpec>,
    status: ::protobuf::SingularPtrField<PersistentVolumeClaimStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PersistentVolumeClaim {}

impl PersistentVolumeClaim {
    pub fn new() -> PersistentVolumeClaim {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PersistentVolumeClaim {
        static mut instance: ::protobuf::lazy::Lazy<PersistentVolumeClaim> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentVolumeClaim,
        };
        unsafe {
            instance.get(PersistentVolumeClaim::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PersistentVolumeClaimSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PersistentVolumeClaimSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> PersistentVolumeClaimSpec {
        self.spec.take().unwrap_or_else(|| PersistentVolumeClaimSpec::new())
    }

    pub fn get_spec(&self) -> &PersistentVolumeClaimSpec {
        self.spec.as_ref().unwrap_or_else(|| PersistentVolumeClaimSpec::default_instance())
    }

    fn get_spec_for_reflect(&self) -> &::protobuf::SingularPtrField<PersistentVolumeClaimSpec> {
        &self.spec
    }

    fn mut_spec_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PersistentVolumeClaimSpec> {
        &mut self.spec
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeClaimStatus status = 3;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PersistentVolumeClaimStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PersistentVolumeClaimStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> PersistentVolumeClaimStatus {
        self.status.take().unwrap_or_else(|| PersistentVolumeClaimStatus::new())
    }

    pub fn get_status(&self) -> &PersistentVolumeClaimStatus {
        self.status.as_ref().unwrap_or_else(|| PersistentVolumeClaimStatus::default_instance())
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularPtrField<PersistentVolumeClaimStatus> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PersistentVolumeClaimStatus> {
        &mut self.status
    }
}

impl ::protobuf::Message for PersistentVolumeClaim {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PersistentVolumeClaim {
    fn new() -> PersistentVolumeClaim {
        PersistentVolumeClaim::new()
    }

    fn descriptor_static(_: ::std::option::Option<PersistentVolumeClaim>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    PersistentVolumeClaim::get_metadata_for_reflect,
                    PersistentVolumeClaim::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeClaimSpec>>(
                    "spec",
                    PersistentVolumeClaim::get_spec_for_reflect,
                    PersistentVolumeClaim::mut_spec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeClaimStatus>>(
                    "status",
                    PersistentVolumeClaim::get_status_for_reflect,
                    PersistentVolumeClaim::mut_status_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentVolumeClaim>(
                    "PersistentVolumeClaim",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PersistentVolumeClaim {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_spec();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeClaim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaim {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeClaimList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<PersistentVolumeClaim>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PersistentVolumeClaimList {}

impl PersistentVolumeClaimList {
    pub fn new() -> PersistentVolumeClaimList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PersistentVolumeClaimList {
        static mut instance: ::protobuf::lazy::Lazy<PersistentVolumeClaimList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentVolumeClaimList,
        };
        unsafe {
            instance.get(PersistentVolumeClaimList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.PersistentVolumeClaim items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<PersistentVolumeClaim>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<PersistentVolumeClaim> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<PersistentVolumeClaim> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[PersistentVolumeClaim] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<PersistentVolumeClaim> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<PersistentVolumeClaim> {
        &mut self.items
    }
}

impl ::protobuf::Message for PersistentVolumeClaimList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PersistentVolumeClaimList {
    fn new() -> PersistentVolumeClaimList {
        PersistentVolumeClaimList::new()
    }

    fn descriptor_static(_: ::std::option::Option<PersistentVolumeClaimList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    PersistentVolumeClaimList::get_metadata_for_reflect,
                    PersistentVolumeClaimList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeClaim>>(
                    "items",
                    PersistentVolumeClaimList::get_items_for_reflect,
                    PersistentVolumeClaimList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentVolumeClaimList>(
                    "PersistentVolumeClaimList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PersistentVolumeClaimList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeClaimList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeClaimSpec {
    // message fields
    accessModes: ::protobuf::RepeatedField<::std::string::String>,
    selector: ::protobuf::SingularPtrField<super::generated::LabelSelector>,
    resources: ::protobuf::SingularPtrField<ResourceRequirements>,
    volumeName: ::protobuf::SingularField<::std::string::String>,
    storageClassName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PersistentVolumeClaimSpec {}

impl PersistentVolumeClaimSpec {
    pub fn new() -> PersistentVolumeClaimSpec {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PersistentVolumeClaimSpec {
        static mut instance: ::protobuf::lazy::Lazy<PersistentVolumeClaimSpec> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentVolumeClaimSpec,
        };
        unsafe {
            instance.get(PersistentVolumeClaimSpec::new)
        }
    }

    // repeated string accessModes = 1;

    pub fn clear_accessModes(&mut self) {
        self.accessModes.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessModes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accessModes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accessModes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accessModes
    }

    // Take field
    pub fn take_accessModes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.accessModes, ::protobuf::RepeatedField::new())
    }

    pub fn get_accessModes(&self) -> &[::std::string::String] {
        &self.accessModes
    }

    fn get_accessModes_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.accessModes
    }

    fn mut_accessModes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accessModes
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: super::generated::LabelSelector) {
        self.selector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut super::generated::LabelSelector {
        if self.selector.is_none() {
            self.selector.set_default();
        }
        self.selector.as_mut().unwrap()
    }

    // Take field
    pub fn take_selector(&mut self) -> super::generated::LabelSelector {
        self.selector.take().unwrap_or_else(|| super::generated::LabelSelector::new())
    }

    pub fn get_selector(&self) -> &super::generated::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| super::generated::LabelSelector::default_instance())
    }

    fn get_selector_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::LabelSelector> {
        &self.selector
    }

    fn mut_selector_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::LabelSelector> {
        &mut self.selector
    }

    // optional .k8s.io.api.core.v1.ResourceRequirements resources = 2;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ResourceRequirements) {
        self.resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut ResourceRequirements {
        if self.resources.is_none() {
            self.resources.set_default();
        }
        self.resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_resources(&mut self) -> ResourceRequirements {
        self.resources.take().unwrap_or_else(|| ResourceRequirements::new())
    }

    pub fn get_resources(&self) -> &ResourceRequirements {
        self.resources.as_ref().unwrap_or_else(|| ResourceRequirements::default_instance())
    }

    fn get_resources_for_reflect(&self) -> &::protobuf::SingularPtrField<ResourceRequirements> {
        &self.resources
    }

    fn mut_resources_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ResourceRequirements> {
        &mut self.resources
    }

    // optional string volumeName = 3;

    pub fn clear_volumeName(&mut self) {
        self.volumeName.clear();
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName.set_default();
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volumeName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volumeName
    }

    fn mut_volumeName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volumeName
    }

    // optional string storageClassName = 5;

    pub fn clear_storageClassName(&mut self) {
        self.storageClassName.clear();
    }

    pub fn has_storageClassName(&self) -> bool {
        self.storageClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageClassName(&mut self, v: ::std::string::String) {
        self.storageClassName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageClassName(&mut self) -> &mut ::std::string::String {
        if self.storageClassName.is_none() {
            self.storageClassName.set_default();
        }
        self.storageClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageClassName(&mut self) -> ::std::string::String {
        self.storageClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_storageClassName(&self) -> &str {
        match self.storageClassName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_storageClassName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.storageClassName
    }

    fn mut_storageClassName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.storageClassName
    }
}

impl ::protobuf::Message for PersistentVolumeClaimSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.selector {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.accessModes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selector)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resources)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeName)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageClassName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.accessModes {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.storageClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.accessModes {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.selector.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.resources.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.volumeName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.storageClassName.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PersistentVolumeClaimSpec {
    fn new() -> PersistentVolumeClaimSpec {
        PersistentVolumeClaimSpec::new()
    }

    fn descriptor_static(_: ::std::option::Option<PersistentVolumeClaimSpec>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "accessModes",
                    PersistentVolumeClaimSpec::get_accessModes_for_reflect,
                    PersistentVolumeClaimSpec::mut_accessModes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::LabelSelector>>(
                    "selector",
                    PersistentVolumeClaimSpec::get_selector_for_reflect,
                    PersistentVolumeClaimSpec::mut_selector_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceRequirements>>(
                    "resources",
                    PersistentVolumeClaimSpec::get_resources_for_reflect,
                    PersistentVolumeClaimSpec::mut_resources_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volumeName",
                    PersistentVolumeClaimSpec::get_volumeName_for_reflect,
                    PersistentVolumeClaimSpec::mut_volumeName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storageClassName",
                    PersistentVolumeClaimSpec::get_storageClassName_for_reflect,
                    PersistentVolumeClaimSpec::mut_storageClassName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentVolumeClaimSpec>(
                    "PersistentVolumeClaimSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PersistentVolumeClaimSpec {
    fn clear(&mut self) {
        self.clear_accessModes();
        self.clear_selector();
        self.clear_resources();
        self.clear_volumeName();
        self.clear_storageClassName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeClaimSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeClaimStatus {
    // message fields
    phase: ::protobuf::SingularField<::std::string::String>,
    accessModes: ::protobuf::RepeatedField<::std::string::String>,
    pub capacity: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PersistentVolumeClaimStatus {}

impl PersistentVolumeClaimStatus {
    pub fn new() -> PersistentVolumeClaimStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PersistentVolumeClaimStatus {
        static mut instance: ::protobuf::lazy::Lazy<PersistentVolumeClaimStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentVolumeClaimStatus,
        };
        unsafe {
            instance.get(PersistentVolumeClaimStatus::new)
        }
    }

    // optional string phase = 1;

    pub fn clear_phase(&mut self) {
        self.phase.clear();
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase.set_default();
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_phase_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.phase
    }

    fn mut_phase_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.phase
    }

    // repeated string accessModes = 2;

    pub fn clear_accessModes(&mut self) {
        self.accessModes.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessModes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accessModes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accessModes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accessModes
    }

    // Take field
    pub fn take_accessModes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.accessModes, ::protobuf::RepeatedField::new())
    }

    pub fn get_accessModes(&self) -> &[::std::string::String] {
        &self.accessModes
    }

    fn get_accessModes_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.accessModes
    }

    fn mut_accessModes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accessModes
    }

    // repeated .k8s.io.api.core.v1.PersistentVolumeClaimStatus.CapacityEntry capacity = 3;

    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.capacity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capacity(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.capacity
    }

    // Take field
    pub fn take_capacity(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.capacity, ::std::collections::HashMap::new())
    }

    pub fn get_capacity(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.capacity
    }

    fn get_capacity_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.capacity
    }

    fn mut_capacity_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.capacity
    }
}

impl ::protobuf::Message for PersistentVolumeClaimStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phase)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.accessModes)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.capacity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.accessModes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(3, &self.capacity);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.phase.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.accessModes {
            os.write_string(2, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(3, &self.capacity, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PersistentVolumeClaimStatus {
    fn new() -> PersistentVolumeClaimStatus {
        PersistentVolumeClaimStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<PersistentVolumeClaimStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "phase",
                    PersistentVolumeClaimStatus::get_phase_for_reflect,
                    PersistentVolumeClaimStatus::mut_phase_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "accessModes",
                    PersistentVolumeClaimStatus::get_accessModes_for_reflect,
                    PersistentVolumeClaimStatus::mut_accessModes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "capacity",
                    PersistentVolumeClaimStatus::get_capacity_for_reflect,
                    PersistentVolumeClaimStatus::mut_capacity_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentVolumeClaimStatus>(
                    "PersistentVolumeClaimStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PersistentVolumeClaimStatus {
    fn clear(&mut self) {
        self.clear_phase();
        self.clear_accessModes();
        self.clear_capacity();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeClaimStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeClaimVolumeSource {
    // message fields
    claimName: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PersistentVolumeClaimVolumeSource {}

impl PersistentVolumeClaimVolumeSource {
    pub fn new() -> PersistentVolumeClaimVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PersistentVolumeClaimVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<PersistentVolumeClaimVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentVolumeClaimVolumeSource,
        };
        unsafe {
            instance.get(PersistentVolumeClaimVolumeSource::new)
        }
    }

    // optional string claimName = 1;

    pub fn clear_claimName(&mut self) {
        self.claimName.clear();
    }

    pub fn has_claimName(&self) -> bool {
        self.claimName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimName(&mut self, v: ::std::string::String) {
        self.claimName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_claimName(&mut self) -> &mut ::std::string::String {
        if self.claimName.is_none() {
            self.claimName.set_default();
        }
        self.claimName.as_mut().unwrap()
    }

    // Take field
    pub fn take_claimName(&mut self) -> ::std::string::String {
        self.claimName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_claimName(&self) -> &str {
        match self.claimName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_claimName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.claimName
    }

    fn mut_claimName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.claimName
    }

    // optional bool readOnly = 2;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }
}

impl ::protobuf::Message for PersistentVolumeClaimVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.claimName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.claimName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.claimName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PersistentVolumeClaimVolumeSource {
    fn new() -> PersistentVolumeClaimVolumeSource {
        PersistentVolumeClaimVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<PersistentVolumeClaimVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "claimName",
                    PersistentVolumeClaimVolumeSource::get_claimName_for_reflect,
                    PersistentVolumeClaimVolumeSource::mut_claimName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    PersistentVolumeClaimVolumeSource::get_readOnly_for_reflect,
                    PersistentVolumeClaimVolumeSource::mut_readOnly_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentVolumeClaimVolumeSource>(
                    "PersistentVolumeClaimVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PersistentVolumeClaimVolumeSource {
    fn clear(&mut self) {
        self.clear_claimName();
        self.clear_readOnly();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeClaimVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<PersistentVolume>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PersistentVolumeList {}

impl PersistentVolumeList {
    pub fn new() -> PersistentVolumeList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PersistentVolumeList {
        static mut instance: ::protobuf::lazy::Lazy<PersistentVolumeList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentVolumeList,
        };
        unsafe {
            instance.get(PersistentVolumeList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.PersistentVolume items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<PersistentVolume>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<PersistentVolume> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<PersistentVolume> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[PersistentVolume] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<PersistentVolume> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<PersistentVolume> {
        &mut self.items
    }
}

impl ::protobuf::Message for PersistentVolumeList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PersistentVolumeList {
    fn new() -> PersistentVolumeList {
        PersistentVolumeList::new()
    }

    fn descriptor_static(_: ::std::option::Option<PersistentVolumeList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    PersistentVolumeList::get_metadata_for_reflect,
                    PersistentVolumeList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolume>>(
                    "items",
                    PersistentVolumeList::get_items_for_reflect,
                    PersistentVolumeList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentVolumeList>(
                    "PersistentVolumeList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PersistentVolumeList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeSource {
    // message fields
    gcePersistentDisk: ::protobuf::SingularPtrField<GCEPersistentDiskVolumeSource>,
    awsElasticBlockStore: ::protobuf::SingularPtrField<AWSElasticBlockStoreVolumeSource>,
    hostPath: ::protobuf::SingularPtrField<HostPathVolumeSource>,
    glusterfs: ::protobuf::SingularPtrField<GlusterfsVolumeSource>,
    nfs: ::protobuf::SingularPtrField<NFSVolumeSource>,
    rbd: ::protobuf::SingularPtrField<RBDVolumeSource>,
    iscsi: ::protobuf::SingularPtrField<ISCSIVolumeSource>,
    cinder: ::protobuf::SingularPtrField<CinderVolumeSource>,
    cephfs: ::protobuf::SingularPtrField<CephFSVolumeSource>,
    fc: ::protobuf::SingularPtrField<FCVolumeSource>,
    flocker: ::protobuf::SingularPtrField<FlockerVolumeSource>,
    flexVolume: ::protobuf::SingularPtrField<FlexVolumeSource>,
    azureFile: ::protobuf::SingularPtrField<AzureFileVolumeSource>,
    vsphereVolume: ::protobuf::SingularPtrField<VsphereVirtualDiskVolumeSource>,
    quobyte: ::protobuf::SingularPtrField<QuobyteVolumeSource>,
    azureDisk: ::protobuf::SingularPtrField<AzureDiskVolumeSource>,
    photonPersistentDisk: ::protobuf::SingularPtrField<PhotonPersistentDiskVolumeSource>,
    portworxVolume: ::protobuf::SingularPtrField<PortworxVolumeSource>,
    scaleIO: ::protobuf::SingularPtrField<ScaleIOVolumeSource>,
    local: ::protobuf::SingularPtrField<LocalVolumeSource>,
    storageos: ::protobuf::SingularPtrField<StorageOSPersistentVolumeSource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PersistentVolumeSource {}

impl PersistentVolumeSource {
    pub fn new() -> PersistentVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PersistentVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<PersistentVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentVolumeSource,
        };
        unsafe {
            instance.get(PersistentVolumeSource::new)
        }
    }

    // optional .k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 1;

    pub fn clear_gcePersistentDisk(&mut self) {
        self.gcePersistentDisk.clear();
    }

    pub fn has_gcePersistentDisk(&self) -> bool {
        self.gcePersistentDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcePersistentDisk(&mut self, v: GCEPersistentDiskVolumeSource) {
        self.gcePersistentDisk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcePersistentDisk(&mut self) -> &mut GCEPersistentDiskVolumeSource {
        if self.gcePersistentDisk.is_none() {
            self.gcePersistentDisk.set_default();
        }
        self.gcePersistentDisk.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcePersistentDisk(&mut self) -> GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.take().unwrap_or_else(|| GCEPersistentDiskVolumeSource::new())
    }

    pub fn get_gcePersistentDisk(&self) -> &GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.as_ref().unwrap_or_else(|| GCEPersistentDiskVolumeSource::default_instance())
    }

    fn get_gcePersistentDisk_for_reflect(&self) -> &::protobuf::SingularPtrField<GCEPersistentDiskVolumeSource> {
        &self.gcePersistentDisk
    }

    fn mut_gcePersistentDisk_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<GCEPersistentDiskVolumeSource> {
        &mut self.gcePersistentDisk
    }

    // optional .k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 2;

    pub fn clear_awsElasticBlockStore(&mut self) {
        self.awsElasticBlockStore.clear();
    }

    pub fn has_awsElasticBlockStore(&self) -> bool {
        self.awsElasticBlockStore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_awsElasticBlockStore(&mut self, v: AWSElasticBlockStoreVolumeSource) {
        self.awsElasticBlockStore = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_awsElasticBlockStore(&mut self) -> &mut AWSElasticBlockStoreVolumeSource {
        if self.awsElasticBlockStore.is_none() {
            self.awsElasticBlockStore.set_default();
        }
        self.awsElasticBlockStore.as_mut().unwrap()
    }

    // Take field
    pub fn take_awsElasticBlockStore(&mut self) -> AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.take().unwrap_or_else(|| AWSElasticBlockStoreVolumeSource::new())
    }

    pub fn get_awsElasticBlockStore(&self) -> &AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.as_ref().unwrap_or_else(|| AWSElasticBlockStoreVolumeSource::default_instance())
    }

    fn get_awsElasticBlockStore_for_reflect(&self) -> &::protobuf::SingularPtrField<AWSElasticBlockStoreVolumeSource> {
        &self.awsElasticBlockStore
    }

    fn mut_awsElasticBlockStore_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AWSElasticBlockStoreVolumeSource> {
        &mut self.awsElasticBlockStore
    }

    // optional .k8s.io.api.core.v1.HostPathVolumeSource hostPath = 3;

    pub fn clear_hostPath(&mut self) {
        self.hostPath.clear();
    }

    pub fn has_hostPath(&self) -> bool {
        self.hostPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostPath(&mut self, v: HostPathVolumeSource) {
        self.hostPath = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostPath(&mut self) -> &mut HostPathVolumeSource {
        if self.hostPath.is_none() {
            self.hostPath.set_default();
        }
        self.hostPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostPath(&mut self) -> HostPathVolumeSource {
        self.hostPath.take().unwrap_or_else(|| HostPathVolumeSource::new())
    }

    pub fn get_hostPath(&self) -> &HostPathVolumeSource {
        self.hostPath.as_ref().unwrap_or_else(|| HostPathVolumeSource::default_instance())
    }

    fn get_hostPath_for_reflect(&self) -> &::protobuf::SingularPtrField<HostPathVolumeSource> {
        &self.hostPath
    }

    fn mut_hostPath_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<HostPathVolumeSource> {
        &mut self.hostPath
    }

    // optional .k8s.io.api.core.v1.GlusterfsVolumeSource glusterfs = 4;

    pub fn clear_glusterfs(&mut self) {
        self.glusterfs.clear();
    }

    pub fn has_glusterfs(&self) -> bool {
        self.glusterfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_glusterfs(&mut self, v: GlusterfsVolumeSource) {
        self.glusterfs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_glusterfs(&mut self) -> &mut GlusterfsVolumeSource {
        if self.glusterfs.is_none() {
            self.glusterfs.set_default();
        }
        self.glusterfs.as_mut().unwrap()
    }

    // Take field
    pub fn take_glusterfs(&mut self) -> GlusterfsVolumeSource {
        self.glusterfs.take().unwrap_or_else(|| GlusterfsVolumeSource::new())
    }

    pub fn get_glusterfs(&self) -> &GlusterfsVolumeSource {
        self.glusterfs.as_ref().unwrap_or_else(|| GlusterfsVolumeSource::default_instance())
    }

    fn get_glusterfs_for_reflect(&self) -> &::protobuf::SingularPtrField<GlusterfsVolumeSource> {
        &self.glusterfs
    }

    fn mut_glusterfs_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<GlusterfsVolumeSource> {
        &mut self.glusterfs
    }

    // optional .k8s.io.api.core.v1.NFSVolumeSource nfs = 5;

    pub fn clear_nfs(&mut self) {
        self.nfs.clear();
    }

    pub fn has_nfs(&self) -> bool {
        self.nfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nfs(&mut self, v: NFSVolumeSource) {
        self.nfs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nfs(&mut self) -> &mut NFSVolumeSource {
        if self.nfs.is_none() {
            self.nfs.set_default();
        }
        self.nfs.as_mut().unwrap()
    }

    // Take field
    pub fn take_nfs(&mut self) -> NFSVolumeSource {
        self.nfs.take().unwrap_or_else(|| NFSVolumeSource::new())
    }

    pub fn get_nfs(&self) -> &NFSVolumeSource {
        self.nfs.as_ref().unwrap_or_else(|| NFSVolumeSource::default_instance())
    }

    fn get_nfs_for_reflect(&self) -> &::protobuf::SingularPtrField<NFSVolumeSource> {
        &self.nfs
    }

    fn mut_nfs_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<NFSVolumeSource> {
        &mut self.nfs
    }

    // optional .k8s.io.api.core.v1.RBDVolumeSource rbd = 6;

    pub fn clear_rbd(&mut self) {
        self.rbd.clear();
    }

    pub fn has_rbd(&self) -> bool {
        self.rbd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rbd(&mut self, v: RBDVolumeSource) {
        self.rbd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rbd(&mut self) -> &mut RBDVolumeSource {
        if self.rbd.is_none() {
            self.rbd.set_default();
        }
        self.rbd.as_mut().unwrap()
    }

    // Take field
    pub fn take_rbd(&mut self) -> RBDVolumeSource {
        self.rbd.take().unwrap_or_else(|| RBDVolumeSource::new())
    }

    pub fn get_rbd(&self) -> &RBDVolumeSource {
        self.rbd.as_ref().unwrap_or_else(|| RBDVolumeSource::default_instance())
    }

    fn get_rbd_for_reflect(&self) -> &::protobuf::SingularPtrField<RBDVolumeSource> {
        &self.rbd
    }

    fn mut_rbd_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<RBDVolumeSource> {
        &mut self.rbd
    }

    // optional .k8s.io.api.core.v1.ISCSIVolumeSource iscsi = 7;

    pub fn clear_iscsi(&mut self) {
        self.iscsi.clear();
    }

    pub fn has_iscsi(&self) -> bool {
        self.iscsi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iscsi(&mut self, v: ISCSIVolumeSource) {
        self.iscsi = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iscsi(&mut self) -> &mut ISCSIVolumeSource {
        if self.iscsi.is_none() {
            self.iscsi.set_default();
        }
        self.iscsi.as_mut().unwrap()
    }

    // Take field
    pub fn take_iscsi(&mut self) -> ISCSIVolumeSource {
        self.iscsi.take().unwrap_or_else(|| ISCSIVolumeSource::new())
    }

    pub fn get_iscsi(&self) -> &ISCSIVolumeSource {
        self.iscsi.as_ref().unwrap_or_else(|| ISCSIVolumeSource::default_instance())
    }

    fn get_iscsi_for_reflect(&self) -> &::protobuf::SingularPtrField<ISCSIVolumeSource> {
        &self.iscsi
    }

    fn mut_iscsi_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ISCSIVolumeSource> {
        &mut self.iscsi
    }

    // optional .k8s.io.api.core.v1.CinderVolumeSource cinder = 8;

    pub fn clear_cinder(&mut self) {
        self.cinder.clear();
    }

    pub fn has_cinder(&self) -> bool {
        self.cinder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cinder(&mut self, v: CinderVolumeSource) {
        self.cinder = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cinder(&mut self) -> &mut CinderVolumeSource {
        if self.cinder.is_none() {
            self.cinder.set_default();
        }
        self.cinder.as_mut().unwrap()
    }

    // Take field
    pub fn take_cinder(&mut self) -> CinderVolumeSource {
        self.cinder.take().unwrap_or_else(|| CinderVolumeSource::new())
    }

    pub fn get_cinder(&self) -> &CinderVolumeSource {
        self.cinder.as_ref().unwrap_or_else(|| CinderVolumeSource::default_instance())
    }

    fn get_cinder_for_reflect(&self) -> &::protobuf::SingularPtrField<CinderVolumeSource> {
        &self.cinder
    }

    fn mut_cinder_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CinderVolumeSource> {
        &mut self.cinder
    }

    // optional .k8s.io.api.core.v1.CephFSVolumeSource cephfs = 9;

    pub fn clear_cephfs(&mut self) {
        self.cephfs.clear();
    }

    pub fn has_cephfs(&self) -> bool {
        self.cephfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cephfs(&mut self, v: CephFSVolumeSource) {
        self.cephfs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cephfs(&mut self) -> &mut CephFSVolumeSource {
        if self.cephfs.is_none() {
            self.cephfs.set_default();
        }
        self.cephfs.as_mut().unwrap()
    }

    // Take field
    pub fn take_cephfs(&mut self) -> CephFSVolumeSource {
        self.cephfs.take().unwrap_or_else(|| CephFSVolumeSource::new())
    }

    pub fn get_cephfs(&self) -> &CephFSVolumeSource {
        self.cephfs.as_ref().unwrap_or_else(|| CephFSVolumeSource::default_instance())
    }

    fn get_cephfs_for_reflect(&self) -> &::protobuf::SingularPtrField<CephFSVolumeSource> {
        &self.cephfs
    }

    fn mut_cephfs_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CephFSVolumeSource> {
        &mut self.cephfs
    }

    // optional .k8s.io.api.core.v1.FCVolumeSource fc = 10;

    pub fn clear_fc(&mut self) {
        self.fc.clear();
    }

    pub fn has_fc(&self) -> bool {
        self.fc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fc(&mut self, v: FCVolumeSource) {
        self.fc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fc(&mut self) -> &mut FCVolumeSource {
        if self.fc.is_none() {
            self.fc.set_default();
        }
        self.fc.as_mut().unwrap()
    }

    // Take field
    pub fn take_fc(&mut self) -> FCVolumeSource {
        self.fc.take().unwrap_or_else(|| FCVolumeSource::new())
    }

    pub fn get_fc(&self) -> &FCVolumeSource {
        self.fc.as_ref().unwrap_or_else(|| FCVolumeSource::default_instance())
    }

    fn get_fc_for_reflect(&self) -> &::protobuf::SingularPtrField<FCVolumeSource> {
        &self.fc
    }

    fn mut_fc_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<FCVolumeSource> {
        &mut self.fc
    }

    // optional .k8s.io.api.core.v1.FlockerVolumeSource flocker = 11;

    pub fn clear_flocker(&mut self) {
        self.flocker.clear();
    }

    pub fn has_flocker(&self) -> bool {
        self.flocker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flocker(&mut self, v: FlockerVolumeSource) {
        self.flocker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flocker(&mut self) -> &mut FlockerVolumeSource {
        if self.flocker.is_none() {
            self.flocker.set_default();
        }
        self.flocker.as_mut().unwrap()
    }

    // Take field
    pub fn take_flocker(&mut self) -> FlockerVolumeSource {
        self.flocker.take().unwrap_or_else(|| FlockerVolumeSource::new())
    }

    pub fn get_flocker(&self) -> &FlockerVolumeSource {
        self.flocker.as_ref().unwrap_or_else(|| FlockerVolumeSource::default_instance())
    }

    fn get_flocker_for_reflect(&self) -> &::protobuf::SingularPtrField<FlockerVolumeSource> {
        &self.flocker
    }

    fn mut_flocker_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<FlockerVolumeSource> {
        &mut self.flocker
    }

    // optional .k8s.io.api.core.v1.FlexVolumeSource flexVolume = 12;

    pub fn clear_flexVolume(&mut self) {
        self.flexVolume.clear();
    }

    pub fn has_flexVolume(&self) -> bool {
        self.flexVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flexVolume(&mut self, v: FlexVolumeSource) {
        self.flexVolume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flexVolume(&mut self) -> &mut FlexVolumeSource {
        if self.flexVolume.is_none() {
            self.flexVolume.set_default();
        }
        self.flexVolume.as_mut().unwrap()
    }

    // Take field
    pub fn take_flexVolume(&mut self) -> FlexVolumeSource {
        self.flexVolume.take().unwrap_or_else(|| FlexVolumeSource::new())
    }

    pub fn get_flexVolume(&self) -> &FlexVolumeSource {
        self.flexVolume.as_ref().unwrap_or_else(|| FlexVolumeSource::default_instance())
    }

    fn get_flexVolume_for_reflect(&self) -> &::protobuf::SingularPtrField<FlexVolumeSource> {
        &self.flexVolume
    }

    fn mut_flexVolume_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<FlexVolumeSource> {
        &mut self.flexVolume
    }

    // optional .k8s.io.api.core.v1.AzureFileVolumeSource azureFile = 13;

    pub fn clear_azureFile(&mut self) {
        self.azureFile.clear();
    }

    pub fn has_azureFile(&self) -> bool {
        self.azureFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azureFile(&mut self, v: AzureFileVolumeSource) {
        self.azureFile = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azureFile(&mut self) -> &mut AzureFileVolumeSource {
        if self.azureFile.is_none() {
            self.azureFile.set_default();
        }
        self.azureFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_azureFile(&mut self) -> AzureFileVolumeSource {
        self.azureFile.take().unwrap_or_else(|| AzureFileVolumeSource::new())
    }

    pub fn get_azureFile(&self) -> &AzureFileVolumeSource {
        self.azureFile.as_ref().unwrap_or_else(|| AzureFileVolumeSource::default_instance())
    }

    fn get_azureFile_for_reflect(&self) -> &::protobuf::SingularPtrField<AzureFileVolumeSource> {
        &self.azureFile
    }

    fn mut_azureFile_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AzureFileVolumeSource> {
        &mut self.azureFile
    }

    // optional .k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 14;

    pub fn clear_vsphereVolume(&mut self) {
        self.vsphereVolume.clear();
    }

    pub fn has_vsphereVolume(&self) -> bool {
        self.vsphereVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vsphereVolume(&mut self, v: VsphereVirtualDiskVolumeSource) {
        self.vsphereVolume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vsphereVolume(&mut self) -> &mut VsphereVirtualDiskVolumeSource {
        if self.vsphereVolume.is_none() {
            self.vsphereVolume.set_default();
        }
        self.vsphereVolume.as_mut().unwrap()
    }

    // Take field
    pub fn take_vsphereVolume(&mut self) -> VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.take().unwrap_or_else(|| VsphereVirtualDiskVolumeSource::new())
    }

    pub fn get_vsphereVolume(&self) -> &VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.as_ref().unwrap_or_else(|| VsphereVirtualDiskVolumeSource::default_instance())
    }

    fn get_vsphereVolume_for_reflect(&self) -> &::protobuf::SingularPtrField<VsphereVirtualDiskVolumeSource> {
        &self.vsphereVolume
    }

    fn mut_vsphereVolume_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<VsphereVirtualDiskVolumeSource> {
        &mut self.vsphereVolume
    }

    // optional .k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 15;

    pub fn clear_quobyte(&mut self) {
        self.quobyte.clear();
    }

    pub fn has_quobyte(&self) -> bool {
        self.quobyte.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quobyte(&mut self, v: QuobyteVolumeSource) {
        self.quobyte = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quobyte(&mut self) -> &mut QuobyteVolumeSource {
        if self.quobyte.is_none() {
            self.quobyte.set_default();
        }
        self.quobyte.as_mut().unwrap()
    }

    // Take field
    pub fn take_quobyte(&mut self) -> QuobyteVolumeSource {
        self.quobyte.take().unwrap_or_else(|| QuobyteVolumeSource::new())
    }

    pub fn get_quobyte(&self) -> &QuobyteVolumeSource {
        self.quobyte.as_ref().unwrap_or_else(|| QuobyteVolumeSource::default_instance())
    }

    fn get_quobyte_for_reflect(&self) -> &::protobuf::SingularPtrField<QuobyteVolumeSource> {
        &self.quobyte
    }

    fn mut_quobyte_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<QuobyteVolumeSource> {
        &mut self.quobyte
    }

    // optional .k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 16;

    pub fn clear_azureDisk(&mut self) {
        self.azureDisk.clear();
    }

    pub fn has_azureDisk(&self) -> bool {
        self.azureDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azureDisk(&mut self, v: AzureDiskVolumeSource) {
        self.azureDisk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azureDisk(&mut self) -> &mut AzureDiskVolumeSource {
        if self.azureDisk.is_none() {
            self.azureDisk.set_default();
        }
        self.azureDisk.as_mut().unwrap()
    }

    // Take field
    pub fn take_azureDisk(&mut self) -> AzureDiskVolumeSource {
        self.azureDisk.take().unwrap_or_else(|| AzureDiskVolumeSource::new())
    }

    pub fn get_azureDisk(&self) -> &AzureDiskVolumeSource {
        self.azureDisk.as_ref().unwrap_or_else(|| AzureDiskVolumeSource::default_instance())
    }

    fn get_azureDisk_for_reflect(&self) -> &::protobuf::SingularPtrField<AzureDiskVolumeSource> {
        &self.azureDisk
    }

    fn mut_azureDisk_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AzureDiskVolumeSource> {
        &mut self.azureDisk
    }

    // optional .k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 17;

    pub fn clear_photonPersistentDisk(&mut self) {
        self.photonPersistentDisk.clear();
    }

    pub fn has_photonPersistentDisk(&self) -> bool {
        self.photonPersistentDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_photonPersistentDisk(&mut self, v: PhotonPersistentDiskVolumeSource) {
        self.photonPersistentDisk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_photonPersistentDisk(&mut self) -> &mut PhotonPersistentDiskVolumeSource {
        if self.photonPersistentDisk.is_none() {
            self.photonPersistentDisk.set_default();
        }
        self.photonPersistentDisk.as_mut().unwrap()
    }

    // Take field
    pub fn take_photonPersistentDisk(&mut self) -> PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.take().unwrap_or_else(|| PhotonPersistentDiskVolumeSource::new())
    }

    pub fn get_photonPersistentDisk(&self) -> &PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.as_ref().unwrap_or_else(|| PhotonPersistentDiskVolumeSource::default_instance())
    }

    fn get_photonPersistentDisk_for_reflect(&self) -> &::protobuf::SingularPtrField<PhotonPersistentDiskVolumeSource> {
        &self.photonPersistentDisk
    }

    fn mut_photonPersistentDisk_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PhotonPersistentDiskVolumeSource> {
        &mut self.photonPersistentDisk
    }

    // optional .k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 18;

    pub fn clear_portworxVolume(&mut self) {
        self.portworxVolume.clear();
    }

    pub fn has_portworxVolume(&self) -> bool {
        self.portworxVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portworxVolume(&mut self, v: PortworxVolumeSource) {
        self.portworxVolume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portworxVolume(&mut self) -> &mut PortworxVolumeSource {
        if self.portworxVolume.is_none() {
            self.portworxVolume.set_default();
        }
        self.portworxVolume.as_mut().unwrap()
    }

    // Take field
    pub fn take_portworxVolume(&mut self) -> PortworxVolumeSource {
        self.portworxVolume.take().unwrap_or_else(|| PortworxVolumeSource::new())
    }

    pub fn get_portworxVolume(&self) -> &PortworxVolumeSource {
        self.portworxVolume.as_ref().unwrap_or_else(|| PortworxVolumeSource::default_instance())
    }

    fn get_portworxVolume_for_reflect(&self) -> &::protobuf::SingularPtrField<PortworxVolumeSource> {
        &self.portworxVolume
    }

    fn mut_portworxVolume_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PortworxVolumeSource> {
        &mut self.portworxVolume
    }

    // optional .k8s.io.api.core.v1.ScaleIOVolumeSource scaleIO = 19;

    pub fn clear_scaleIO(&mut self) {
        self.scaleIO.clear();
    }

    pub fn has_scaleIO(&self) -> bool {
        self.scaleIO.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaleIO(&mut self, v: ScaleIOVolumeSource) {
        self.scaleIO = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scaleIO(&mut self) -> &mut ScaleIOVolumeSource {
        if self.scaleIO.is_none() {
            self.scaleIO.set_default();
        }
        self.scaleIO.as_mut().unwrap()
    }

    // Take field
    pub fn take_scaleIO(&mut self) -> ScaleIOVolumeSource {
        self.scaleIO.take().unwrap_or_else(|| ScaleIOVolumeSource::new())
    }

    pub fn get_scaleIO(&self) -> &ScaleIOVolumeSource {
        self.scaleIO.as_ref().unwrap_or_else(|| ScaleIOVolumeSource::default_instance())
    }

    fn get_scaleIO_for_reflect(&self) -> &::protobuf::SingularPtrField<ScaleIOVolumeSource> {
        &self.scaleIO
    }

    fn mut_scaleIO_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ScaleIOVolumeSource> {
        &mut self.scaleIO
    }

    // optional .k8s.io.api.core.v1.LocalVolumeSource local = 20;

    pub fn clear_local(&mut self) {
        self.local.clear();
    }

    pub fn has_local(&self) -> bool {
        self.local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: LocalVolumeSource) {
        self.local = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local(&mut self) -> &mut LocalVolumeSource {
        if self.local.is_none() {
            self.local.set_default();
        }
        self.local.as_mut().unwrap()
    }

    // Take field
    pub fn take_local(&mut self) -> LocalVolumeSource {
        self.local.take().unwrap_or_else(|| LocalVolumeSource::new())
    }

    pub fn get_local(&self) -> &LocalVolumeSource {
        self.local.as_ref().unwrap_or_else(|| LocalVolumeSource::default_instance())
    }

    fn get_local_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalVolumeSource> {
        &self.local
    }

    fn mut_local_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalVolumeSource> {
        &mut self.local
    }

    // optional .k8s.io.api.core.v1.StorageOSPersistentVolumeSource storageos = 21;

    pub fn clear_storageos(&mut self) {
        self.storageos.clear();
    }

    pub fn has_storageos(&self) -> bool {
        self.storageos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageos(&mut self, v: StorageOSPersistentVolumeSource) {
        self.storageos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageos(&mut self) -> &mut StorageOSPersistentVolumeSource {
        if self.storageos.is_none() {
            self.storageos.set_default();
        }
        self.storageos.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageos(&mut self) -> StorageOSPersistentVolumeSource {
        self.storageos.take().unwrap_or_else(|| StorageOSPersistentVolumeSource::new())
    }

    pub fn get_storageos(&self) -> &StorageOSPersistentVolumeSource {
        self.storageos.as_ref().unwrap_or_else(|| StorageOSPersistentVolumeSource::default_instance())
    }

    fn get_storageos_for_reflect(&self) -> &::protobuf::SingularPtrField<StorageOSPersistentVolumeSource> {
        &self.storageos
    }

    fn mut_storageos_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<StorageOSPersistentVolumeSource> {
        &mut self.storageos
    }
}

impl ::protobuf::Message for PersistentVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.gcePersistentDisk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.awsElasticBlockStore {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hostPath {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.glusterfs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nfs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rbd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.iscsi {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cinder {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cephfs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flocker {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flexVolume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.azureFile {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vsphereVolume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quobyte {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.azureDisk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.photonPersistentDisk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.portworxVolume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scaleIO {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.local {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storageos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gcePersistentDisk)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.awsElasticBlockStore)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hostPath)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.glusterfs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nfs)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rbd)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iscsi)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cinder)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cephfs)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fc)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flocker)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flexVolume)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.azureFile)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vsphereVolume)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quobyte)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.azureDisk)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.photonPersistentDisk)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.portworxVolume)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scaleIO)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storageos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gcePersistentDisk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.awsElasticBlockStore.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hostPath.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.glusterfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rbd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.iscsi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cinder.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cephfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flocker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flexVolume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.azureFile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vsphereVolume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quobyte.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.azureDisk.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.photonPersistentDisk.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.portworxVolume.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scaleIO.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.local.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.storageos.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gcePersistentDisk.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.awsElasticBlockStore.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hostPath.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.glusterfs.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nfs.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rbd.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.iscsi.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cinder.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cephfs.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fc.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flocker.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flexVolume.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.azureFile.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vsphereVolume.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quobyte.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.azureDisk.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.photonPersistentDisk.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.portworxVolume.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scaleIO.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.local.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.storageos.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PersistentVolumeSource {
    fn new() -> PersistentVolumeSource {
        PersistentVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<PersistentVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GCEPersistentDiskVolumeSource>>(
                    "gcePersistentDisk",
                    PersistentVolumeSource::get_gcePersistentDisk_for_reflect,
                    PersistentVolumeSource::mut_gcePersistentDisk_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AWSElasticBlockStoreVolumeSource>>(
                    "awsElasticBlockStore",
                    PersistentVolumeSource::get_awsElasticBlockStore_for_reflect,
                    PersistentVolumeSource::mut_awsElasticBlockStore_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HostPathVolumeSource>>(
                    "hostPath",
                    PersistentVolumeSource::get_hostPath_for_reflect,
                    PersistentVolumeSource::mut_hostPath_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlusterfsVolumeSource>>(
                    "glusterfs",
                    PersistentVolumeSource::get_glusterfs_for_reflect,
                    PersistentVolumeSource::mut_glusterfs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NFSVolumeSource>>(
                    "nfs",
                    PersistentVolumeSource::get_nfs_for_reflect,
                    PersistentVolumeSource::mut_nfs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RBDVolumeSource>>(
                    "rbd",
                    PersistentVolumeSource::get_rbd_for_reflect,
                    PersistentVolumeSource::mut_rbd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ISCSIVolumeSource>>(
                    "iscsi",
                    PersistentVolumeSource::get_iscsi_for_reflect,
                    PersistentVolumeSource::mut_iscsi_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CinderVolumeSource>>(
                    "cinder",
                    PersistentVolumeSource::get_cinder_for_reflect,
                    PersistentVolumeSource::mut_cinder_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CephFSVolumeSource>>(
                    "cephfs",
                    PersistentVolumeSource::get_cephfs_for_reflect,
                    PersistentVolumeSource::mut_cephfs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FCVolumeSource>>(
                    "fc",
                    PersistentVolumeSource::get_fc_for_reflect,
                    PersistentVolumeSource::mut_fc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FlockerVolumeSource>>(
                    "flocker",
                    PersistentVolumeSource::get_flocker_for_reflect,
                    PersistentVolumeSource::mut_flocker_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FlexVolumeSource>>(
                    "flexVolume",
                    PersistentVolumeSource::get_flexVolume_for_reflect,
                    PersistentVolumeSource::mut_flexVolume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AzureFileVolumeSource>>(
                    "azureFile",
                    PersistentVolumeSource::get_azureFile_for_reflect,
                    PersistentVolumeSource::mut_azureFile_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VsphereVirtualDiskVolumeSource>>(
                    "vsphereVolume",
                    PersistentVolumeSource::get_vsphereVolume_for_reflect,
                    PersistentVolumeSource::mut_vsphereVolume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuobyteVolumeSource>>(
                    "quobyte",
                    PersistentVolumeSource::get_quobyte_for_reflect,
                    PersistentVolumeSource::mut_quobyte_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AzureDiskVolumeSource>>(
                    "azureDisk",
                    PersistentVolumeSource::get_azureDisk_for_reflect,
                    PersistentVolumeSource::mut_azureDisk_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PhotonPersistentDiskVolumeSource>>(
                    "photonPersistentDisk",
                    PersistentVolumeSource::get_photonPersistentDisk_for_reflect,
                    PersistentVolumeSource::mut_photonPersistentDisk_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortworxVolumeSource>>(
                    "portworxVolume",
                    PersistentVolumeSource::get_portworxVolume_for_reflect,
                    PersistentVolumeSource::mut_portworxVolume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScaleIOVolumeSource>>(
                    "scaleIO",
                    PersistentVolumeSource::get_scaleIO_for_reflect,
                    PersistentVolumeSource::mut_scaleIO_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalVolumeSource>>(
                    "local",
                    PersistentVolumeSource::get_local_for_reflect,
                    PersistentVolumeSource::mut_local_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageOSPersistentVolumeSource>>(
                    "storageos",
                    PersistentVolumeSource::get_storageos_for_reflect,
                    PersistentVolumeSource::mut_storageos_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentVolumeSource>(
                    "PersistentVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PersistentVolumeSource {
    fn clear(&mut self) {
        self.clear_gcePersistentDisk();
        self.clear_awsElasticBlockStore();
        self.clear_hostPath();
        self.clear_glusterfs();
        self.clear_nfs();
        self.clear_rbd();
        self.clear_iscsi();
        self.clear_cinder();
        self.clear_cephfs();
        self.clear_fc();
        self.clear_flocker();
        self.clear_flexVolume();
        self.clear_azureFile();
        self.clear_vsphereVolume();
        self.clear_quobyte();
        self.clear_azureDisk();
        self.clear_photonPersistentDisk();
        self.clear_portworxVolume();
        self.clear_scaleIO();
        self.clear_local();
        self.clear_storageos();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeSpec {
    // message fields
    pub capacity: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    persistentVolumeSource: ::protobuf::SingularPtrField<PersistentVolumeSource>,
    accessModes: ::protobuf::RepeatedField<::std::string::String>,
    claimRef: ::protobuf::SingularPtrField<ObjectReference>,
    persistentVolumeReclaimPolicy: ::protobuf::SingularField<::std::string::String>,
    storageClassName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PersistentVolumeSpec {}

impl PersistentVolumeSpec {
    pub fn new() -> PersistentVolumeSpec {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PersistentVolumeSpec {
        static mut instance: ::protobuf::lazy::Lazy<PersistentVolumeSpec> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentVolumeSpec,
        };
        unsafe {
            instance.get(PersistentVolumeSpec::new)
        }
    }

    // repeated .k8s.io.api.core.v1.PersistentVolumeSpec.CapacityEntry capacity = 1;

    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.capacity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capacity(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.capacity
    }

    // Take field
    pub fn take_capacity(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.capacity, ::std::collections::HashMap::new())
    }

    pub fn get_capacity(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.capacity
    }

    fn get_capacity_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.capacity
    }

    fn mut_capacity_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.capacity
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeSource persistentVolumeSource = 2;

    pub fn clear_persistentVolumeSource(&mut self) {
        self.persistentVolumeSource.clear();
    }

    pub fn has_persistentVolumeSource(&self) -> bool {
        self.persistentVolumeSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistentVolumeSource(&mut self, v: PersistentVolumeSource) {
        self.persistentVolumeSource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistentVolumeSource(&mut self) -> &mut PersistentVolumeSource {
        if self.persistentVolumeSource.is_none() {
            self.persistentVolumeSource.set_default();
        }
        self.persistentVolumeSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistentVolumeSource(&mut self) -> PersistentVolumeSource {
        self.persistentVolumeSource.take().unwrap_or_else(|| PersistentVolumeSource::new())
    }

    pub fn get_persistentVolumeSource(&self) -> &PersistentVolumeSource {
        self.persistentVolumeSource.as_ref().unwrap_or_else(|| PersistentVolumeSource::default_instance())
    }

    fn get_persistentVolumeSource_for_reflect(&self) -> &::protobuf::SingularPtrField<PersistentVolumeSource> {
        &self.persistentVolumeSource
    }

    fn mut_persistentVolumeSource_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PersistentVolumeSource> {
        &mut self.persistentVolumeSource
    }

    // repeated string accessModes = 3;

    pub fn clear_accessModes(&mut self) {
        self.accessModes.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessModes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accessModes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accessModes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accessModes
    }

    // Take field
    pub fn take_accessModes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.accessModes, ::protobuf::RepeatedField::new())
    }

    pub fn get_accessModes(&self) -> &[::std::string::String] {
        &self.accessModes
    }

    fn get_accessModes_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.accessModes
    }

    fn mut_accessModes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accessModes
    }

    // optional .k8s.io.api.core.v1.ObjectReference claimRef = 4;

    pub fn clear_claimRef(&mut self) {
        self.claimRef.clear();
    }

    pub fn has_claimRef(&self) -> bool {
        self.claimRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimRef(&mut self, v: ObjectReference) {
        self.claimRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_claimRef(&mut self) -> &mut ObjectReference {
        if self.claimRef.is_none() {
            self.claimRef.set_default();
        }
        self.claimRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_claimRef(&mut self) -> ObjectReference {
        self.claimRef.take().unwrap_or_else(|| ObjectReference::new())
    }

    pub fn get_claimRef(&self) -> &ObjectReference {
        self.claimRef.as_ref().unwrap_or_else(|| ObjectReference::default_instance())
    }

    fn get_claimRef_for_reflect(&self) -> &::protobuf::SingularPtrField<ObjectReference> {
        &self.claimRef
    }

    fn mut_claimRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ObjectReference> {
        &mut self.claimRef
    }

    // optional string persistentVolumeReclaimPolicy = 5;

    pub fn clear_persistentVolumeReclaimPolicy(&mut self) {
        self.persistentVolumeReclaimPolicy.clear();
    }

    pub fn has_persistentVolumeReclaimPolicy(&self) -> bool {
        self.persistentVolumeReclaimPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistentVolumeReclaimPolicy(&mut self, v: ::std::string::String) {
        self.persistentVolumeReclaimPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistentVolumeReclaimPolicy(&mut self) -> &mut ::std::string::String {
        if self.persistentVolumeReclaimPolicy.is_none() {
            self.persistentVolumeReclaimPolicy.set_default();
        }
        self.persistentVolumeReclaimPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistentVolumeReclaimPolicy(&mut self) -> ::std::string::String {
        self.persistentVolumeReclaimPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_persistentVolumeReclaimPolicy(&self) -> &str {
        match self.persistentVolumeReclaimPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_persistentVolumeReclaimPolicy_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.persistentVolumeReclaimPolicy
    }

    fn mut_persistentVolumeReclaimPolicy_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.persistentVolumeReclaimPolicy
    }

    // optional string storageClassName = 6;

    pub fn clear_storageClassName(&mut self) {
        self.storageClassName.clear();
    }

    pub fn has_storageClassName(&self) -> bool {
        self.storageClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageClassName(&mut self, v: ::std::string::String) {
        self.storageClassName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageClassName(&mut self) -> &mut ::std::string::String {
        if self.storageClassName.is_none() {
            self.storageClassName.set_default();
        }
        self.storageClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageClassName(&mut self) -> ::std::string::String {
        self.storageClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_storageClassName(&self) -> &str {
        match self.storageClassName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_storageClassName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.storageClassName
    }

    fn mut_storageClassName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.storageClassName
    }
}

impl ::protobuf::Message for PersistentVolumeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.persistentVolumeSource {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.claimRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.capacity)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.persistentVolumeSource)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.accessModes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.claimRef)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persistentVolumeReclaimPolicy)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageClassName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(1, &self.capacity);
        if let Some(ref v) = self.persistentVolumeSource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.accessModes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.claimRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.persistentVolumeReclaimPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.storageClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(1, &self.capacity, os)?;
        if let Some(ref v) = self.persistentVolumeSource.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.accessModes {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.claimRef.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.persistentVolumeReclaimPolicy.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.storageClassName.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PersistentVolumeSpec {
    fn new() -> PersistentVolumeSpec {
        PersistentVolumeSpec::new()
    }

    fn descriptor_static(_: ::std::option::Option<PersistentVolumeSpec>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "capacity",
                    PersistentVolumeSpec::get_capacity_for_reflect,
                    PersistentVolumeSpec::mut_capacity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeSource>>(
                    "persistentVolumeSource",
                    PersistentVolumeSpec::get_persistentVolumeSource_for_reflect,
                    PersistentVolumeSpec::mut_persistentVolumeSource_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "accessModes",
                    PersistentVolumeSpec::get_accessModes_for_reflect,
                    PersistentVolumeSpec::mut_accessModes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                    "claimRef",
                    PersistentVolumeSpec::get_claimRef_for_reflect,
                    PersistentVolumeSpec::mut_claimRef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "persistentVolumeReclaimPolicy",
                    PersistentVolumeSpec::get_persistentVolumeReclaimPolicy_for_reflect,
                    PersistentVolumeSpec::mut_persistentVolumeReclaimPolicy_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storageClassName",
                    PersistentVolumeSpec::get_storageClassName_for_reflect,
                    PersistentVolumeSpec::mut_storageClassName_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentVolumeSpec>(
                    "PersistentVolumeSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PersistentVolumeSpec {
    fn clear(&mut self) {
        self.clear_capacity();
        self.clear_persistentVolumeSource();
        self.clear_accessModes();
        self.clear_claimRef();
        self.clear_persistentVolumeReclaimPolicy();
        self.clear_storageClassName();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeStatus {
    // message fields
    phase: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    reason: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PersistentVolumeStatus {}

impl PersistentVolumeStatus {
    pub fn new() -> PersistentVolumeStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PersistentVolumeStatus {
        static mut instance: ::protobuf::lazy::Lazy<PersistentVolumeStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PersistentVolumeStatus,
        };
        unsafe {
            instance.get(PersistentVolumeStatus::new)
        }
    }

    // optional string phase = 1;

    pub fn clear_phase(&mut self) {
        self.phase.clear();
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase.set_default();
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_phase_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.phase
    }

    fn mut_phase_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.phase
    }

    // optional string message = 2;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // optional string reason = 3;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_reason_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.reason
    }
}

impl ::protobuf::Message for PersistentVolumeStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phase)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.phase.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PersistentVolumeStatus {
    fn new() -> PersistentVolumeStatus {
        PersistentVolumeStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<PersistentVolumeStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "phase",
                    PersistentVolumeStatus::get_phase_for_reflect,
                    PersistentVolumeStatus::mut_phase_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    PersistentVolumeStatus::get_message_for_reflect,
                    PersistentVolumeStatus::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reason",
                    PersistentVolumeStatus::get_reason_for_reflect,
                    PersistentVolumeStatus::mut_reason_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PersistentVolumeStatus>(
                    "PersistentVolumeStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PersistentVolumeStatus {
    fn clear(&mut self) {
        self.clear_phase();
        self.clear_message();
        self.clear_reason();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhotonPersistentDiskVolumeSource {
    // message fields
    pdID: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PhotonPersistentDiskVolumeSource {}

impl PhotonPersistentDiskVolumeSource {
    pub fn new() -> PhotonPersistentDiskVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PhotonPersistentDiskVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<PhotonPersistentDiskVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PhotonPersistentDiskVolumeSource,
        };
        unsafe {
            instance.get(PhotonPersistentDiskVolumeSource::new)
        }
    }

    // optional string pdID = 1;

    pub fn clear_pdID(&mut self) {
        self.pdID.clear();
    }

    pub fn has_pdID(&self) -> bool {
        self.pdID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pdID(&mut self, v: ::std::string::String) {
        self.pdID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pdID(&mut self) -> &mut ::std::string::String {
        if self.pdID.is_none() {
            self.pdID.set_default();
        }
        self.pdID.as_mut().unwrap()
    }

    // Take field
    pub fn take_pdID(&mut self) -> ::std::string::String {
        self.pdID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_pdID(&self) -> &str {
        match self.pdID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_pdID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.pdID
    }

    fn mut_pdID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.pdID
    }

    // optional string fsType = 2;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }
}

impl ::protobuf::Message for PhotonPersistentDiskVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pdID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pdID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pdID.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PhotonPersistentDiskVolumeSource {
    fn new() -> PhotonPersistentDiskVolumeSource {
        PhotonPersistentDiskVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<PhotonPersistentDiskVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pdID",
                    PhotonPersistentDiskVolumeSource::get_pdID_for_reflect,
                    PhotonPersistentDiskVolumeSource::mut_pdID_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    PhotonPersistentDiskVolumeSource::get_fsType_for_reflect,
                    PhotonPersistentDiskVolumeSource::mut_fsType_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PhotonPersistentDiskVolumeSource>(
                    "PhotonPersistentDiskVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PhotonPersistentDiskVolumeSource {
    fn clear(&mut self) {
        self.clear_pdID();
        self.clear_fsType();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhotonPersistentDiskVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhotonPersistentDiskVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pod {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    spec: ::protobuf::SingularPtrField<PodSpec>,
    status: ::protobuf::SingularPtrField<PodStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Pod {}

impl Pod {
    pub fn new() -> Pod {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Pod {
        static mut instance: ::protobuf::lazy::Lazy<Pod> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Pod,
        };
        unsafe {
            instance.get(Pod::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.PodSpec spec = 2;

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PodSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PodSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> PodSpec {
        self.spec.take().unwrap_or_else(|| PodSpec::new())
    }

    pub fn get_spec(&self) -> &PodSpec {
        self.spec.as_ref().unwrap_or_else(|| PodSpec::default_instance())
    }

    fn get_spec_for_reflect(&self) -> &::protobuf::SingularPtrField<PodSpec> {
        &self.spec
    }

    fn mut_spec_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PodSpec> {
        &mut self.spec
    }

    // optional .k8s.io.api.core.v1.PodStatus status = 3;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PodStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PodStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> PodStatus {
        self.status.take().unwrap_or_else(|| PodStatus::new())
    }

    pub fn get_status(&self) -> &PodStatus {
        self.status.as_ref().unwrap_or_else(|| PodStatus::default_instance())
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularPtrField<PodStatus> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PodStatus> {
        &mut self.status
    }
}

impl ::protobuf::Message for Pod {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Pod {
    fn new() -> Pod {
        Pod::new()
    }

    fn descriptor_static(_: ::std::option::Option<Pod>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    Pod::get_metadata_for_reflect,
                    Pod::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSpec>>(
                    "spec",
                    Pod::get_spec_for_reflect,
                    Pod::mut_spec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodStatus>>(
                    "status",
                    Pod::get_status_for_reflect,
                    Pod::mut_status_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Pod>(
                    "Pod",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Pod {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_spec();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pod {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodAffinity {
    // message fields
    requiredDuringSchedulingIgnoredDuringExecution: ::protobuf::RepeatedField<PodAffinityTerm>,
    preferredDuringSchedulingIgnoredDuringExecution: ::protobuf::RepeatedField<WeightedPodAffinityTerm>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodAffinity {}

impl PodAffinity {
    pub fn new() -> PodAffinity {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodAffinity {
        static mut instance: ::protobuf::lazy::Lazy<PodAffinity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodAffinity,
        };
        unsafe {
            instance.get(PodAffinity::new)
        }
    }

    // repeated .k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;

    pub fn clear_requiredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_requiredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::protobuf::RepeatedField<PodAffinityTerm>) {
        self.requiredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::protobuf::RepeatedField<PodAffinityTerm> {
        &mut self.requiredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::protobuf::RepeatedField<PodAffinityTerm> {
        ::std::mem::replace(&mut self.requiredDuringSchedulingIgnoredDuringExecution, ::protobuf::RepeatedField::new())
    }

    pub fn get_requiredDuringSchedulingIgnoredDuringExecution(&self) -> &[PodAffinityTerm] {
        &self.requiredDuringSchedulingIgnoredDuringExecution
    }

    fn get_requiredDuringSchedulingIgnoredDuringExecution_for_reflect(&self) -> &::protobuf::RepeatedField<PodAffinityTerm> {
        &self.requiredDuringSchedulingIgnoredDuringExecution
    }

    fn mut_requiredDuringSchedulingIgnoredDuringExecution_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<PodAffinityTerm> {
        &mut self.requiredDuringSchedulingIgnoredDuringExecution
    }

    // repeated .k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;

    pub fn clear_preferredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::protobuf::RepeatedField<WeightedPodAffinityTerm>) {
        self.preferredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::protobuf::RepeatedField<WeightedPodAffinityTerm> {
        &mut self.preferredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::protobuf::RepeatedField<WeightedPodAffinityTerm> {
        ::std::mem::replace(&mut self.preferredDuringSchedulingIgnoredDuringExecution, ::protobuf::RepeatedField::new())
    }

    pub fn get_preferredDuringSchedulingIgnoredDuringExecution(&self) -> &[WeightedPodAffinityTerm] {
        &self.preferredDuringSchedulingIgnoredDuringExecution
    }

    fn get_preferredDuringSchedulingIgnoredDuringExecution_for_reflect(&self) -> &::protobuf::RepeatedField<WeightedPodAffinityTerm> {
        &self.preferredDuringSchedulingIgnoredDuringExecution
    }

    fn mut_preferredDuringSchedulingIgnoredDuringExecution_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<WeightedPodAffinityTerm> {
        &mut self.preferredDuringSchedulingIgnoredDuringExecution
    }
}

impl ::protobuf::Message for PodAffinity {
    fn is_initialized(&self) -> bool {
        for v in &self.requiredDuringSchedulingIgnoredDuringExecution {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requiredDuringSchedulingIgnoredDuringExecution)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preferredDuringSchedulingIgnoredDuringExecution)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.requiredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.preferredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.requiredDuringSchedulingIgnoredDuringExecution {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodAffinity {
    fn new() -> PodAffinity {
        PodAffinity::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodAffinity>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodAffinityTerm>>(
                    "requiredDuringSchedulingIgnoredDuringExecution",
                    PodAffinity::get_requiredDuringSchedulingIgnoredDuringExecution_for_reflect,
                    PodAffinity::mut_requiredDuringSchedulingIgnoredDuringExecution_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WeightedPodAffinityTerm>>(
                    "preferredDuringSchedulingIgnoredDuringExecution",
                    PodAffinity::get_preferredDuringSchedulingIgnoredDuringExecution_for_reflect,
                    PodAffinity::mut_preferredDuringSchedulingIgnoredDuringExecution_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodAffinity>(
                    "PodAffinity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodAffinity {
    fn clear(&mut self) {
        self.clear_requiredDuringSchedulingIgnoredDuringExecution();
        self.clear_preferredDuringSchedulingIgnoredDuringExecution();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodAffinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodAffinity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodAffinityTerm {
    // message fields
    labelSelector: ::protobuf::SingularPtrField<super::generated::LabelSelector>,
    namespaces: ::protobuf::RepeatedField<::std::string::String>,
    topologyKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodAffinityTerm {}

impl PodAffinityTerm {
    pub fn new() -> PodAffinityTerm {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodAffinityTerm {
        static mut instance: ::protobuf::lazy::Lazy<PodAffinityTerm> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodAffinityTerm,
        };
        unsafe {
            instance.get(PodAffinityTerm::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 1;

    pub fn clear_labelSelector(&mut self) {
        self.labelSelector.clear();
    }

    pub fn has_labelSelector(&self) -> bool {
        self.labelSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelSelector(&mut self, v: super::generated::LabelSelector) {
        self.labelSelector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelSelector(&mut self) -> &mut super::generated::LabelSelector {
        if self.labelSelector.is_none() {
            self.labelSelector.set_default();
        }
        self.labelSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_labelSelector(&mut self) -> super::generated::LabelSelector {
        self.labelSelector.take().unwrap_or_else(|| super::generated::LabelSelector::new())
    }

    pub fn get_labelSelector(&self) -> &super::generated::LabelSelector {
        self.labelSelector.as_ref().unwrap_or_else(|| super::generated::LabelSelector::default_instance())
    }

    fn get_labelSelector_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::LabelSelector> {
        &self.labelSelector
    }

    fn mut_labelSelector_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::LabelSelector> {
        &mut self.labelSelector
    }

    // repeated string namespaces = 2;

    pub fn clear_namespaces(&mut self) {
        self.namespaces.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespaces(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.namespaces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_namespaces(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.namespaces
    }

    // Take field
    pub fn take_namespaces(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.namespaces, ::protobuf::RepeatedField::new())
    }

    pub fn get_namespaces(&self) -> &[::std::string::String] {
        &self.namespaces
    }

    fn get_namespaces_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.namespaces
    }

    fn mut_namespaces_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.namespaces
    }

    // optional string topologyKey = 3;

    pub fn clear_topologyKey(&mut self) {
        self.topologyKey.clear();
    }

    pub fn has_topologyKey(&self) -> bool {
        self.topologyKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topologyKey(&mut self, v: ::std::string::String) {
        self.topologyKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topologyKey(&mut self) -> &mut ::std::string::String {
        if self.topologyKey.is_none() {
            self.topologyKey.set_default();
        }
        self.topologyKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_topologyKey(&mut self) -> ::std::string::String {
        self.topologyKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_topologyKey(&self) -> &str {
        match self.topologyKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_topologyKey_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.topologyKey
    }

    fn mut_topologyKey_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.topologyKey
    }
}

impl ::protobuf::Message for PodAffinityTerm {
    fn is_initialized(&self) -> bool {
        for v in &self.labelSelector {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labelSelector)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.namespaces)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topologyKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.labelSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.namespaces {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.topologyKey.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.labelSelector.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.namespaces {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.topologyKey.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodAffinityTerm {
    fn new() -> PodAffinityTerm {
        PodAffinityTerm::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodAffinityTerm>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::LabelSelector>>(
                    "labelSelector",
                    PodAffinityTerm::get_labelSelector_for_reflect,
                    PodAffinityTerm::mut_labelSelector_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "namespaces",
                    PodAffinityTerm::get_namespaces_for_reflect,
                    PodAffinityTerm::mut_namespaces_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topologyKey",
                    PodAffinityTerm::get_topologyKey_for_reflect,
                    PodAffinityTerm::mut_topologyKey_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodAffinityTerm>(
                    "PodAffinityTerm",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodAffinityTerm {
    fn clear(&mut self) {
        self.clear_labelSelector();
        self.clear_namespaces();
        self.clear_topologyKey();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodAffinityTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodAffinityTerm {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodAntiAffinity {
    // message fields
    requiredDuringSchedulingIgnoredDuringExecution: ::protobuf::RepeatedField<PodAffinityTerm>,
    preferredDuringSchedulingIgnoredDuringExecution: ::protobuf::RepeatedField<WeightedPodAffinityTerm>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodAntiAffinity {}

impl PodAntiAffinity {
    pub fn new() -> PodAntiAffinity {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodAntiAffinity {
        static mut instance: ::protobuf::lazy::Lazy<PodAntiAffinity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodAntiAffinity,
        };
        unsafe {
            instance.get(PodAntiAffinity::new)
        }
    }

    // repeated .k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;

    pub fn clear_requiredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_requiredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::protobuf::RepeatedField<PodAffinityTerm>) {
        self.requiredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::protobuf::RepeatedField<PodAffinityTerm> {
        &mut self.requiredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::protobuf::RepeatedField<PodAffinityTerm> {
        ::std::mem::replace(&mut self.requiredDuringSchedulingIgnoredDuringExecution, ::protobuf::RepeatedField::new())
    }

    pub fn get_requiredDuringSchedulingIgnoredDuringExecution(&self) -> &[PodAffinityTerm] {
        &self.requiredDuringSchedulingIgnoredDuringExecution
    }

    fn get_requiredDuringSchedulingIgnoredDuringExecution_for_reflect(&self) -> &::protobuf::RepeatedField<PodAffinityTerm> {
        &self.requiredDuringSchedulingIgnoredDuringExecution
    }

    fn mut_requiredDuringSchedulingIgnoredDuringExecution_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<PodAffinityTerm> {
        &mut self.requiredDuringSchedulingIgnoredDuringExecution
    }

    // repeated .k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;

    pub fn clear_preferredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::protobuf::RepeatedField<WeightedPodAffinityTerm>) {
        self.preferredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::protobuf::RepeatedField<WeightedPodAffinityTerm> {
        &mut self.preferredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::protobuf::RepeatedField<WeightedPodAffinityTerm> {
        ::std::mem::replace(&mut self.preferredDuringSchedulingIgnoredDuringExecution, ::protobuf::RepeatedField::new())
    }

    pub fn get_preferredDuringSchedulingIgnoredDuringExecution(&self) -> &[WeightedPodAffinityTerm] {
        &self.preferredDuringSchedulingIgnoredDuringExecution
    }

    fn get_preferredDuringSchedulingIgnoredDuringExecution_for_reflect(&self) -> &::protobuf::RepeatedField<WeightedPodAffinityTerm> {
        &self.preferredDuringSchedulingIgnoredDuringExecution
    }

    fn mut_preferredDuringSchedulingIgnoredDuringExecution_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<WeightedPodAffinityTerm> {
        &mut self.preferredDuringSchedulingIgnoredDuringExecution
    }
}

impl ::protobuf::Message for PodAntiAffinity {
    fn is_initialized(&self) -> bool {
        for v in &self.requiredDuringSchedulingIgnoredDuringExecution {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requiredDuringSchedulingIgnoredDuringExecution)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preferredDuringSchedulingIgnoredDuringExecution)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.requiredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.preferredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.requiredDuringSchedulingIgnoredDuringExecution {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodAntiAffinity {
    fn new() -> PodAntiAffinity {
        PodAntiAffinity::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodAntiAffinity>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodAffinityTerm>>(
                    "requiredDuringSchedulingIgnoredDuringExecution",
                    PodAntiAffinity::get_requiredDuringSchedulingIgnoredDuringExecution_for_reflect,
                    PodAntiAffinity::mut_requiredDuringSchedulingIgnoredDuringExecution_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WeightedPodAffinityTerm>>(
                    "preferredDuringSchedulingIgnoredDuringExecution",
                    PodAntiAffinity::get_preferredDuringSchedulingIgnoredDuringExecution_for_reflect,
                    PodAntiAffinity::mut_preferredDuringSchedulingIgnoredDuringExecution_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodAntiAffinity>(
                    "PodAntiAffinity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodAntiAffinity {
    fn clear(&mut self) {
        self.clear_requiredDuringSchedulingIgnoredDuringExecution();
        self.clear_preferredDuringSchedulingIgnoredDuringExecution();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodAntiAffinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodAntiAffinity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodAttachOptions {
    // message fields
    stdin: ::std::option::Option<bool>,
    stdout: ::std::option::Option<bool>,
    stderr: ::std::option::Option<bool>,
    tty: ::std::option::Option<bool>,
    container: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodAttachOptions {}

impl PodAttachOptions {
    pub fn new() -> PodAttachOptions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodAttachOptions {
        static mut instance: ::protobuf::lazy::Lazy<PodAttachOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodAttachOptions,
        };
        unsafe {
            instance.get(PodAttachOptions::new)
        }
    }

    // optional bool stdin = 1;

    pub fn clear_stdin(&mut self) {
        self.stdin = ::std::option::Option::None;
    }

    pub fn has_stdin(&self) -> bool {
        self.stdin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = ::std::option::Option::Some(v);
    }

    pub fn get_stdin(&self) -> bool {
        self.stdin.unwrap_or(false)
    }

    fn get_stdin_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.stdin
    }

    fn mut_stdin_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.stdin
    }

    // optional bool stdout = 2;

    pub fn clear_stdout(&mut self) {
        self.stdout = ::std::option::Option::None;
    }

    pub fn has_stdout(&self) -> bool {
        self.stdout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: bool) {
        self.stdout = ::std::option::Option::Some(v);
    }

    pub fn get_stdout(&self) -> bool {
        self.stdout.unwrap_or(false)
    }

    fn get_stdout_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.stdout
    }

    fn mut_stdout_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.stdout
    }

    // optional bool stderr = 3;

    pub fn clear_stderr(&mut self) {
        self.stderr = ::std::option::Option::None;
    }

    pub fn has_stderr(&self) -> bool {
        self.stderr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: bool) {
        self.stderr = ::std::option::Option::Some(v);
    }

    pub fn get_stderr(&self) -> bool {
        self.stderr.unwrap_or(false)
    }

    fn get_stderr_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.stderr
    }

    fn mut_stderr_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.stderr
    }

    // optional bool tty = 4;

    pub fn clear_tty(&mut self) {
        self.tty = ::std::option::Option::None;
    }

    pub fn has_tty(&self) -> bool {
        self.tty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = ::std::option::Option::Some(v);
    }

    pub fn get_tty(&self) -> bool {
        self.tty.unwrap_or(false)
    }

    fn get_tty_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.tty
    }

    fn mut_tty_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.tty
    }

    // optional string container = 5;

    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ::std::string::String) {
        self.container = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut ::std::string::String {
        if self.container.is_none() {
            self.container.set_default();
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ::std::string::String {
        self.container.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_container(&self) -> &str {
        match self.container.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_container_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.container
    }

    fn mut_container_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.container
    }
}

impl ::protobuf::Message for PodAttachOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdin = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdout = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stderr = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tty = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.container)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stdin {
            my_size += 2;
        }
        if let Some(v) = self.stdout {
            my_size += 2;
        }
        if let Some(v) = self.stderr {
            my_size += 2;
        }
        if let Some(v) = self.tty {
            my_size += 2;
        }
        if let Some(ref v) = self.container.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stdin {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.stdout {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.stderr {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.tty {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.container.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodAttachOptions {
    fn new() -> PodAttachOptions {
        PodAttachOptions::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodAttachOptions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "stdin",
                    PodAttachOptions::get_stdin_for_reflect,
                    PodAttachOptions::mut_stdin_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "stdout",
                    PodAttachOptions::get_stdout_for_reflect,
                    PodAttachOptions::mut_stdout_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "stderr",
                    PodAttachOptions::get_stderr_for_reflect,
                    PodAttachOptions::mut_stderr_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "tty",
                    PodAttachOptions::get_tty_for_reflect,
                    PodAttachOptions::mut_tty_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container",
                    PodAttachOptions::get_container_for_reflect,
                    PodAttachOptions::mut_container_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodAttachOptions>(
                    "PodAttachOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodAttachOptions {
    fn clear(&mut self) {
        self.clear_stdin();
        self.clear_stdout();
        self.clear_stderr();
        self.clear_tty();
        self.clear_container();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodAttachOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodAttachOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodCondition {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    status: ::protobuf::SingularField<::std::string::String>,
    lastProbeTime: ::protobuf::SingularPtrField<super::generated::Time>,
    lastTransitionTime: ::protobuf::SingularPtrField<super::generated::Time>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodCondition {}

impl PodCondition {
    pub fn new() -> PodCondition {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodCondition {
        static mut instance: ::protobuf::lazy::Lazy<PodCondition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodCondition,
        };
        unsafe {
            instance.get(PodCondition::new)
        }
    }

    // optional string type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_field_type_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.field_type
    }

    // optional string status = 2;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.status
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;

    pub fn clear_lastProbeTime(&mut self) {
        self.lastProbeTime.clear();
    }

    pub fn has_lastProbeTime(&self) -> bool {
        self.lastProbeTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastProbeTime(&mut self, v: super::generated::Time) {
        self.lastProbeTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastProbeTime(&mut self) -> &mut super::generated::Time {
        if self.lastProbeTime.is_none() {
            self.lastProbeTime.set_default();
        }
        self.lastProbeTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastProbeTime(&mut self) -> super::generated::Time {
        self.lastProbeTime.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_lastProbeTime(&self) -> &super::generated::Time {
        self.lastProbeTime.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_lastProbeTime_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.lastProbeTime
    }

    fn mut_lastProbeTime_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.lastProbeTime
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: super::generated::Time) {
        self.lastTransitionTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut super::generated::Time {
        if self.lastTransitionTime.is_none() {
            self.lastTransitionTime.set_default();
        }
        self.lastTransitionTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> super::generated::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_lastTransitionTime(&self) -> &super::generated::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_lastTransitionTime_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.lastTransitionTime
    }

    fn mut_lastTransitionTime_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.lastTransitionTime
    }

    // optional string reason = 5;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_reason_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.reason
    }

    // optional string message = 6;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }
}

impl ::protobuf::Message for PodCondition {
    fn is_initialized(&self) -> bool {
        for v in &self.lastProbeTime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lastTransitionTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastProbeTime)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastTransitionTime)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.lastProbeTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.lastProbeTime.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodCondition {
    fn new() -> PodCondition {
        PodCondition::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodCondition>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    PodCondition::get_field_type_for_reflect,
                    PodCondition::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "status",
                    PodCondition::get_status_for_reflect,
                    PodCondition::mut_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "lastProbeTime",
                    PodCondition::get_lastProbeTime_for_reflect,
                    PodCondition::mut_lastProbeTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "lastTransitionTime",
                    PodCondition::get_lastTransitionTime_for_reflect,
                    PodCondition::mut_lastTransitionTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reason",
                    PodCondition::get_reason_for_reflect,
                    PodCondition::mut_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    PodCondition::get_message_for_reflect,
                    PodCondition::mut_message_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodCondition>(
                    "PodCondition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodCondition {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_status();
        self.clear_lastProbeTime();
        self.clear_lastTransitionTime();
        self.clear_reason();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodExecOptions {
    // message fields
    stdin: ::std::option::Option<bool>,
    stdout: ::std::option::Option<bool>,
    stderr: ::std::option::Option<bool>,
    tty: ::std::option::Option<bool>,
    container: ::protobuf::SingularField<::std::string::String>,
    command: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodExecOptions {}

impl PodExecOptions {
    pub fn new() -> PodExecOptions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodExecOptions {
        static mut instance: ::protobuf::lazy::Lazy<PodExecOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodExecOptions,
        };
        unsafe {
            instance.get(PodExecOptions::new)
        }
    }

    // optional bool stdin = 1;

    pub fn clear_stdin(&mut self) {
        self.stdin = ::std::option::Option::None;
    }

    pub fn has_stdin(&self) -> bool {
        self.stdin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = ::std::option::Option::Some(v);
    }

    pub fn get_stdin(&self) -> bool {
        self.stdin.unwrap_or(false)
    }

    fn get_stdin_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.stdin
    }

    fn mut_stdin_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.stdin
    }

    // optional bool stdout = 2;

    pub fn clear_stdout(&mut self) {
        self.stdout = ::std::option::Option::None;
    }

    pub fn has_stdout(&self) -> bool {
        self.stdout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: bool) {
        self.stdout = ::std::option::Option::Some(v);
    }

    pub fn get_stdout(&self) -> bool {
        self.stdout.unwrap_or(false)
    }

    fn get_stdout_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.stdout
    }

    fn mut_stdout_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.stdout
    }

    // optional bool stderr = 3;

    pub fn clear_stderr(&mut self) {
        self.stderr = ::std::option::Option::None;
    }

    pub fn has_stderr(&self) -> bool {
        self.stderr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: bool) {
        self.stderr = ::std::option::Option::Some(v);
    }

    pub fn get_stderr(&self) -> bool {
        self.stderr.unwrap_or(false)
    }

    fn get_stderr_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.stderr
    }

    fn mut_stderr_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.stderr
    }

    // optional bool tty = 4;

    pub fn clear_tty(&mut self) {
        self.tty = ::std::option::Option::None;
    }

    pub fn has_tty(&self) -> bool {
        self.tty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = ::std::option::Option::Some(v);
    }

    pub fn get_tty(&self) -> bool {
        self.tty.unwrap_or(false)
    }

    fn get_tty_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.tty
    }

    fn mut_tty_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.tty
    }

    // optional string container = 5;

    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ::std::string::String) {
        self.container = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut ::std::string::String {
        if self.container.is_none() {
            self.container.set_default();
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ::std::string::String {
        self.container.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_container(&self) -> &str {
        match self.container.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_container_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.container
    }

    fn mut_container_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.container
    }

    // repeated string command = 6;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    pub fn get_command(&self) -> &[::std::string::String] {
        &self.command
    }

    fn get_command_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.command
    }

    fn mut_command_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }
}

impl ::protobuf::Message for PodExecOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdin = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdout = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stderr = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tty = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.container)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.command)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stdin {
            my_size += 2;
        }
        if let Some(v) = self.stdout {
            my_size += 2;
        }
        if let Some(v) = self.stderr {
            my_size += 2;
        }
        if let Some(v) = self.tty {
            my_size += 2;
        }
        if let Some(ref v) = self.container.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stdin {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.stdout {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.stderr {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.tty {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.container.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.command {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodExecOptions {
    fn new() -> PodExecOptions {
        PodExecOptions::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodExecOptions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "stdin",
                    PodExecOptions::get_stdin_for_reflect,
                    PodExecOptions::mut_stdin_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "stdout",
                    PodExecOptions::get_stdout_for_reflect,
                    PodExecOptions::mut_stdout_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "stderr",
                    PodExecOptions::get_stderr_for_reflect,
                    PodExecOptions::mut_stderr_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "tty",
                    PodExecOptions::get_tty_for_reflect,
                    PodExecOptions::mut_tty_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container",
                    PodExecOptions::get_container_for_reflect,
                    PodExecOptions::mut_container_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "command",
                    PodExecOptions::get_command_for_reflect,
                    PodExecOptions::mut_command_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodExecOptions>(
                    "PodExecOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodExecOptions {
    fn clear(&mut self) {
        self.clear_stdin();
        self.clear_stdout();
        self.clear_stderr();
        self.clear_tty();
        self.clear_container();
        self.clear_command();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodExecOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodExecOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<Pod>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodList {}

impl PodList {
    pub fn new() -> PodList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodList {
        static mut instance: ::protobuf::lazy::Lazy<PodList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodList,
        };
        unsafe {
            instance.get(PodList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.Pod items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Pod>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Pod> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Pod> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[Pod] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<Pod> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Pod> {
        &mut self.items
    }
}

impl ::protobuf::Message for PodList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodList {
    fn new() -> PodList {
        PodList::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    PodList::get_metadata_for_reflect,
                    PodList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pod>>(
                    "items",
                    PodList::get_items_for_reflect,
                    PodList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodList>(
                    "PodList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodLogOptions {
    // message fields
    container: ::protobuf::SingularField<::std::string::String>,
    follow: ::std::option::Option<bool>,
    previous: ::std::option::Option<bool>,
    sinceSeconds: ::std::option::Option<i64>,
    sinceTime: ::protobuf::SingularPtrField<super::generated::Time>,
    timestamps: ::std::option::Option<bool>,
    tailLines: ::std::option::Option<i64>,
    limitBytes: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodLogOptions {}

impl PodLogOptions {
    pub fn new() -> PodLogOptions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodLogOptions {
        static mut instance: ::protobuf::lazy::Lazy<PodLogOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodLogOptions,
        };
        unsafe {
            instance.get(PodLogOptions::new)
        }
    }

    // optional string container = 1;

    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ::std::string::String) {
        self.container = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut ::std::string::String {
        if self.container.is_none() {
            self.container.set_default();
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ::std::string::String {
        self.container.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_container(&self) -> &str {
        match self.container.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_container_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.container
    }

    fn mut_container_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.container
    }

    // optional bool follow = 2;

    pub fn clear_follow(&mut self) {
        self.follow = ::std::option::Option::None;
    }

    pub fn has_follow(&self) -> bool {
        self.follow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_follow(&mut self, v: bool) {
        self.follow = ::std::option::Option::Some(v);
    }

    pub fn get_follow(&self) -> bool {
        self.follow.unwrap_or(false)
    }

    fn get_follow_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.follow
    }

    fn mut_follow_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.follow
    }

    // optional bool previous = 3;

    pub fn clear_previous(&mut self) {
        self.previous = ::std::option::Option::None;
    }

    pub fn has_previous(&self) -> bool {
        self.previous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous(&mut self, v: bool) {
        self.previous = ::std::option::Option::Some(v);
    }

    pub fn get_previous(&self) -> bool {
        self.previous.unwrap_or(false)
    }

    fn get_previous_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.previous
    }

    fn mut_previous_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.previous
    }

    // optional int64 sinceSeconds = 4;

    pub fn clear_sinceSeconds(&mut self) {
        self.sinceSeconds = ::std::option::Option::None;
    }

    pub fn has_sinceSeconds(&self) -> bool {
        self.sinceSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sinceSeconds(&mut self, v: i64) {
        self.sinceSeconds = ::std::option::Option::Some(v);
    }

    pub fn get_sinceSeconds(&self) -> i64 {
        self.sinceSeconds.unwrap_or(0)
    }

    fn get_sinceSeconds_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.sinceSeconds
    }

    fn mut_sinceSeconds_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.sinceSeconds
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time sinceTime = 5;

    pub fn clear_sinceTime(&mut self) {
        self.sinceTime.clear();
    }

    pub fn has_sinceTime(&self) -> bool {
        self.sinceTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sinceTime(&mut self, v: super::generated::Time) {
        self.sinceTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sinceTime(&mut self) -> &mut super::generated::Time {
        if self.sinceTime.is_none() {
            self.sinceTime.set_default();
        }
        self.sinceTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_sinceTime(&mut self) -> super::generated::Time {
        self.sinceTime.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_sinceTime(&self) -> &super::generated::Time {
        self.sinceTime.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_sinceTime_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.sinceTime
    }

    fn mut_sinceTime_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.sinceTime
    }

    // optional bool timestamps = 6;

    pub fn clear_timestamps(&mut self) {
        self.timestamps = ::std::option::Option::None;
    }

    pub fn has_timestamps(&self) -> bool {
        self.timestamps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamps(&mut self, v: bool) {
        self.timestamps = ::std::option::Option::Some(v);
    }

    pub fn get_timestamps(&self) -> bool {
        self.timestamps.unwrap_or(false)
    }

    fn get_timestamps_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.timestamps
    }

    fn mut_timestamps_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.timestamps
    }

    // optional int64 tailLines = 7;

    pub fn clear_tailLines(&mut self) {
        self.tailLines = ::std::option::Option::None;
    }

    pub fn has_tailLines(&self) -> bool {
        self.tailLines.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tailLines(&mut self, v: i64) {
        self.tailLines = ::std::option::Option::Some(v);
    }

    pub fn get_tailLines(&self) -> i64 {
        self.tailLines.unwrap_or(0)
    }

    fn get_tailLines_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.tailLines
    }

    fn mut_tailLines_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.tailLines
    }

    // optional int64 limitBytes = 8;

    pub fn clear_limitBytes(&mut self) {
        self.limitBytes = ::std::option::Option::None;
    }

    pub fn has_limitBytes(&self) -> bool {
        self.limitBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limitBytes(&mut self, v: i64) {
        self.limitBytes = ::std::option::Option::Some(v);
    }

    pub fn get_limitBytes(&self) -> i64 {
        self.limitBytes.unwrap_or(0)
    }

    fn get_limitBytes_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.limitBytes
    }

    fn mut_limitBytes_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.limitBytes
    }
}

impl ::protobuf::Message for PodLogOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.sinceTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.container)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.follow = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.previous = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sinceSeconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sinceTime)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.timestamps = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tailLines = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limitBytes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.container.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.follow {
            my_size += 2;
        }
        if let Some(v) = self.previous {
            my_size += 2;
        }
        if let Some(v) = self.sinceSeconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sinceTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.timestamps {
            my_size += 2;
        }
        if let Some(v) = self.tailLines {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.limitBytes {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.container.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.follow {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.previous {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.sinceSeconds {
            os.write_int64(4, v)?;
        }
        if let Some(ref v) = self.sinceTime.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.timestamps {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.tailLines {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.limitBytes {
            os.write_int64(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodLogOptions {
    fn new() -> PodLogOptions {
        PodLogOptions::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodLogOptions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "container",
                    PodLogOptions::get_container_for_reflect,
                    PodLogOptions::mut_container_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "follow",
                    PodLogOptions::get_follow_for_reflect,
                    PodLogOptions::mut_follow_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "previous",
                    PodLogOptions::get_previous_for_reflect,
                    PodLogOptions::mut_previous_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sinceSeconds",
                    PodLogOptions::get_sinceSeconds_for_reflect,
                    PodLogOptions::mut_sinceSeconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "sinceTime",
                    PodLogOptions::get_sinceTime_for_reflect,
                    PodLogOptions::mut_sinceTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "timestamps",
                    PodLogOptions::get_timestamps_for_reflect,
                    PodLogOptions::mut_timestamps_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "tailLines",
                    PodLogOptions::get_tailLines_for_reflect,
                    PodLogOptions::mut_tailLines_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limitBytes",
                    PodLogOptions::get_limitBytes_for_reflect,
                    PodLogOptions::mut_limitBytes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodLogOptions>(
                    "PodLogOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodLogOptions {
    fn clear(&mut self) {
        self.clear_container();
        self.clear_follow();
        self.clear_previous();
        self.clear_sinceSeconds();
        self.clear_sinceTime();
        self.clear_timestamps();
        self.clear_tailLines();
        self.clear_limitBytes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodLogOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodLogOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodPortForwardOptions {
    // message fields
    ports: ::std::vec::Vec<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodPortForwardOptions {}

impl PodPortForwardOptions {
    pub fn new() -> PodPortForwardOptions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodPortForwardOptions {
        static mut instance: ::protobuf::lazy::Lazy<PodPortForwardOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodPortForwardOptions,
        };
        unsafe {
            instance.get(PodPortForwardOptions::new)
        }
    }

    // repeated int32 ports = 1;

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<i32>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }

    pub fn get_ports(&self) -> &[i32] {
        &self.ports
    }

    fn get_ports_for_reflect(&self) -> &::std::vec::Vec<i32> {
        &self.ports
    }

    fn mut_ports_for_reflect(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.ports
    }
}

impl ::protobuf::Message for PodPortForwardOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.ports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ports {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ports {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodPortForwardOptions {
    fn new() -> PodPortForwardOptions {
        PodPortForwardOptions::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodPortForwardOptions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ports",
                    PodPortForwardOptions::get_ports_for_reflect,
                    PodPortForwardOptions::mut_ports_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodPortForwardOptions>(
                    "PodPortForwardOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodPortForwardOptions {
    fn clear(&mut self) {
        self.clear_ports();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodPortForwardOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodPortForwardOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodProxyOptions {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodProxyOptions {}

impl PodProxyOptions {
    pub fn new() -> PodProxyOptions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodProxyOptions {
        static mut instance: ::protobuf::lazy::Lazy<PodProxyOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodProxyOptions,
        };
        unsafe {
            instance.get(PodProxyOptions::new)
        }
    }

    // optional string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }
}

impl ::protobuf::Message for PodProxyOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodProxyOptions {
    fn new() -> PodProxyOptions {
        PodProxyOptions::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodProxyOptions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    PodProxyOptions::get_path_for_reflect,
                    PodProxyOptions::mut_path_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodProxyOptions>(
                    "PodProxyOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodProxyOptions {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodProxyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodProxyOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSecurityContext {
    // message fields
    seLinuxOptions: ::protobuf::SingularPtrField<SELinuxOptions>,
    runAsUser: ::std::option::Option<i64>,
    runAsNonRoot: ::std::option::Option<bool>,
    supplementalGroups: ::std::vec::Vec<i64>,
    fsGroup: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodSecurityContext {}

impl PodSecurityContext {
    pub fn new() -> PodSecurityContext {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodSecurityContext {
        static mut instance: ::protobuf::lazy::Lazy<PodSecurityContext> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodSecurityContext,
        };
        unsafe {
            instance.get(PodSecurityContext::new)
        }
    }

    // optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 1;

    pub fn clear_seLinuxOptions(&mut self) {
        self.seLinuxOptions.clear();
    }

    pub fn has_seLinuxOptions(&self) -> bool {
        self.seLinuxOptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seLinuxOptions(&mut self, v: SELinuxOptions) {
        self.seLinuxOptions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seLinuxOptions(&mut self) -> &mut SELinuxOptions {
        if self.seLinuxOptions.is_none() {
            self.seLinuxOptions.set_default();
        }
        self.seLinuxOptions.as_mut().unwrap()
    }

    // Take field
    pub fn take_seLinuxOptions(&mut self) -> SELinuxOptions {
        self.seLinuxOptions.take().unwrap_or_else(|| SELinuxOptions::new())
    }

    pub fn get_seLinuxOptions(&self) -> &SELinuxOptions {
        self.seLinuxOptions.as_ref().unwrap_or_else(|| SELinuxOptions::default_instance())
    }

    fn get_seLinuxOptions_for_reflect(&self) -> &::protobuf::SingularPtrField<SELinuxOptions> {
        &self.seLinuxOptions
    }

    fn mut_seLinuxOptions_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<SELinuxOptions> {
        &mut self.seLinuxOptions
    }

    // optional int64 runAsUser = 2;

    pub fn clear_runAsUser(&mut self) {
        self.runAsUser = ::std::option::Option::None;
    }

    pub fn has_runAsUser(&self) -> bool {
        self.runAsUser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsUser(&mut self, v: i64) {
        self.runAsUser = ::std::option::Option::Some(v);
    }

    pub fn get_runAsUser(&self) -> i64 {
        self.runAsUser.unwrap_or(0)
    }

    fn get_runAsUser_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.runAsUser
    }

    fn mut_runAsUser_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.runAsUser
    }

    // optional bool runAsNonRoot = 3;

    pub fn clear_runAsNonRoot(&mut self) {
        self.runAsNonRoot = ::std::option::Option::None;
    }

    pub fn has_runAsNonRoot(&self) -> bool {
        self.runAsNonRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsNonRoot(&mut self, v: bool) {
        self.runAsNonRoot = ::std::option::Option::Some(v);
    }

    pub fn get_runAsNonRoot(&self) -> bool {
        self.runAsNonRoot.unwrap_or(false)
    }

    fn get_runAsNonRoot_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.runAsNonRoot
    }

    fn mut_runAsNonRoot_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.runAsNonRoot
    }

    // repeated int64 supplementalGroups = 4;

    pub fn clear_supplementalGroups(&mut self) {
        self.supplementalGroups.clear();
    }

    // Param is passed by value, moved
    pub fn set_supplementalGroups(&mut self, v: ::std::vec::Vec<i64>) {
        self.supplementalGroups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supplementalGroups(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.supplementalGroups
    }

    // Take field
    pub fn take_supplementalGroups(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.supplementalGroups, ::std::vec::Vec::new())
    }

    pub fn get_supplementalGroups(&self) -> &[i64] {
        &self.supplementalGroups
    }

    fn get_supplementalGroups_for_reflect(&self) -> &::std::vec::Vec<i64> {
        &self.supplementalGroups
    }

    fn mut_supplementalGroups_for_reflect(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.supplementalGroups
    }

    // optional int64 fsGroup = 5;

    pub fn clear_fsGroup(&mut self) {
        self.fsGroup = ::std::option::Option::None;
    }

    pub fn has_fsGroup(&self) -> bool {
        self.fsGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsGroup(&mut self, v: i64) {
        self.fsGroup = ::std::option::Option::Some(v);
    }

    pub fn get_fsGroup(&self) -> i64 {
        self.fsGroup.unwrap_or(0)
    }

    fn get_fsGroup_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.fsGroup
    }

    fn mut_fsGroup_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.fsGroup
    }
}

impl ::protobuf::Message for PodSecurityContext {
    fn is_initialized(&self) -> bool {
        for v in &self.seLinuxOptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.seLinuxOptions)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.runAsUser = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.runAsNonRoot = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.supplementalGroups)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fsGroup = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.seLinuxOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.runAsUser {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.runAsNonRoot {
            my_size += 2;
        }
        for value in &self.supplementalGroups {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.fsGroup {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.seLinuxOptions.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.runAsUser {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.runAsNonRoot {
            os.write_bool(3, v)?;
        }
        for v in &self.supplementalGroups {
            os.write_int64(4, *v)?;
        };
        if let Some(v) = self.fsGroup {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodSecurityContext {
    fn new() -> PodSecurityContext {
        PodSecurityContext::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodSecurityContext>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SELinuxOptions>>(
                    "seLinuxOptions",
                    PodSecurityContext::get_seLinuxOptions_for_reflect,
                    PodSecurityContext::mut_seLinuxOptions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "runAsUser",
                    PodSecurityContext::get_runAsUser_for_reflect,
                    PodSecurityContext::mut_runAsUser_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "runAsNonRoot",
                    PodSecurityContext::get_runAsNonRoot_for_reflect,
                    PodSecurityContext::mut_runAsNonRoot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "supplementalGroups",
                    PodSecurityContext::get_supplementalGroups_for_reflect,
                    PodSecurityContext::mut_supplementalGroups_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fsGroup",
                    PodSecurityContext::get_fsGroup_for_reflect,
                    PodSecurityContext::mut_fsGroup_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodSecurityContext>(
                    "PodSecurityContext",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodSecurityContext {
    fn clear(&mut self) {
        self.clear_seLinuxOptions();
        self.clear_runAsUser();
        self.clear_runAsNonRoot();
        self.clear_supplementalGroups();
        self.clear_fsGroup();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSecurityContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSecurityContext {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSignature {
    // message fields
    podController: ::protobuf::SingularPtrField<super::generated::OwnerReference>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodSignature {}

impl PodSignature {
    pub fn new() -> PodSignature {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodSignature {
        static mut instance: ::protobuf::lazy::Lazy<PodSignature> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodSignature,
        };
        unsafe {
            instance.get(PodSignature::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference podController = 1;

    pub fn clear_podController(&mut self) {
        self.podController.clear();
    }

    pub fn has_podController(&self) -> bool {
        self.podController.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podController(&mut self, v: super::generated::OwnerReference) {
        self.podController = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podController(&mut self) -> &mut super::generated::OwnerReference {
        if self.podController.is_none() {
            self.podController.set_default();
        }
        self.podController.as_mut().unwrap()
    }

    // Take field
    pub fn take_podController(&mut self) -> super::generated::OwnerReference {
        self.podController.take().unwrap_or_else(|| super::generated::OwnerReference::new())
    }

    pub fn get_podController(&self) -> &super::generated::OwnerReference {
        self.podController.as_ref().unwrap_or_else(|| super::generated::OwnerReference::default_instance())
    }

    fn get_podController_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::OwnerReference> {
        &self.podController
    }

    fn mut_podController_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::OwnerReference> {
        &mut self.podController
    }
}

impl ::protobuf::Message for PodSignature {
    fn is_initialized(&self) -> bool {
        for v in &self.podController {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.podController)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.podController.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.podController.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodSignature {
    fn new() -> PodSignature {
        PodSignature::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodSignature>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::OwnerReference>>(
                    "podController",
                    PodSignature::get_podController_for_reflect,
                    PodSignature::mut_podController_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodSignature>(
                    "PodSignature",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodSignature {
    fn clear(&mut self) {
        self.clear_podController();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSignature {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSpec {
    // message fields
    volumes: ::protobuf::RepeatedField<Volume>,
    initContainers: ::protobuf::RepeatedField<Container>,
    containers: ::protobuf::RepeatedField<Container>,
    restartPolicy: ::protobuf::SingularField<::std::string::String>,
    terminationGracePeriodSeconds: ::std::option::Option<i64>,
    activeDeadlineSeconds: ::std::option::Option<i64>,
    dnsPolicy: ::protobuf::SingularField<::std::string::String>,
    pub nodeSelector: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    serviceAccountName: ::protobuf::SingularField<::std::string::String>,
    serviceAccount: ::protobuf::SingularField<::std::string::String>,
    automountServiceAccountToken: ::std::option::Option<bool>,
    nodeName: ::protobuf::SingularField<::std::string::String>,
    hostNetwork: ::std::option::Option<bool>,
    hostPID: ::std::option::Option<bool>,
    hostIPC: ::std::option::Option<bool>,
    securityContext: ::protobuf::SingularPtrField<PodSecurityContext>,
    imagePullSecrets: ::protobuf::RepeatedField<LocalObjectReference>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    subdomain: ::protobuf::SingularField<::std::string::String>,
    affinity: ::protobuf::SingularPtrField<Affinity>,
    schedulerName: ::protobuf::SingularField<::std::string::String>,
    tolerations: ::protobuf::RepeatedField<Toleration>,
    hostAliases: ::protobuf::RepeatedField<HostAlias>,
    priorityClassName: ::protobuf::SingularField<::std::string::String>,
    priority: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodSpec {}

impl PodSpec {
    pub fn new() -> PodSpec {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodSpec {
        static mut instance: ::protobuf::lazy::Lazy<PodSpec> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodSpec,
        };
        unsafe {
            instance.get(PodSpec::new)
        }
    }

    // repeated .k8s.io.api.core.v1.Volume volumes = 1;

    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::protobuf::RepeatedField<Volume>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes(&mut self) -> &mut ::protobuf::RepeatedField<Volume> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::protobuf::RepeatedField<Volume> {
        ::std::mem::replace(&mut self.volumes, ::protobuf::RepeatedField::new())
    }

    pub fn get_volumes(&self) -> &[Volume] {
        &self.volumes
    }

    fn get_volumes_for_reflect(&self) -> &::protobuf::RepeatedField<Volume> {
        &self.volumes
    }

    fn mut_volumes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Volume> {
        &mut self.volumes
    }

    // repeated .k8s.io.api.core.v1.Container initContainers = 20;

    pub fn clear_initContainers(&mut self) {
        self.initContainers.clear();
    }

    // Param is passed by value, moved
    pub fn set_initContainers(&mut self, v: ::protobuf::RepeatedField<Container>) {
        self.initContainers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_initContainers(&mut self) -> &mut ::protobuf::RepeatedField<Container> {
        &mut self.initContainers
    }

    // Take field
    pub fn take_initContainers(&mut self) -> ::protobuf::RepeatedField<Container> {
        ::std::mem::replace(&mut self.initContainers, ::protobuf::RepeatedField::new())
    }

    pub fn get_initContainers(&self) -> &[Container] {
        &self.initContainers
    }

    fn get_initContainers_for_reflect(&self) -> &::protobuf::RepeatedField<Container> {
        &self.initContainers
    }

    fn mut_initContainers_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Container> {
        &mut self.initContainers
    }

    // repeated .k8s.io.api.core.v1.Container containers = 2;

    pub fn clear_containers(&mut self) {
        self.containers.clear();
    }

    // Param is passed by value, moved
    pub fn set_containers(&mut self, v: ::protobuf::RepeatedField<Container>) {
        self.containers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_containers(&mut self) -> &mut ::protobuf::RepeatedField<Container> {
        &mut self.containers
    }

    // Take field
    pub fn take_containers(&mut self) -> ::protobuf::RepeatedField<Container> {
        ::std::mem::replace(&mut self.containers, ::protobuf::RepeatedField::new())
    }

    pub fn get_containers(&self) -> &[Container] {
        &self.containers
    }

    fn get_containers_for_reflect(&self) -> &::protobuf::RepeatedField<Container> {
        &self.containers
    }

    fn mut_containers_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Container> {
        &mut self.containers
    }

    // optional string restartPolicy = 3;

    pub fn clear_restartPolicy(&mut self) {
        self.restartPolicy.clear();
    }

    pub fn has_restartPolicy(&self) -> bool {
        self.restartPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restartPolicy(&mut self, v: ::std::string::String) {
        self.restartPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_restartPolicy(&mut self) -> &mut ::std::string::String {
        if self.restartPolicy.is_none() {
            self.restartPolicy.set_default();
        }
        self.restartPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_restartPolicy(&mut self) -> ::std::string::String {
        self.restartPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_restartPolicy(&self) -> &str {
        match self.restartPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_restartPolicy_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.restartPolicy
    }

    fn mut_restartPolicy_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.restartPolicy
    }

    // optional int64 terminationGracePeriodSeconds = 4;

    pub fn clear_terminationGracePeriodSeconds(&mut self) {
        self.terminationGracePeriodSeconds = ::std::option::Option::None;
    }

    pub fn has_terminationGracePeriodSeconds(&self) -> bool {
        self.terminationGracePeriodSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationGracePeriodSeconds(&mut self, v: i64) {
        self.terminationGracePeriodSeconds = ::std::option::Option::Some(v);
    }

    pub fn get_terminationGracePeriodSeconds(&self) -> i64 {
        self.terminationGracePeriodSeconds.unwrap_or(0)
    }

    fn get_terminationGracePeriodSeconds_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.terminationGracePeriodSeconds
    }

    fn mut_terminationGracePeriodSeconds_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.terminationGracePeriodSeconds
    }

    // optional int64 activeDeadlineSeconds = 5;

    pub fn clear_activeDeadlineSeconds(&mut self) {
        self.activeDeadlineSeconds = ::std::option::Option::None;
    }

    pub fn has_activeDeadlineSeconds(&self) -> bool {
        self.activeDeadlineSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activeDeadlineSeconds(&mut self, v: i64) {
        self.activeDeadlineSeconds = ::std::option::Option::Some(v);
    }

    pub fn get_activeDeadlineSeconds(&self) -> i64 {
        self.activeDeadlineSeconds.unwrap_or(0)
    }

    fn get_activeDeadlineSeconds_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.activeDeadlineSeconds
    }

    fn mut_activeDeadlineSeconds_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.activeDeadlineSeconds
    }

    // optional string dnsPolicy = 6;

    pub fn clear_dnsPolicy(&mut self) {
        self.dnsPolicy.clear();
    }

    pub fn has_dnsPolicy(&self) -> bool {
        self.dnsPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dnsPolicy(&mut self, v: ::std::string::String) {
        self.dnsPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dnsPolicy(&mut self) -> &mut ::std::string::String {
        if self.dnsPolicy.is_none() {
            self.dnsPolicy.set_default();
        }
        self.dnsPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_dnsPolicy(&mut self) -> ::std::string::String {
        self.dnsPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_dnsPolicy(&self) -> &str {
        match self.dnsPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_dnsPolicy_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.dnsPolicy
    }

    fn mut_dnsPolicy_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.dnsPolicy
    }

    // repeated .k8s.io.api.core.v1.PodSpec.NodeSelectorEntry nodeSelector = 7;

    pub fn clear_nodeSelector(&mut self) {
        self.nodeSelector.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeSelector(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.nodeSelector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodeSelector(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.nodeSelector
    }

    // Take field
    pub fn take_nodeSelector(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.nodeSelector, ::std::collections::HashMap::new())
    }

    pub fn get_nodeSelector(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.nodeSelector
    }

    fn get_nodeSelector_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.nodeSelector
    }

    fn mut_nodeSelector_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.nodeSelector
    }

    // optional string serviceAccountName = 8;

    pub fn clear_serviceAccountName(&mut self) {
        self.serviceAccountName.clear();
    }

    pub fn has_serviceAccountName(&self) -> bool {
        self.serviceAccountName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceAccountName(&mut self, v: ::std::string::String) {
        self.serviceAccountName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceAccountName(&mut self) -> &mut ::std::string::String {
        if self.serviceAccountName.is_none() {
            self.serviceAccountName.set_default();
        }
        self.serviceAccountName.as_mut().unwrap()
    }

    // Take field
    pub fn take_serviceAccountName(&mut self) -> ::std::string::String {
        self.serviceAccountName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_serviceAccountName(&self) -> &str {
        match self.serviceAccountName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_serviceAccountName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.serviceAccountName
    }

    fn mut_serviceAccountName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.serviceAccountName
    }

    // optional string serviceAccount = 9;

    pub fn clear_serviceAccount(&mut self) {
        self.serviceAccount.clear();
    }

    pub fn has_serviceAccount(&self) -> bool {
        self.serviceAccount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceAccount(&mut self, v: ::std::string::String) {
        self.serviceAccount = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceAccount(&mut self) -> &mut ::std::string::String {
        if self.serviceAccount.is_none() {
            self.serviceAccount.set_default();
        }
        self.serviceAccount.as_mut().unwrap()
    }

    // Take field
    pub fn take_serviceAccount(&mut self) -> ::std::string::String {
        self.serviceAccount.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_serviceAccount(&self) -> &str {
        match self.serviceAccount.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_serviceAccount_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.serviceAccount
    }

    fn mut_serviceAccount_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.serviceAccount
    }

    // optional bool automountServiceAccountToken = 21;

    pub fn clear_automountServiceAccountToken(&mut self) {
        self.automountServiceAccountToken = ::std::option::Option::None;
    }

    pub fn has_automountServiceAccountToken(&self) -> bool {
        self.automountServiceAccountToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_automountServiceAccountToken(&mut self, v: bool) {
        self.automountServiceAccountToken = ::std::option::Option::Some(v);
    }

    pub fn get_automountServiceAccountToken(&self) -> bool {
        self.automountServiceAccountToken.unwrap_or(false)
    }

    fn get_automountServiceAccountToken_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.automountServiceAccountToken
    }

    fn mut_automountServiceAccountToken_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.automountServiceAccountToken
    }

    // optional string nodeName = 10;

    pub fn clear_nodeName(&mut self) {
        self.nodeName.clear();
    }

    pub fn has_nodeName(&self) -> bool {
        self.nodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeName(&mut self, v: ::std::string::String) {
        self.nodeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeName(&mut self) -> &mut ::std::string::String {
        if self.nodeName.is_none() {
            self.nodeName.set_default();
        }
        self.nodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeName(&mut self) -> ::std::string::String {
        self.nodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_nodeName(&self) -> &str {
        match self.nodeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_nodeName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.nodeName
    }

    fn mut_nodeName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.nodeName
    }

    // optional bool hostNetwork = 11;

    pub fn clear_hostNetwork(&mut self) {
        self.hostNetwork = ::std::option::Option::None;
    }

    pub fn has_hostNetwork(&self) -> bool {
        self.hostNetwork.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostNetwork(&mut self, v: bool) {
        self.hostNetwork = ::std::option::Option::Some(v);
    }

    pub fn get_hostNetwork(&self) -> bool {
        self.hostNetwork.unwrap_or(false)
    }

    fn get_hostNetwork_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.hostNetwork
    }

    fn mut_hostNetwork_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.hostNetwork
    }

    // optional bool hostPID = 12;

    pub fn clear_hostPID(&mut self) {
        self.hostPID = ::std::option::Option::None;
    }

    pub fn has_hostPID(&self) -> bool {
        self.hostPID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostPID(&mut self, v: bool) {
        self.hostPID = ::std::option::Option::Some(v);
    }

    pub fn get_hostPID(&self) -> bool {
        self.hostPID.unwrap_or(false)
    }

    fn get_hostPID_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.hostPID
    }

    fn mut_hostPID_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.hostPID
    }

    // optional bool hostIPC = 13;

    pub fn clear_hostIPC(&mut self) {
        self.hostIPC = ::std::option::Option::None;
    }

    pub fn has_hostIPC(&self) -> bool {
        self.hostIPC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostIPC(&mut self, v: bool) {
        self.hostIPC = ::std::option::Option::Some(v);
    }

    pub fn get_hostIPC(&self) -> bool {
        self.hostIPC.unwrap_or(false)
    }

    fn get_hostIPC_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.hostIPC
    }

    fn mut_hostIPC_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.hostIPC
    }

    // optional .k8s.io.api.core.v1.PodSecurityContext securityContext = 14;

    pub fn clear_securityContext(&mut self) {
        self.securityContext.clear();
    }

    pub fn has_securityContext(&self) -> bool {
        self.securityContext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_securityContext(&mut self, v: PodSecurityContext) {
        self.securityContext = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_securityContext(&mut self) -> &mut PodSecurityContext {
        if self.securityContext.is_none() {
            self.securityContext.set_default();
        }
        self.securityContext.as_mut().unwrap()
    }

    // Take field
    pub fn take_securityContext(&mut self) -> PodSecurityContext {
        self.securityContext.take().unwrap_or_else(|| PodSecurityContext::new())
    }

    pub fn get_securityContext(&self) -> &PodSecurityContext {
        self.securityContext.as_ref().unwrap_or_else(|| PodSecurityContext::default_instance())
    }

    fn get_securityContext_for_reflect(&self) -> &::protobuf::SingularPtrField<PodSecurityContext> {
        &self.securityContext
    }

    fn mut_securityContext_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PodSecurityContext> {
        &mut self.securityContext
    }

    // repeated .k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 15;

    pub fn clear_imagePullSecrets(&mut self) {
        self.imagePullSecrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_imagePullSecrets(&mut self, v: ::protobuf::RepeatedField<LocalObjectReference>) {
        self.imagePullSecrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_imagePullSecrets(&mut self) -> &mut ::protobuf::RepeatedField<LocalObjectReference> {
        &mut self.imagePullSecrets
    }

    // Take field
    pub fn take_imagePullSecrets(&mut self) -> ::protobuf::RepeatedField<LocalObjectReference> {
        ::std::mem::replace(&mut self.imagePullSecrets, ::protobuf::RepeatedField::new())
    }

    pub fn get_imagePullSecrets(&self) -> &[LocalObjectReference] {
        &self.imagePullSecrets
    }

    fn get_imagePullSecrets_for_reflect(&self) -> &::protobuf::RepeatedField<LocalObjectReference> {
        &self.imagePullSecrets
    }

    fn mut_imagePullSecrets_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<LocalObjectReference> {
        &mut self.imagePullSecrets
    }

    // optional string hostname = 16;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hostname_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hostname
    }

    fn mut_hostname_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hostname
    }

    // optional string subdomain = 17;

    pub fn clear_subdomain(&mut self) {
        self.subdomain.clear();
    }

    pub fn has_subdomain(&self) -> bool {
        self.subdomain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subdomain(&mut self, v: ::std::string::String) {
        self.subdomain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subdomain(&mut self) -> &mut ::std::string::String {
        if self.subdomain.is_none() {
            self.subdomain.set_default();
        }
        self.subdomain.as_mut().unwrap()
    }

    // Take field
    pub fn take_subdomain(&mut self) -> ::std::string::String {
        self.subdomain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_subdomain(&self) -> &str {
        match self.subdomain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_subdomain_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.subdomain
    }

    fn mut_subdomain_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.subdomain
    }

    // optional .k8s.io.api.core.v1.Affinity affinity = 18;

    pub fn clear_affinity(&mut self) {
        self.affinity.clear();
    }

    pub fn has_affinity(&self) -> bool {
        self.affinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_affinity(&mut self, v: Affinity) {
        self.affinity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_affinity(&mut self) -> &mut Affinity {
        if self.affinity.is_none() {
            self.affinity.set_default();
        }
        self.affinity.as_mut().unwrap()
    }

    // Take field
    pub fn take_affinity(&mut self) -> Affinity {
        self.affinity.take().unwrap_or_else(|| Affinity::new())
    }

    pub fn get_affinity(&self) -> &Affinity {
        self.affinity.as_ref().unwrap_or_else(|| Affinity::default_instance())
    }

    fn get_affinity_for_reflect(&self) -> &::protobuf::SingularPtrField<Affinity> {
        &self.affinity
    }

    fn mut_affinity_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Affinity> {
        &mut self.affinity
    }

    // optional string schedulerName = 19;

    pub fn clear_schedulerName(&mut self) {
        self.schedulerName.clear();
    }

    pub fn has_schedulerName(&self) -> bool {
        self.schedulerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schedulerName(&mut self, v: ::std::string::String) {
        self.schedulerName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schedulerName(&mut self) -> &mut ::std::string::String {
        if self.schedulerName.is_none() {
            self.schedulerName.set_default();
        }
        self.schedulerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_schedulerName(&mut self) -> ::std::string::String {
        self.schedulerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_schedulerName(&self) -> &str {
        match self.schedulerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_schedulerName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.schedulerName
    }

    fn mut_schedulerName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.schedulerName
    }

    // repeated .k8s.io.api.core.v1.Toleration tolerations = 22;

    pub fn clear_tolerations(&mut self) {
        self.tolerations.clear();
    }

    // Param is passed by value, moved
    pub fn set_tolerations(&mut self, v: ::protobuf::RepeatedField<Toleration>) {
        self.tolerations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tolerations(&mut self) -> &mut ::protobuf::RepeatedField<Toleration> {
        &mut self.tolerations
    }

    // Take field
    pub fn take_tolerations(&mut self) -> ::protobuf::RepeatedField<Toleration> {
        ::std::mem::replace(&mut self.tolerations, ::protobuf::RepeatedField::new())
    }

    pub fn get_tolerations(&self) -> &[Toleration] {
        &self.tolerations
    }

    fn get_tolerations_for_reflect(&self) -> &::protobuf::RepeatedField<Toleration> {
        &self.tolerations
    }

    fn mut_tolerations_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Toleration> {
        &mut self.tolerations
    }

    // repeated .k8s.io.api.core.v1.HostAlias hostAliases = 23;

    pub fn clear_hostAliases(&mut self) {
        self.hostAliases.clear();
    }

    // Param is passed by value, moved
    pub fn set_hostAliases(&mut self, v: ::protobuf::RepeatedField<HostAlias>) {
        self.hostAliases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hostAliases(&mut self) -> &mut ::protobuf::RepeatedField<HostAlias> {
        &mut self.hostAliases
    }

    // Take field
    pub fn take_hostAliases(&mut self) -> ::protobuf::RepeatedField<HostAlias> {
        ::std::mem::replace(&mut self.hostAliases, ::protobuf::RepeatedField::new())
    }

    pub fn get_hostAliases(&self) -> &[HostAlias] {
        &self.hostAliases
    }

    fn get_hostAliases_for_reflect(&self) -> &::protobuf::RepeatedField<HostAlias> {
        &self.hostAliases
    }

    fn mut_hostAliases_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<HostAlias> {
        &mut self.hostAliases
    }

    // optional string priorityClassName = 24;

    pub fn clear_priorityClassName(&mut self) {
        self.priorityClassName.clear();
    }

    pub fn has_priorityClassName(&self) -> bool {
        self.priorityClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priorityClassName(&mut self, v: ::std::string::String) {
        self.priorityClassName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_priorityClassName(&mut self) -> &mut ::std::string::String {
        if self.priorityClassName.is_none() {
            self.priorityClassName.set_default();
        }
        self.priorityClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_priorityClassName(&mut self) -> ::std::string::String {
        self.priorityClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_priorityClassName(&self) -> &str {
        match self.priorityClassName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_priorityClassName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.priorityClassName
    }

    fn mut_priorityClassName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.priorityClassName
    }

    // optional int32 priority = 25;

    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i32) {
        self.priority = ::std::option::Option::Some(v);
    }

    pub fn get_priority(&self) -> i32 {
        self.priority.unwrap_or(0)
    }

    fn get_priority_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.priority
    }

    fn mut_priority_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.priority
    }
}

impl ::protobuf::Message for PodSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.volumes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initContainers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.containers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.securityContext {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.imagePullSecrets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.affinity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tolerations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hostAliases {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumes)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.initContainers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.containers)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.restartPolicy)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.terminationGracePeriodSeconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.activeDeadlineSeconds = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dnsPolicy)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.nodeSelector)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serviceAccountName)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serviceAccount)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.automountServiceAccountToken = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nodeName)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hostNetwork = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hostPID = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hostIPC = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.securityContext)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.imagePullSecrets)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subdomain)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.affinity)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.schedulerName)?;
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tolerations)?;
                },
                23 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hostAliases)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.priorityClassName)?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.priority = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.volumes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.initContainers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.containers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.restartPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.terminationGracePeriodSeconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.activeDeadlineSeconds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dnsPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.nodeSelector);
        if let Some(ref v) = self.serviceAccountName.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.serviceAccount.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.automountServiceAccountToken {
            my_size += 3;
        }
        if let Some(ref v) = self.nodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.hostNetwork {
            my_size += 2;
        }
        if let Some(v) = self.hostPID {
            my_size += 2;
        }
        if let Some(v) = self.hostIPC {
            my_size += 2;
        }
        if let Some(ref v) = self.securityContext.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.imagePullSecrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(ref v) = self.subdomain.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(ref v) = self.affinity.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.schedulerName.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        for value in &self.tolerations {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.hostAliases {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.priorityClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(24, &v);
        }
        if let Some(v) = self.priority {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.volumes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.initContainers {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.containers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.restartPolicy.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.terminationGracePeriodSeconds {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.activeDeadlineSeconds {
            os.write_int64(5, v)?;
        }
        if let Some(ref v) = self.dnsPolicy.as_ref() {
            os.write_string(6, &v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.nodeSelector, os)?;
        if let Some(ref v) = self.serviceAccountName.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.serviceAccount.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.automountServiceAccountToken {
            os.write_bool(21, v)?;
        }
        if let Some(ref v) = self.nodeName.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.hostNetwork {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.hostPID {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.hostIPC {
            os.write_bool(13, v)?;
        }
        if let Some(ref v) = self.securityContext.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.imagePullSecrets {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(16, &v)?;
        }
        if let Some(ref v) = self.subdomain.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(ref v) = self.affinity.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.schedulerName.as_ref() {
            os.write_string(19, &v)?;
        }
        for v in &self.tolerations {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.hostAliases {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.priorityClassName.as_ref() {
            os.write_string(24, &v)?;
        }
        if let Some(v) = self.priority {
            os.write_int32(25, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodSpec {
    fn new() -> PodSpec {
        PodSpec::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodSpec>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Volume>>(
                    "volumes",
                    PodSpec::get_volumes_for_reflect,
                    PodSpec::mut_volumes_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Container>>(
                    "initContainers",
                    PodSpec::get_initContainers_for_reflect,
                    PodSpec::mut_initContainers_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Container>>(
                    "containers",
                    PodSpec::get_containers_for_reflect,
                    PodSpec::mut_containers_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "restartPolicy",
                    PodSpec::get_restartPolicy_for_reflect,
                    PodSpec::mut_restartPolicy_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "terminationGracePeriodSeconds",
                    PodSpec::get_terminationGracePeriodSeconds_for_reflect,
                    PodSpec::mut_terminationGracePeriodSeconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "activeDeadlineSeconds",
                    PodSpec::get_activeDeadlineSeconds_for_reflect,
                    PodSpec::mut_activeDeadlineSeconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dnsPolicy",
                    PodSpec::get_dnsPolicy_for_reflect,
                    PodSpec::mut_dnsPolicy_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "nodeSelector",
                    PodSpec::get_nodeSelector_for_reflect,
                    PodSpec::mut_nodeSelector_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serviceAccountName",
                    PodSpec::get_serviceAccountName_for_reflect,
                    PodSpec::mut_serviceAccountName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "serviceAccount",
                    PodSpec::get_serviceAccount_for_reflect,
                    PodSpec::mut_serviceAccount_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "automountServiceAccountToken",
                    PodSpec::get_automountServiceAccountToken_for_reflect,
                    PodSpec::mut_automountServiceAccountToken_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodeName",
                    PodSpec::get_nodeName_for_reflect,
                    PodSpec::mut_nodeName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hostNetwork",
                    PodSpec::get_hostNetwork_for_reflect,
                    PodSpec::mut_hostNetwork_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hostPID",
                    PodSpec::get_hostPID_for_reflect,
                    PodSpec::mut_hostPID_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "hostIPC",
                    PodSpec::get_hostIPC_for_reflect,
                    PodSpec::mut_hostIPC_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSecurityContext>>(
                    "securityContext",
                    PodSpec::get_securityContext_for_reflect,
                    PodSpec::mut_securityContext_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "imagePullSecrets",
                    PodSpec::get_imagePullSecrets_for_reflect,
                    PodSpec::mut_imagePullSecrets_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostname",
                    PodSpec::get_hostname_for_reflect,
                    PodSpec::mut_hostname_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subdomain",
                    PodSpec::get_subdomain_for_reflect,
                    PodSpec::mut_subdomain_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Affinity>>(
                    "affinity",
                    PodSpec::get_affinity_for_reflect,
                    PodSpec::mut_affinity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "schedulerName",
                    PodSpec::get_schedulerName_for_reflect,
                    PodSpec::mut_schedulerName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Toleration>>(
                    "tolerations",
                    PodSpec::get_tolerations_for_reflect,
                    PodSpec::mut_tolerations_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HostAlias>>(
                    "hostAliases",
                    PodSpec::get_hostAliases_for_reflect,
                    PodSpec::mut_hostAliases_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "priorityClassName",
                    PodSpec::get_priorityClassName_for_reflect,
                    PodSpec::mut_priorityClassName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "priority",
                    PodSpec::get_priority_for_reflect,
                    PodSpec::mut_priority_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodSpec>(
                    "PodSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodSpec {
    fn clear(&mut self) {
        self.clear_volumes();
        self.clear_initContainers();
        self.clear_containers();
        self.clear_restartPolicy();
        self.clear_terminationGracePeriodSeconds();
        self.clear_activeDeadlineSeconds();
        self.clear_dnsPolicy();
        self.clear_nodeSelector();
        self.clear_serviceAccountName();
        self.clear_serviceAccount();
        self.clear_automountServiceAccountToken();
        self.clear_nodeName();
        self.clear_hostNetwork();
        self.clear_hostPID();
        self.clear_hostIPC();
        self.clear_securityContext();
        self.clear_imagePullSecrets();
        self.clear_hostname();
        self.clear_subdomain();
        self.clear_affinity();
        self.clear_schedulerName();
        self.clear_tolerations();
        self.clear_hostAliases();
        self.clear_priorityClassName();
        self.clear_priority();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodStatus {
    // message fields
    phase: ::protobuf::SingularField<::std::string::String>,
    conditions: ::protobuf::RepeatedField<PodCondition>,
    message: ::protobuf::SingularField<::std::string::String>,
    reason: ::protobuf::SingularField<::std::string::String>,
    hostIP: ::protobuf::SingularField<::std::string::String>,
    podIP: ::protobuf::SingularField<::std::string::String>,
    startTime: ::protobuf::SingularPtrField<super::generated::Time>,
    initContainerStatuses: ::protobuf::RepeatedField<ContainerStatus>,
    containerStatuses: ::protobuf::RepeatedField<ContainerStatus>,
    qosClass: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodStatus {}

impl PodStatus {
    pub fn new() -> PodStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodStatus {
        static mut instance: ::protobuf::lazy::Lazy<PodStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodStatus,
        };
        unsafe {
            instance.get(PodStatus::new)
        }
    }

    // optional string phase = 1;

    pub fn clear_phase(&mut self) {
        self.phase.clear();
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase.set_default();
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_phase_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.phase
    }

    fn mut_phase_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.phase
    }

    // repeated .k8s.io.api.core.v1.PodCondition conditions = 2;

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<PodCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<PodCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<PodCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }

    pub fn get_conditions(&self) -> &[PodCondition] {
        &self.conditions
    }

    fn get_conditions_for_reflect(&self) -> &::protobuf::RepeatedField<PodCondition> {
        &self.conditions
    }

    fn mut_conditions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<PodCondition> {
        &mut self.conditions
    }

    // optional string message = 3;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }

    // optional string reason = 4;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_reason_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.reason
    }

    // optional string hostIP = 5;

    pub fn clear_hostIP(&mut self) {
        self.hostIP.clear();
    }

    pub fn has_hostIP(&self) -> bool {
        self.hostIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostIP(&mut self, v: ::std::string::String) {
        self.hostIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostIP(&mut self) -> &mut ::std::string::String {
        if self.hostIP.is_none() {
            self.hostIP.set_default();
        }
        self.hostIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostIP(&mut self) -> ::std::string::String {
        self.hostIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostIP(&self) -> &str {
        match self.hostIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_hostIP_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.hostIP
    }

    fn mut_hostIP_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.hostIP
    }

    // optional string podIP = 6;

    pub fn clear_podIP(&mut self) {
        self.podIP.clear();
    }

    pub fn has_podIP(&self) -> bool {
        self.podIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podIP(&mut self, v: ::std::string::String) {
        self.podIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podIP(&mut self) -> &mut ::std::string::String {
        if self.podIP.is_none() {
            self.podIP.set_default();
        }
        self.podIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_podIP(&mut self) -> ::std::string::String {
        self.podIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_podIP(&self) -> &str {
        match self.podIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_podIP_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.podIP
    }

    fn mut_podIP_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.podIP
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 7;

    pub fn clear_startTime(&mut self) {
        self.startTime.clear();
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: super::generated::Time) {
        self.startTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startTime(&mut self) -> &mut super::generated::Time {
        if self.startTime.is_none() {
            self.startTime.set_default();
        }
        self.startTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_startTime(&mut self) -> super::generated::Time {
        self.startTime.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_startTime(&self) -> &super::generated::Time {
        self.startTime.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_startTime_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.startTime
    }

    fn mut_startTime_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.startTime
    }

    // repeated .k8s.io.api.core.v1.ContainerStatus initContainerStatuses = 10;

    pub fn clear_initContainerStatuses(&mut self) {
        self.initContainerStatuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_initContainerStatuses(&mut self, v: ::protobuf::RepeatedField<ContainerStatus>) {
        self.initContainerStatuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_initContainerStatuses(&mut self) -> &mut ::protobuf::RepeatedField<ContainerStatus> {
        &mut self.initContainerStatuses
    }

    // Take field
    pub fn take_initContainerStatuses(&mut self) -> ::protobuf::RepeatedField<ContainerStatus> {
        ::std::mem::replace(&mut self.initContainerStatuses, ::protobuf::RepeatedField::new())
    }

    pub fn get_initContainerStatuses(&self) -> &[ContainerStatus] {
        &self.initContainerStatuses
    }

    fn get_initContainerStatuses_for_reflect(&self) -> &::protobuf::RepeatedField<ContainerStatus> {
        &self.initContainerStatuses
    }

    fn mut_initContainerStatuses_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ContainerStatus> {
        &mut self.initContainerStatuses
    }

    // repeated .k8s.io.api.core.v1.ContainerStatus containerStatuses = 8;

    pub fn clear_containerStatuses(&mut self) {
        self.containerStatuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_containerStatuses(&mut self, v: ::protobuf::RepeatedField<ContainerStatus>) {
        self.containerStatuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_containerStatuses(&mut self) -> &mut ::protobuf::RepeatedField<ContainerStatus> {
        &mut self.containerStatuses
    }

    // Take field
    pub fn take_containerStatuses(&mut self) -> ::protobuf::RepeatedField<ContainerStatus> {
        ::std::mem::replace(&mut self.containerStatuses, ::protobuf::RepeatedField::new())
    }

    pub fn get_containerStatuses(&self) -> &[ContainerStatus] {
        &self.containerStatuses
    }

    fn get_containerStatuses_for_reflect(&self) -> &::protobuf::RepeatedField<ContainerStatus> {
        &self.containerStatuses
    }

    fn mut_containerStatuses_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ContainerStatus> {
        &mut self.containerStatuses
    }

    // optional string qosClass = 9;

    pub fn clear_qosClass(&mut self) {
        self.qosClass.clear();
    }

    pub fn has_qosClass(&self) -> bool {
        self.qosClass.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qosClass(&mut self, v: ::std::string::String) {
        self.qosClass = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_qosClass(&mut self) -> &mut ::std::string::String {
        if self.qosClass.is_none() {
            self.qosClass.set_default();
        }
        self.qosClass.as_mut().unwrap()
    }

    // Take field
    pub fn take_qosClass(&mut self) -> ::std::string::String {
        self.qosClass.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_qosClass(&self) -> &str {
        match self.qosClass.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_qosClass_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.qosClass
    }

    fn mut_qosClass_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.qosClass
    }
}

impl ::protobuf::Message for PodStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.startTime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initContainerStatuses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.containerStatuses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phase)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostIP)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.podIP)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startTime)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.initContainerStatuses)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.containerStatuses)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.qosClass)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.hostIP.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.podIP.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.startTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.initContainerStatuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.containerStatuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.qosClass.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.phase.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.conditions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.hostIP.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.podIP.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.startTime.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.initContainerStatuses {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.containerStatuses {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.qosClass.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodStatus {
    fn new() -> PodStatus {
        PodStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "phase",
                    PodStatus::get_phase_for_reflect,
                    PodStatus::mut_phase_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodCondition>>(
                    "conditions",
                    PodStatus::get_conditions_for_reflect,
                    PodStatus::mut_conditions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    PodStatus::get_message_for_reflect,
                    PodStatus::mut_message_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reason",
                    PodStatus::get_reason_for_reflect,
                    PodStatus::mut_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "hostIP",
                    PodStatus::get_hostIP_for_reflect,
                    PodStatus::mut_hostIP_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "podIP",
                    PodStatus::get_podIP_for_reflect,
                    PodStatus::mut_podIP_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "startTime",
                    PodStatus::get_startTime_for_reflect,
                    PodStatus::mut_startTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStatus>>(
                    "initContainerStatuses",
                    PodStatus::get_initContainerStatuses_for_reflect,
                    PodStatus::mut_initContainerStatuses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStatus>>(
                    "containerStatuses",
                    PodStatus::get_containerStatuses_for_reflect,
                    PodStatus::mut_containerStatuses_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "qosClass",
                    PodStatus::get_qosClass_for_reflect,
                    PodStatus::mut_qosClass_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodStatus>(
                    "PodStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodStatus {
    fn clear(&mut self) {
        self.clear_phase();
        self.clear_conditions();
        self.clear_message();
        self.clear_reason();
        self.clear_hostIP();
        self.clear_podIP();
        self.clear_startTime();
        self.clear_initContainerStatuses();
        self.clear_containerStatuses();
        self.clear_qosClass();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodStatusResult {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    status: ::protobuf::SingularPtrField<PodStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodStatusResult {}

impl PodStatusResult {
    pub fn new() -> PodStatusResult {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodStatusResult {
        static mut instance: ::protobuf::lazy::Lazy<PodStatusResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodStatusResult,
        };
        unsafe {
            instance.get(PodStatusResult::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.PodStatus status = 2;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PodStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PodStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> PodStatus {
        self.status.take().unwrap_or_else(|| PodStatus::new())
    }

    pub fn get_status(&self) -> &PodStatus {
        self.status.as_ref().unwrap_or_else(|| PodStatus::default_instance())
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularPtrField<PodStatus> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PodStatus> {
        &mut self.status
    }
}

impl ::protobuf::Message for PodStatusResult {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodStatusResult {
    fn new() -> PodStatusResult {
        PodStatusResult::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodStatusResult>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    PodStatusResult::get_metadata_for_reflect,
                    PodStatusResult::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodStatus>>(
                    "status",
                    PodStatusResult::get_status_for_reflect,
                    PodStatusResult::mut_status_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodStatusResult>(
                    "PodStatusResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodStatusResult {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodStatusResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodStatusResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodTemplate {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    template: ::protobuf::SingularPtrField<PodTemplateSpec>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodTemplate {}

impl PodTemplate {
    pub fn new() -> PodTemplate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodTemplate {
        static mut instance: ::protobuf::lazy::Lazy<PodTemplate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodTemplate,
        };
        unsafe {
            instance.get(PodTemplate::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: PodTemplateSpec) {
        self.template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut PodTemplateSpec {
        if self.template.is_none() {
            self.template.set_default();
        }
        self.template.as_mut().unwrap()
    }

    // Take field
    pub fn take_template(&mut self) -> PodTemplateSpec {
        self.template.take().unwrap_or_else(|| PodTemplateSpec::new())
    }

    pub fn get_template(&self) -> &PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| PodTemplateSpec::default_instance())
    }

    fn get_template_for_reflect(&self) -> &::protobuf::SingularPtrField<PodTemplateSpec> {
        &self.template
    }

    fn mut_template_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PodTemplateSpec> {
        &mut self.template
    }
}

impl ::protobuf::Message for PodTemplate {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.template {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.template)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.template.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodTemplate {
    fn new() -> PodTemplate {
        PodTemplate::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodTemplate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    PodTemplate::get_metadata_for_reflect,
                    PodTemplate::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodTemplateSpec>>(
                    "template",
                    PodTemplate::get_template_for_reflect,
                    PodTemplate::mut_template_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodTemplate>(
                    "PodTemplate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodTemplate {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_template();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodTemplate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodTemplateList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<PodTemplate>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodTemplateList {}

impl PodTemplateList {
    pub fn new() -> PodTemplateList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodTemplateList {
        static mut instance: ::protobuf::lazy::Lazy<PodTemplateList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodTemplateList,
        };
        unsafe {
            instance.get(PodTemplateList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.PodTemplate items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<PodTemplate>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<PodTemplate> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<PodTemplate> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[PodTemplate] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<PodTemplate> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<PodTemplate> {
        &mut self.items
    }
}

impl ::protobuf::Message for PodTemplateList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodTemplateList {
    fn new() -> PodTemplateList {
        PodTemplateList::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodTemplateList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    PodTemplateList::get_metadata_for_reflect,
                    PodTemplateList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodTemplate>>(
                    "items",
                    PodTemplateList::get_items_for_reflect,
                    PodTemplateList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodTemplateList>(
                    "PodTemplateList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodTemplateList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodTemplateList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodTemplateList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodTemplateSpec {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    spec: ::protobuf::SingularPtrField<PodSpec>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PodTemplateSpec {}

impl PodTemplateSpec {
    pub fn new() -> PodTemplateSpec {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PodTemplateSpec {
        static mut instance: ::protobuf::lazy::Lazy<PodTemplateSpec> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PodTemplateSpec,
        };
        unsafe {
            instance.get(PodTemplateSpec::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.PodSpec spec = 2;

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PodSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PodSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> PodSpec {
        self.spec.take().unwrap_or_else(|| PodSpec::new())
    }

    pub fn get_spec(&self) -> &PodSpec {
        self.spec.as_ref().unwrap_or_else(|| PodSpec::default_instance())
    }

    fn get_spec_for_reflect(&self) -> &::protobuf::SingularPtrField<PodSpec> {
        &self.spec
    }

    fn mut_spec_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PodSpec> {
        &mut self.spec
    }
}

impl ::protobuf::Message for PodTemplateSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PodTemplateSpec {
    fn new() -> PodTemplateSpec {
        PodTemplateSpec::new()
    }

    fn descriptor_static(_: ::std::option::Option<PodTemplateSpec>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    PodTemplateSpec::get_metadata_for_reflect,
                    PodTemplateSpec::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSpec>>(
                    "spec",
                    PodTemplateSpec::get_spec_for_reflect,
                    PodTemplateSpec::mut_spec_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PodTemplateSpec>(
                    "PodTemplateSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PodTemplateSpec {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_spec();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodTemplateSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodTemplateSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PortworxVolumeSource {
    // message fields
    volumeID: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PortworxVolumeSource {}

impl PortworxVolumeSource {
    pub fn new() -> PortworxVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PortworxVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<PortworxVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PortworxVolumeSource,
        };
        unsafe {
            instance.get(PortworxVolumeSource::new)
        }
    }

    // optional string volumeID = 1;

    pub fn clear_volumeID(&mut self) {
        self.volumeID.clear();
    }

    pub fn has_volumeID(&self) -> bool {
        self.volumeID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeID(&mut self, v: ::std::string::String) {
        self.volumeID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeID(&mut self) -> &mut ::std::string::String {
        if self.volumeID.is_none() {
            self.volumeID.set_default();
        }
        self.volumeID.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeID(&mut self) -> ::std::string::String {
        self.volumeID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volumeID(&self) -> &str {
        match self.volumeID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volumeID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volumeID
    }

    fn mut_volumeID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volumeID
    }

    // optional string fsType = 2;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }

    // optional bool readOnly = 3;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }
}

impl ::protobuf::Message for PortworxVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumeID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumeID.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PortworxVolumeSource {
    fn new() -> PortworxVolumeSource {
        PortworxVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<PortworxVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volumeID",
                    PortworxVolumeSource::get_volumeID_for_reflect,
                    PortworxVolumeSource::mut_volumeID_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    PortworxVolumeSource::get_fsType_for_reflect,
                    PortworxVolumeSource::mut_fsType_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    PortworxVolumeSource::get_readOnly_for_reflect,
                    PortworxVolumeSource::mut_readOnly_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PortworxVolumeSource>(
                    "PortworxVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PortworxVolumeSource {
    fn clear(&mut self) {
        self.clear_volumeID();
        self.clear_fsType();
        self.clear_readOnly();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortworxVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortworxVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Preconditions {
    // message fields
    uid: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Preconditions {}

impl Preconditions {
    pub fn new() -> Preconditions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Preconditions {
        static mut instance: ::protobuf::lazy::Lazy<Preconditions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Preconditions,
        };
        unsafe {
            instance.get(Preconditions::new)
        }
    }

    // optional string uid = 1;

    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid.set_default();
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_uid_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.uid
    }

    fn mut_uid_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.uid
    }
}

impl ::protobuf::Message for Preconditions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.uid.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Preconditions {
    fn new() -> Preconditions {
        Preconditions::new()
    }

    fn descriptor_static(_: ::std::option::Option<Preconditions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uid",
                    Preconditions::get_uid_for_reflect,
                    Preconditions::mut_uid_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Preconditions>(
                    "Preconditions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Preconditions {
    fn clear(&mut self) {
        self.clear_uid();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Preconditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Preconditions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreferAvoidPodsEntry {
    // message fields
    podSignature: ::protobuf::SingularPtrField<PodSignature>,
    evictionTime: ::protobuf::SingularPtrField<super::generated::Time>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PreferAvoidPodsEntry {}

impl PreferAvoidPodsEntry {
    pub fn new() -> PreferAvoidPodsEntry {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PreferAvoidPodsEntry {
        static mut instance: ::protobuf::lazy::Lazy<PreferAvoidPodsEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PreferAvoidPodsEntry,
        };
        unsafe {
            instance.get(PreferAvoidPodsEntry::new)
        }
    }

    // optional .k8s.io.api.core.v1.PodSignature podSignature = 1;

    pub fn clear_podSignature(&mut self) {
        self.podSignature.clear();
    }

    pub fn has_podSignature(&self) -> bool {
        self.podSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podSignature(&mut self, v: PodSignature) {
        self.podSignature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podSignature(&mut self) -> &mut PodSignature {
        if self.podSignature.is_none() {
            self.podSignature.set_default();
        }
        self.podSignature.as_mut().unwrap()
    }

    // Take field
    pub fn take_podSignature(&mut self) -> PodSignature {
        self.podSignature.take().unwrap_or_else(|| PodSignature::new())
    }

    pub fn get_podSignature(&self) -> &PodSignature {
        self.podSignature.as_ref().unwrap_or_else(|| PodSignature::default_instance())
    }

    fn get_podSignature_for_reflect(&self) -> &::protobuf::SingularPtrField<PodSignature> {
        &self.podSignature
    }

    fn mut_podSignature_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PodSignature> {
        &mut self.podSignature
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time evictionTime = 2;

    pub fn clear_evictionTime(&mut self) {
        self.evictionTime.clear();
    }

    pub fn has_evictionTime(&self) -> bool {
        self.evictionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_evictionTime(&mut self, v: super::generated::Time) {
        self.evictionTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_evictionTime(&mut self) -> &mut super::generated::Time {
        if self.evictionTime.is_none() {
            self.evictionTime.set_default();
        }
        self.evictionTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_evictionTime(&mut self) -> super::generated::Time {
        self.evictionTime.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_evictionTime(&self) -> &super::generated::Time {
        self.evictionTime.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_evictionTime_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.evictionTime
    }

    fn mut_evictionTime_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.evictionTime
    }

    // optional string reason = 3;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_reason_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.reason
    }

    // optional string message = 4;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }
}

impl ::protobuf::Message for PreferAvoidPodsEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.podSignature {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.evictionTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.podSignature)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.evictionTime)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.podSignature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.evictionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.podSignature.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.evictionTime.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PreferAvoidPodsEntry {
    fn new() -> PreferAvoidPodsEntry {
        PreferAvoidPodsEntry::new()
    }

    fn descriptor_static(_: ::std::option::Option<PreferAvoidPodsEntry>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSignature>>(
                    "podSignature",
                    PreferAvoidPodsEntry::get_podSignature_for_reflect,
                    PreferAvoidPodsEntry::mut_podSignature_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "evictionTime",
                    PreferAvoidPodsEntry::get_evictionTime_for_reflect,
                    PreferAvoidPodsEntry::mut_evictionTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reason",
                    PreferAvoidPodsEntry::get_reason_for_reflect,
                    PreferAvoidPodsEntry::mut_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    PreferAvoidPodsEntry::get_message_for_reflect,
                    PreferAvoidPodsEntry::mut_message_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PreferAvoidPodsEntry>(
                    "PreferAvoidPodsEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PreferAvoidPodsEntry {
    fn clear(&mut self) {
        self.clear_podSignature();
        self.clear_evictionTime();
        self.clear_reason();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreferAvoidPodsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreferAvoidPodsEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreferredSchedulingTerm {
    // message fields
    weight: ::std::option::Option<i32>,
    preference: ::protobuf::SingularPtrField<NodeSelectorTerm>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PreferredSchedulingTerm {}

impl PreferredSchedulingTerm {
    pub fn new() -> PreferredSchedulingTerm {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PreferredSchedulingTerm {
        static mut instance: ::protobuf::lazy::Lazy<PreferredSchedulingTerm> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PreferredSchedulingTerm,
        };
        unsafe {
            instance.get(PreferredSchedulingTerm::new)
        }
    }

    // optional int32 weight = 1;

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i32) {
        self.weight = ::std::option::Option::Some(v);
    }

    pub fn get_weight(&self) -> i32 {
        self.weight.unwrap_or(0)
    }

    fn get_weight_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.weight
    }

    fn mut_weight_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.weight
    }

    // optional .k8s.io.api.core.v1.NodeSelectorTerm preference = 2;

    pub fn clear_preference(&mut self) {
        self.preference.clear();
    }

    pub fn has_preference(&self) -> bool {
        self.preference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preference(&mut self, v: NodeSelectorTerm) {
        self.preference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preference(&mut self) -> &mut NodeSelectorTerm {
        if self.preference.is_none() {
            self.preference.set_default();
        }
        self.preference.as_mut().unwrap()
    }

    // Take field
    pub fn take_preference(&mut self) -> NodeSelectorTerm {
        self.preference.take().unwrap_or_else(|| NodeSelectorTerm::new())
    }

    pub fn get_preference(&self) -> &NodeSelectorTerm {
        self.preference.as_ref().unwrap_or_else(|| NodeSelectorTerm::default_instance())
    }

    fn get_preference_for_reflect(&self) -> &::protobuf::SingularPtrField<NodeSelectorTerm> {
        &self.preference
    }

    fn mut_preference_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<NodeSelectorTerm> {
        &mut self.preference
    }
}

impl ::protobuf::Message for PreferredSchedulingTerm {
    fn is_initialized(&self) -> bool {
        for v in &self.preference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.weight = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preference)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.preference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.weight {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.preference.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PreferredSchedulingTerm {
    fn new() -> PreferredSchedulingTerm {
        PreferredSchedulingTerm::new()
    }

    fn descriptor_static(_: ::std::option::Option<PreferredSchedulingTerm>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "weight",
                    PreferredSchedulingTerm::get_weight_for_reflect,
                    PreferredSchedulingTerm::mut_weight_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSelectorTerm>>(
                    "preference",
                    PreferredSchedulingTerm::get_preference_for_reflect,
                    PreferredSchedulingTerm::mut_preference_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PreferredSchedulingTerm>(
                    "PreferredSchedulingTerm",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PreferredSchedulingTerm {
    fn clear(&mut self) {
        self.clear_weight();
        self.clear_preference();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreferredSchedulingTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreferredSchedulingTerm {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Probe {
    // message fields
    handler: ::protobuf::SingularPtrField<Handler>,
    initialDelaySeconds: ::std::option::Option<i32>,
    timeoutSeconds: ::std::option::Option<i32>,
    periodSeconds: ::std::option::Option<i32>,
    successThreshold: ::std::option::Option<i32>,
    failureThreshold: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Probe {}

impl Probe {
    pub fn new() -> Probe {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Probe {
        static mut instance: ::protobuf::lazy::Lazy<Probe> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Probe,
        };
        unsafe {
            instance.get(Probe::new)
        }
    }

    // optional .k8s.io.api.core.v1.Handler handler = 1;

    pub fn clear_handler(&mut self) {
        self.handler.clear();
    }

    pub fn has_handler(&self) -> bool {
        self.handler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handler(&mut self, v: Handler) {
        self.handler = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handler(&mut self) -> &mut Handler {
        if self.handler.is_none() {
            self.handler.set_default();
        }
        self.handler.as_mut().unwrap()
    }

    // Take field
    pub fn take_handler(&mut self) -> Handler {
        self.handler.take().unwrap_or_else(|| Handler::new())
    }

    pub fn get_handler(&self) -> &Handler {
        self.handler.as_ref().unwrap_or_else(|| Handler::default_instance())
    }

    fn get_handler_for_reflect(&self) -> &::protobuf::SingularPtrField<Handler> {
        &self.handler
    }

    fn mut_handler_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Handler> {
        &mut self.handler
    }

    // optional int32 initialDelaySeconds = 2;

    pub fn clear_initialDelaySeconds(&mut self) {
        self.initialDelaySeconds = ::std::option::Option::None;
    }

    pub fn has_initialDelaySeconds(&self) -> bool {
        self.initialDelaySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialDelaySeconds(&mut self, v: i32) {
        self.initialDelaySeconds = ::std::option::Option::Some(v);
    }

    pub fn get_initialDelaySeconds(&self) -> i32 {
        self.initialDelaySeconds.unwrap_or(0)
    }

    fn get_initialDelaySeconds_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.initialDelaySeconds
    }

    fn mut_initialDelaySeconds_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.initialDelaySeconds
    }

    // optional int32 timeoutSeconds = 3;

    pub fn clear_timeoutSeconds(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
    }

    pub fn has_timeoutSeconds(&self) -> bool {
        self.timeoutSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeoutSeconds(&mut self, v: i32) {
        self.timeoutSeconds = ::std::option::Option::Some(v);
    }

    pub fn get_timeoutSeconds(&self) -> i32 {
        self.timeoutSeconds.unwrap_or(0)
    }

    fn get_timeoutSeconds_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.timeoutSeconds
    }

    fn mut_timeoutSeconds_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.timeoutSeconds
    }

    // optional int32 periodSeconds = 4;

    pub fn clear_periodSeconds(&mut self) {
        self.periodSeconds = ::std::option::Option::None;
    }

    pub fn has_periodSeconds(&self) -> bool {
        self.periodSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodSeconds(&mut self, v: i32) {
        self.periodSeconds = ::std::option::Option::Some(v);
    }

    pub fn get_periodSeconds(&self) -> i32 {
        self.periodSeconds.unwrap_or(0)
    }

    fn get_periodSeconds_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.periodSeconds
    }

    fn mut_periodSeconds_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.periodSeconds
    }

    // optional int32 successThreshold = 5;

    pub fn clear_successThreshold(&mut self) {
        self.successThreshold = ::std::option::Option::None;
    }

    pub fn has_successThreshold(&self) -> bool {
        self.successThreshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_successThreshold(&mut self, v: i32) {
        self.successThreshold = ::std::option::Option::Some(v);
    }

    pub fn get_successThreshold(&self) -> i32 {
        self.successThreshold.unwrap_or(0)
    }

    fn get_successThreshold_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.successThreshold
    }

    fn mut_successThreshold_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.successThreshold
    }

    // optional int32 failureThreshold = 6;

    pub fn clear_failureThreshold(&mut self) {
        self.failureThreshold = ::std::option::Option::None;
    }

    pub fn has_failureThreshold(&self) -> bool {
        self.failureThreshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failureThreshold(&mut self, v: i32) {
        self.failureThreshold = ::std::option::Option::Some(v);
    }

    pub fn get_failureThreshold(&self) -> i32 {
        self.failureThreshold.unwrap_or(0)
    }

    fn get_failureThreshold_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.failureThreshold
    }

    fn mut_failureThreshold_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.failureThreshold
    }
}

impl ::protobuf::Message for Probe {
    fn is_initialized(&self) -> bool {
        for v in &self.handler {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.handler)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.initialDelaySeconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timeoutSeconds = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.periodSeconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.successThreshold = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.failureThreshold = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.handler.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.initialDelaySeconds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeoutSeconds {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.periodSeconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.successThreshold {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.failureThreshold {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.handler.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.initialDelaySeconds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.timeoutSeconds {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.periodSeconds {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.successThreshold {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.failureThreshold {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Probe {
    fn new() -> Probe {
        Probe::new()
    }

    fn descriptor_static(_: ::std::option::Option<Probe>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Handler>>(
                    "handler",
                    Probe::get_handler_for_reflect,
                    Probe::mut_handler_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "initialDelaySeconds",
                    Probe::get_initialDelaySeconds_for_reflect,
                    Probe::mut_initialDelaySeconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "timeoutSeconds",
                    Probe::get_timeoutSeconds_for_reflect,
                    Probe::mut_timeoutSeconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "periodSeconds",
                    Probe::get_periodSeconds_for_reflect,
                    Probe::mut_periodSeconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "successThreshold",
                    Probe::get_successThreshold_for_reflect,
                    Probe::mut_successThreshold_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "failureThreshold",
                    Probe::get_failureThreshold_for_reflect,
                    Probe::mut_failureThreshold_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Probe>(
                    "Probe",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Probe {
    fn clear(&mut self) {
        self.clear_handler();
        self.clear_initialDelaySeconds();
        self.clear_timeoutSeconds();
        self.clear_periodSeconds();
        self.clear_successThreshold();
        self.clear_failureThreshold();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Probe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Probe {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProjectedVolumeSource {
    // message fields
    sources: ::protobuf::RepeatedField<VolumeProjection>,
    defaultMode: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ProjectedVolumeSource {}

impl ProjectedVolumeSource {
    pub fn new() -> ProjectedVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ProjectedVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<ProjectedVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProjectedVolumeSource,
        };
        unsafe {
            instance.get(ProjectedVolumeSource::new)
        }
    }

    // repeated .k8s.io.api.core.v1.VolumeProjection sources = 1;

    pub fn clear_sources(&mut self) {
        self.sources.clear();
    }

    // Param is passed by value, moved
    pub fn set_sources(&mut self, v: ::protobuf::RepeatedField<VolumeProjection>) {
        self.sources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sources(&mut self) -> &mut ::protobuf::RepeatedField<VolumeProjection> {
        &mut self.sources
    }

    // Take field
    pub fn take_sources(&mut self) -> ::protobuf::RepeatedField<VolumeProjection> {
        ::std::mem::replace(&mut self.sources, ::protobuf::RepeatedField::new())
    }

    pub fn get_sources(&self) -> &[VolumeProjection] {
        &self.sources
    }

    fn get_sources_for_reflect(&self) -> &::protobuf::RepeatedField<VolumeProjection> {
        &self.sources
    }

    fn mut_sources_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<VolumeProjection> {
        &mut self.sources
    }

    // optional int32 defaultMode = 2;

    pub fn clear_defaultMode(&mut self) {
        self.defaultMode = ::std::option::Option::None;
    }

    pub fn has_defaultMode(&self) -> bool {
        self.defaultMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultMode(&mut self, v: i32) {
        self.defaultMode = ::std::option::Option::Some(v);
    }

    pub fn get_defaultMode(&self) -> i32 {
        self.defaultMode.unwrap_or(0)
    }

    fn get_defaultMode_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.defaultMode
    }

    fn mut_defaultMode_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.defaultMode
    }
}

impl ::protobuf::Message for ProjectedVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.sources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sources)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.defaultMode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.defaultMode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sources {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.defaultMode {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ProjectedVolumeSource {
    fn new() -> ProjectedVolumeSource {
        ProjectedVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<ProjectedVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VolumeProjection>>(
                    "sources",
                    ProjectedVolumeSource::get_sources_for_reflect,
                    ProjectedVolumeSource::mut_sources_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "defaultMode",
                    ProjectedVolumeSource::get_defaultMode_for_reflect,
                    ProjectedVolumeSource::mut_defaultMode_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProjectedVolumeSource>(
                    "ProjectedVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ProjectedVolumeSource {
    fn clear(&mut self) {
        self.clear_sources();
        self.clear_defaultMode();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProjectedVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProjectedVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuobyteVolumeSource {
    // message fields
    registry: ::protobuf::SingularField<::std::string::String>,
    volume: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    user: ::protobuf::SingularField<::std::string::String>,
    group: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for QuobyteVolumeSource {}

impl QuobyteVolumeSource {
    pub fn new() -> QuobyteVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static QuobyteVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<QuobyteVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const QuobyteVolumeSource,
        };
        unsafe {
            instance.get(QuobyteVolumeSource::new)
        }
    }

    // optional string registry = 1;

    pub fn clear_registry(&mut self) {
        self.registry.clear();
    }

    pub fn has_registry(&self) -> bool {
        self.registry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registry(&mut self, v: ::std::string::String) {
        self.registry = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registry(&mut self) -> &mut ::std::string::String {
        if self.registry.is_none() {
            self.registry.set_default();
        }
        self.registry.as_mut().unwrap()
    }

    // Take field
    pub fn take_registry(&mut self) -> ::std::string::String {
        self.registry.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_registry(&self) -> &str {
        match self.registry.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_registry_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.registry
    }

    fn mut_registry_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.registry
    }

    // optional string volume = 2;

    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: ::std::string::String) {
        self.volume = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut ::std::string::String {
        if self.volume.is_none() {
            self.volume.set_default();
        }
        self.volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume(&mut self) -> ::std::string::String {
        self.volume.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volume(&self) -> &str {
        match self.volume.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volume_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volume
    }

    fn mut_volume_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volume
    }

    // optional bool readOnly = 3;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }

    // optional string user = 4;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_user_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.user
    }

    fn mut_user_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.user
    }

    // optional string group = 5;

    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_group_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.group
    }

    fn mut_group_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.group
    }
}

impl ::protobuf::Message for QuobyteVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.registry)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volume)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registry.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.volume.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registry.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.volume.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for QuobyteVolumeSource {
    fn new() -> QuobyteVolumeSource {
        QuobyteVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<QuobyteVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "registry",
                    QuobyteVolumeSource::get_registry_for_reflect,
                    QuobyteVolumeSource::mut_registry_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volume",
                    QuobyteVolumeSource::get_volume_for_reflect,
                    QuobyteVolumeSource::mut_volume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    QuobyteVolumeSource::get_readOnly_for_reflect,
                    QuobyteVolumeSource::mut_readOnly_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user",
                    QuobyteVolumeSource::get_user_for_reflect,
                    QuobyteVolumeSource::mut_user_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "group",
                    QuobyteVolumeSource::get_group_for_reflect,
                    QuobyteVolumeSource::mut_group_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<QuobyteVolumeSource>(
                    "QuobyteVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for QuobyteVolumeSource {
    fn clear(&mut self) {
        self.clear_registry();
        self.clear_volume();
        self.clear_readOnly();
        self.clear_user();
        self.clear_group();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuobyteVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuobyteVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RBDVolumeSource {
    // message fields
    monitors: ::protobuf::RepeatedField<::std::string::String>,
    image: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    pool: ::protobuf::SingularField<::std::string::String>,
    user: ::protobuf::SingularField<::std::string::String>,
    keyring: ::protobuf::SingularField<::std::string::String>,
    secretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RBDVolumeSource {}

impl RBDVolumeSource {
    pub fn new() -> RBDVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RBDVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<RBDVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RBDVolumeSource,
        };
        unsafe {
            instance.get(RBDVolumeSource::new)
        }
    }

    // repeated string monitors = 1;

    pub fn clear_monitors(&mut self) {
        self.monitors.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitors(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.monitors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_monitors(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.monitors
    }

    // Take field
    pub fn take_monitors(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.monitors, ::protobuf::RepeatedField::new())
    }

    pub fn get_monitors(&self) -> &[::std::string::String] {
        &self.monitors
    }

    fn get_monitors_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.monitors
    }

    fn mut_monitors_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.monitors
    }

    // optional string image = 2;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_image_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.image
    }

    fn mut_image_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.image
    }

    // optional string fsType = 3;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }

    // optional string pool = 4;

    pub fn clear_pool(&mut self) {
        self.pool.clear();
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ::std::string::String {
        if self.pool.is_none() {
            self.pool.set_default();
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_pool(&self) -> &str {
        match self.pool.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_pool_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.pool
    }

    fn mut_pool_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.pool
    }

    // optional string user = 5;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_user_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.user
    }

    fn mut_user_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.user
    }

    // optional string keyring = 6;

    pub fn clear_keyring(&mut self) {
        self.keyring.clear();
    }

    pub fn has_keyring(&self) -> bool {
        self.keyring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyring(&mut self, v: ::std::string::String) {
        self.keyring = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyring(&mut self) -> &mut ::std::string::String {
        if self.keyring.is_none() {
            self.keyring.set_default();
        }
        self.keyring.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyring(&mut self) -> ::std::string::String {
        self.keyring.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_keyring(&self) -> &str {
        match self.keyring.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_keyring_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.keyring
    }

    fn mut_keyring_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.keyring
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 7;

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    pub fn get_secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| LocalObjectReference::default_instance())
    }

    fn get_secretRef_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalObjectReference> {
        &self.secretRef
    }

    fn mut_secretRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalObjectReference> {
        &mut self.secretRef
    }

    // optional bool readOnly = 8;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }
}

impl ::protobuf::Message for RBDVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.monitors)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pool)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.keyring)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.monitors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.pool.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.keyring.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.monitors {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.image.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.pool.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.keyring.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RBDVolumeSource {
    fn new() -> RBDVolumeSource {
        RBDVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<RBDVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "monitors",
                    RBDVolumeSource::get_monitors_for_reflect,
                    RBDVolumeSource::mut_monitors_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "image",
                    RBDVolumeSource::get_image_for_reflect,
                    RBDVolumeSource::mut_image_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    RBDVolumeSource::get_fsType_for_reflect,
                    RBDVolumeSource::mut_fsType_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "pool",
                    RBDVolumeSource::get_pool_for_reflect,
                    RBDVolumeSource::mut_pool_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user",
                    RBDVolumeSource::get_user_for_reflect,
                    RBDVolumeSource::mut_user_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "keyring",
                    RBDVolumeSource::get_keyring_for_reflect,
                    RBDVolumeSource::mut_keyring_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "secretRef",
                    RBDVolumeSource::get_secretRef_for_reflect,
                    RBDVolumeSource::mut_secretRef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    RBDVolumeSource::get_readOnly_for_reflect,
                    RBDVolumeSource::mut_readOnly_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RBDVolumeSource>(
                    "RBDVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RBDVolumeSource {
    fn clear(&mut self) {
        self.clear_monitors();
        self.clear_image();
        self.clear_fsType();
        self.clear_pool();
        self.clear_user();
        self.clear_keyring();
        self.clear_secretRef();
        self.clear_readOnly();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RBDVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RBDVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RangeAllocation {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    range: ::protobuf::SingularField<::std::string::String>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RangeAllocation {}

impl RangeAllocation {
    pub fn new() -> RangeAllocation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RangeAllocation {
        static mut instance: ::protobuf::lazy::Lazy<RangeAllocation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RangeAllocation,
        };
        unsafe {
            instance.get(RangeAllocation::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional string range = 2;

    pub fn clear_range(&mut self) {
        self.range.clear();
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: ::std::string::String) {
        self.range = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range(&mut self) -> &mut ::std::string::String {
        if self.range.is_none() {
            self.range.set_default();
        }
        self.range.as_mut().unwrap()
    }

    // Take field
    pub fn take_range(&mut self) -> ::std::string::String {
        self.range.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_range(&self) -> &str {
        match self.range.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_range_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.range
    }

    fn mut_range_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.range
    }

    // optional bytes data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    fn get_data_for_reflect(&self) -> &::protobuf::SingularField<::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::vec::Vec<u8>> {
        &mut self.data
    }
}

impl ::protobuf::Message for RangeAllocation {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.range)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.range.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.range.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RangeAllocation {
    fn new() -> RangeAllocation {
        RangeAllocation::new()
    }

    fn descriptor_static(_: ::std::option::Option<RangeAllocation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    RangeAllocation::get_metadata_for_reflect,
                    RangeAllocation::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "range",
                    RangeAllocation::get_range_for_reflect,
                    RangeAllocation::mut_range_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    RangeAllocation::get_data_for_reflect,
                    RangeAllocation::mut_data_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RangeAllocation>(
                    "RangeAllocation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RangeAllocation {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_range();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RangeAllocation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RangeAllocation {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplicationController {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    spec: ::protobuf::SingularPtrField<ReplicationControllerSpec>,
    status: ::protobuf::SingularPtrField<ReplicationControllerStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReplicationController {}

impl ReplicationController {
    pub fn new() -> ReplicationController {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReplicationController {
        static mut instance: ::protobuf::lazy::Lazy<ReplicationController> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReplicationController,
        };
        unsafe {
            instance.get(ReplicationController::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.ReplicationControllerSpec spec = 2;

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ReplicationControllerSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ReplicationControllerSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> ReplicationControllerSpec {
        self.spec.take().unwrap_or_else(|| ReplicationControllerSpec::new())
    }

    pub fn get_spec(&self) -> &ReplicationControllerSpec {
        self.spec.as_ref().unwrap_or_else(|| ReplicationControllerSpec::default_instance())
    }

    fn get_spec_for_reflect(&self) -> &::protobuf::SingularPtrField<ReplicationControllerSpec> {
        &self.spec
    }

    fn mut_spec_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ReplicationControllerSpec> {
        &mut self.spec
    }

    // optional .k8s.io.api.core.v1.ReplicationControllerStatus status = 3;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ReplicationControllerStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ReplicationControllerStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ReplicationControllerStatus {
        self.status.take().unwrap_or_else(|| ReplicationControllerStatus::new())
    }

    pub fn get_status(&self) -> &ReplicationControllerStatus {
        self.status.as_ref().unwrap_or_else(|| ReplicationControllerStatus::default_instance())
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularPtrField<ReplicationControllerStatus> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ReplicationControllerStatus> {
        &mut self.status
    }
}

impl ::protobuf::Message for ReplicationController {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReplicationController {
    fn new() -> ReplicationController {
        ReplicationController::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReplicationController>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    ReplicationController::get_metadata_for_reflect,
                    ReplicationController::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReplicationControllerSpec>>(
                    "spec",
                    ReplicationController::get_spec_for_reflect,
                    ReplicationController::mut_spec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReplicationControllerStatus>>(
                    "status",
                    ReplicationController::get_status_for_reflect,
                    ReplicationController::mut_status_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReplicationController>(
                    "ReplicationController",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReplicationController {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_spec();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicationController {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationController {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplicationControllerCondition {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    status: ::protobuf::SingularField<::std::string::String>,
    lastTransitionTime: ::protobuf::SingularPtrField<super::generated::Time>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReplicationControllerCondition {}

impl ReplicationControllerCondition {
    pub fn new() -> ReplicationControllerCondition {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReplicationControllerCondition {
        static mut instance: ::protobuf::lazy::Lazy<ReplicationControllerCondition> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReplicationControllerCondition,
        };
        unsafe {
            instance.get(ReplicationControllerCondition::new)
        }
    }

    // optional string type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_field_type_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.field_type
    }

    // optional string status = 2;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.status
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;

    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: super::generated::Time) {
        self.lastTransitionTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut super::generated::Time {
        if self.lastTransitionTime.is_none() {
            self.lastTransitionTime.set_default();
        }
        self.lastTransitionTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> super::generated::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_lastTransitionTime(&self) -> &super::generated::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_lastTransitionTime_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.lastTransitionTime
    }

    fn mut_lastTransitionTime_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.lastTransitionTime
    }

    // optional string reason = 4;

    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_reason_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.reason
    }

    fn mut_reason_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.reason
    }

    // optional string message = 5;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_message_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.message
    }

    fn mut_message_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.message
    }
}

impl ::protobuf::Message for ReplicationControllerCondition {
    fn is_initialized(&self) -> bool {
        for v in &self.lastTransitionTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastTransitionTime)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReplicationControllerCondition {
    fn new() -> ReplicationControllerCondition {
        ReplicationControllerCondition::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReplicationControllerCondition>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    ReplicationControllerCondition::get_field_type_for_reflect,
                    ReplicationControllerCondition::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "status",
                    ReplicationControllerCondition::get_status_for_reflect,
                    ReplicationControllerCondition::mut_status_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "lastTransitionTime",
                    ReplicationControllerCondition::get_lastTransitionTime_for_reflect,
                    ReplicationControllerCondition::mut_lastTransitionTime_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "reason",
                    ReplicationControllerCondition::get_reason_for_reflect,
                    ReplicationControllerCondition::mut_reason_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    ReplicationControllerCondition::get_message_for_reflect,
                    ReplicationControllerCondition::mut_message_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReplicationControllerCondition>(
                    "ReplicationControllerCondition",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReplicationControllerCondition {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_status();
        self.clear_lastTransitionTime();
        self.clear_reason();
        self.clear_message();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicationControllerCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationControllerCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplicationControllerList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<ReplicationController>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReplicationControllerList {}

impl ReplicationControllerList {
    pub fn new() -> ReplicationControllerList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReplicationControllerList {
        static mut instance: ::protobuf::lazy::Lazy<ReplicationControllerList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReplicationControllerList,
        };
        unsafe {
            instance.get(ReplicationControllerList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.ReplicationController items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ReplicationController>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ReplicationController> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ReplicationController> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[ReplicationController] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<ReplicationController> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ReplicationController> {
        &mut self.items
    }
}

impl ::protobuf::Message for ReplicationControllerList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReplicationControllerList {
    fn new() -> ReplicationControllerList {
        ReplicationControllerList::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReplicationControllerList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    ReplicationControllerList::get_metadata_for_reflect,
                    ReplicationControllerList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReplicationController>>(
                    "items",
                    ReplicationControllerList::get_items_for_reflect,
                    ReplicationControllerList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReplicationControllerList>(
                    "ReplicationControllerList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReplicationControllerList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicationControllerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationControllerList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplicationControllerSpec {
    // message fields
    replicas: ::std::option::Option<i32>,
    minReadySeconds: ::std::option::Option<i32>,
    pub selector: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    template: ::protobuf::SingularPtrField<PodTemplateSpec>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReplicationControllerSpec {}

impl ReplicationControllerSpec {
    pub fn new() -> ReplicationControllerSpec {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReplicationControllerSpec {
        static mut instance: ::protobuf::lazy::Lazy<ReplicationControllerSpec> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReplicationControllerSpec,
        };
        unsafe {
            instance.get(ReplicationControllerSpec::new)
        }
    }

    // optional int32 replicas = 1;

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    pub fn get_replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    fn get_replicas_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.replicas
    }

    fn mut_replicas_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.replicas
    }

    // optional int32 minReadySeconds = 4;

    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    pub fn get_minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }

    fn get_minReadySeconds_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.minReadySeconds
    }

    fn mut_minReadySeconds_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.minReadySeconds
    }

    // repeated .k8s.io.api.core.v1.ReplicationControllerSpec.SelectorEntry selector = 2;

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.selector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selector(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.selector
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.selector, ::std::collections::HashMap::new())
    }

    pub fn get_selector(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.selector
    }

    fn get_selector_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.selector
    }

    fn mut_selector_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.selector
    }

    // optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;

    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: PodTemplateSpec) {
        self.template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut PodTemplateSpec {
        if self.template.is_none() {
            self.template.set_default();
        }
        self.template.as_mut().unwrap()
    }

    // Take field
    pub fn take_template(&mut self) -> PodTemplateSpec {
        self.template.take().unwrap_or_else(|| PodTemplateSpec::new())
    }

    pub fn get_template(&self) -> &PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| PodTemplateSpec::default_instance())
    }

    fn get_template_for_reflect(&self) -> &::protobuf::SingularPtrField<PodTemplateSpec> {
        &self.template
    }

    fn mut_template_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PodTemplateSpec> {
        &mut self.template
    }
}

impl ::protobuf::Message for ReplicationControllerSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.template {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.replicas = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.minReadySeconds = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.selector)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.template)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.selector);
        if let Some(ref v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(4, v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.selector, os)?;
        if let Some(ref v) = self.template.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReplicationControllerSpec {
    fn new() -> ReplicationControllerSpec {
        ReplicationControllerSpec::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReplicationControllerSpec>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "replicas",
                    ReplicationControllerSpec::get_replicas_for_reflect,
                    ReplicationControllerSpec::mut_replicas_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "minReadySeconds",
                    ReplicationControllerSpec::get_minReadySeconds_for_reflect,
                    ReplicationControllerSpec::mut_minReadySeconds_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "selector",
                    ReplicationControllerSpec::get_selector_for_reflect,
                    ReplicationControllerSpec::mut_selector_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodTemplateSpec>>(
                    "template",
                    ReplicationControllerSpec::get_template_for_reflect,
                    ReplicationControllerSpec::mut_template_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReplicationControllerSpec>(
                    "ReplicationControllerSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReplicationControllerSpec {
    fn clear(&mut self) {
        self.clear_replicas();
        self.clear_minReadySeconds();
        self.clear_selector();
        self.clear_template();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicationControllerSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationControllerSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplicationControllerStatus {
    // message fields
    replicas: ::std::option::Option<i32>,
    fullyLabeledReplicas: ::std::option::Option<i32>,
    readyReplicas: ::std::option::Option<i32>,
    availableReplicas: ::std::option::Option<i32>,
    observedGeneration: ::std::option::Option<i64>,
    conditions: ::protobuf::RepeatedField<ReplicationControllerCondition>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ReplicationControllerStatus {}

impl ReplicationControllerStatus {
    pub fn new() -> ReplicationControllerStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ReplicationControllerStatus {
        static mut instance: ::protobuf::lazy::Lazy<ReplicationControllerStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ReplicationControllerStatus,
        };
        unsafe {
            instance.get(ReplicationControllerStatus::new)
        }
    }

    // optional int32 replicas = 1;

    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    pub fn get_replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }

    fn get_replicas_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.replicas
    }

    fn mut_replicas_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.replicas
    }

    // optional int32 fullyLabeledReplicas = 2;

    pub fn clear_fullyLabeledReplicas(&mut self) {
        self.fullyLabeledReplicas = ::std::option::Option::None;
    }

    pub fn has_fullyLabeledReplicas(&self) -> bool {
        self.fullyLabeledReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullyLabeledReplicas(&mut self, v: i32) {
        self.fullyLabeledReplicas = ::std::option::Option::Some(v);
    }

    pub fn get_fullyLabeledReplicas(&self) -> i32 {
        self.fullyLabeledReplicas.unwrap_or(0)
    }

    fn get_fullyLabeledReplicas_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.fullyLabeledReplicas
    }

    fn mut_fullyLabeledReplicas_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.fullyLabeledReplicas
    }

    // optional int32 readyReplicas = 4;

    pub fn clear_readyReplicas(&mut self) {
        self.readyReplicas = ::std::option::Option::None;
    }

    pub fn has_readyReplicas(&self) -> bool {
        self.readyReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readyReplicas(&mut self, v: i32) {
        self.readyReplicas = ::std::option::Option::Some(v);
    }

    pub fn get_readyReplicas(&self) -> i32 {
        self.readyReplicas.unwrap_or(0)
    }

    fn get_readyReplicas_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.readyReplicas
    }

    fn mut_readyReplicas_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.readyReplicas
    }

    // optional int32 availableReplicas = 5;

    pub fn clear_availableReplicas(&mut self) {
        self.availableReplicas = ::std::option::Option::None;
    }

    pub fn has_availableReplicas(&self) -> bool {
        self.availableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableReplicas(&mut self, v: i32) {
        self.availableReplicas = ::std::option::Option::Some(v);
    }

    pub fn get_availableReplicas(&self) -> i32 {
        self.availableReplicas.unwrap_or(0)
    }

    fn get_availableReplicas_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.availableReplicas
    }

    fn mut_availableReplicas_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.availableReplicas
    }

    // optional int64 observedGeneration = 3;

    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    pub fn get_observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }

    fn get_observedGeneration_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.observedGeneration
    }

    fn mut_observedGeneration_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.observedGeneration
    }

    // repeated .k8s.io.api.core.v1.ReplicationControllerCondition conditions = 6;

    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<ReplicationControllerCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<ReplicationControllerCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<ReplicationControllerCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }

    pub fn get_conditions(&self) -> &[ReplicationControllerCondition] {
        &self.conditions
    }

    fn get_conditions_for_reflect(&self) -> &::protobuf::RepeatedField<ReplicationControllerCondition> {
        &self.conditions
    }

    fn mut_conditions_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ReplicationControllerCondition> {
        &mut self.conditions
    }
}

impl ::protobuf::Message for ReplicationControllerStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.replicas = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fullyLabeledReplicas = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.readyReplicas = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.availableReplicas = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.observedGeneration = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fullyLabeledReplicas {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.readyReplicas {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.availableReplicas {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.fullyLabeledReplicas {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.readyReplicas {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.availableReplicas {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.observedGeneration {
            os.write_int64(3, v)?;
        }
        for v in &self.conditions {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ReplicationControllerStatus {
    fn new() -> ReplicationControllerStatus {
        ReplicationControllerStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<ReplicationControllerStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "replicas",
                    ReplicationControllerStatus::get_replicas_for_reflect,
                    ReplicationControllerStatus::mut_replicas_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "fullyLabeledReplicas",
                    ReplicationControllerStatus::get_fullyLabeledReplicas_for_reflect,
                    ReplicationControllerStatus::mut_fullyLabeledReplicas_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "readyReplicas",
                    ReplicationControllerStatus::get_readyReplicas_for_reflect,
                    ReplicationControllerStatus::mut_readyReplicas_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "availableReplicas",
                    ReplicationControllerStatus::get_availableReplicas_for_reflect,
                    ReplicationControllerStatus::mut_availableReplicas_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "observedGeneration",
                    ReplicationControllerStatus::get_observedGeneration_for_reflect,
                    ReplicationControllerStatus::mut_observedGeneration_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReplicationControllerCondition>>(
                    "conditions",
                    ReplicationControllerStatus::get_conditions_for_reflect,
                    ReplicationControllerStatus::mut_conditions_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ReplicationControllerStatus>(
                    "ReplicationControllerStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ReplicationControllerStatus {
    fn clear(&mut self) {
        self.clear_replicas();
        self.clear_fullyLabeledReplicas();
        self.clear_readyReplicas();
        self.clear_availableReplicas();
        self.clear_observedGeneration();
        self.clear_conditions();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicationControllerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationControllerStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceFieldSelector {
    // message fields
    containerName: ::protobuf::SingularField<::std::string::String>,
    resource: ::protobuf::SingularField<::std::string::String>,
    divisor: ::protobuf::SingularPtrField<super::generated::Quantity>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceFieldSelector {}

impl ResourceFieldSelector {
    pub fn new() -> ResourceFieldSelector {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceFieldSelector {
        static mut instance: ::protobuf::lazy::Lazy<ResourceFieldSelector> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceFieldSelector,
        };
        unsafe {
            instance.get(ResourceFieldSelector::new)
        }
    }

    // optional string containerName = 1;

    pub fn clear_containerName(&mut self) {
        self.containerName.clear();
    }

    pub fn has_containerName(&self) -> bool {
        self.containerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerName(&mut self, v: ::std::string::String) {
        self.containerName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_containerName(&mut self) -> &mut ::std::string::String {
        if self.containerName.is_none() {
            self.containerName.set_default();
        }
        self.containerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_containerName(&mut self) -> ::std::string::String {
        self.containerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_containerName(&self) -> &str {
        match self.containerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_containerName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.containerName
    }

    fn mut_containerName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.containerName
    }

    // optional string resource = 2;

    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if self.resource.is_none() {
            self.resource.set_default();
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        self.resource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_resource(&self) -> &str {
        match self.resource.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_resource_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.resource
    }

    fn mut_resource_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.resource
    }

    // optional .k8s.io.apimachinery.pkg.api.resource.Quantity divisor = 3;

    pub fn clear_divisor(&mut self) {
        self.divisor.clear();
    }

    pub fn has_divisor(&self) -> bool {
        self.divisor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_divisor(&mut self, v: super::generated::Quantity) {
        self.divisor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_divisor(&mut self) -> &mut super::generated::Quantity {
        if self.divisor.is_none() {
            self.divisor.set_default();
        }
        self.divisor.as_mut().unwrap()
    }

    // Take field
    pub fn take_divisor(&mut self) -> super::generated::Quantity {
        self.divisor.take().unwrap_or_else(|| super::generated::Quantity::new())
    }

    pub fn get_divisor(&self) -> &super::generated::Quantity {
        self.divisor.as_ref().unwrap_or_else(|| super::generated::Quantity::default_instance())
    }

    fn get_divisor_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Quantity> {
        &self.divisor
    }

    fn mut_divisor_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Quantity> {
        &mut self.divisor
    }
}

impl ::protobuf::Message for ResourceFieldSelector {
    fn is_initialized(&self) -> bool {
        for v in &self.divisor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.containerName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resource)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.divisor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.containerName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.resource.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.divisor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.containerName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.resource.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.divisor.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceFieldSelector {
    fn new() -> ResourceFieldSelector {
        ResourceFieldSelector::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceFieldSelector>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "containerName",
                    ResourceFieldSelector::get_containerName_for_reflect,
                    ResourceFieldSelector::mut_containerName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "resource",
                    ResourceFieldSelector::get_resource_for_reflect,
                    ResourceFieldSelector::mut_resource_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "divisor",
                    ResourceFieldSelector::get_divisor_for_reflect,
                    ResourceFieldSelector::mut_divisor_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceFieldSelector>(
                    "ResourceFieldSelector",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceFieldSelector {
    fn clear(&mut self) {
        self.clear_containerName();
        self.clear_resource();
        self.clear_divisor();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceFieldSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceFieldSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceQuota {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    spec: ::protobuf::SingularPtrField<ResourceQuotaSpec>,
    status: ::protobuf::SingularPtrField<ResourceQuotaStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceQuota {}

impl ResourceQuota {
    pub fn new() -> ResourceQuota {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceQuota {
        static mut instance: ::protobuf::lazy::Lazy<ResourceQuota> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceQuota,
        };
        unsafe {
            instance.get(ResourceQuota::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.ResourceQuotaSpec spec = 2;

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceQuotaSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceQuotaSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceQuotaSpec {
        self.spec.take().unwrap_or_else(|| ResourceQuotaSpec::new())
    }

    pub fn get_spec(&self) -> &ResourceQuotaSpec {
        self.spec.as_ref().unwrap_or_else(|| ResourceQuotaSpec::default_instance())
    }

    fn get_spec_for_reflect(&self) -> &::protobuf::SingularPtrField<ResourceQuotaSpec> {
        &self.spec
    }

    fn mut_spec_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ResourceQuotaSpec> {
        &mut self.spec
    }

    // optional .k8s.io.api.core.v1.ResourceQuotaStatus status = 3;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ResourceQuotaStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ResourceQuotaStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ResourceQuotaStatus {
        self.status.take().unwrap_or_else(|| ResourceQuotaStatus::new())
    }

    pub fn get_status(&self) -> &ResourceQuotaStatus {
        self.status.as_ref().unwrap_or_else(|| ResourceQuotaStatus::default_instance())
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularPtrField<ResourceQuotaStatus> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ResourceQuotaStatus> {
        &mut self.status
    }
}

impl ::protobuf::Message for ResourceQuota {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceQuota {
    fn new() -> ResourceQuota {
        ResourceQuota::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceQuota>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    ResourceQuota::get_metadata_for_reflect,
                    ResourceQuota::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceQuotaSpec>>(
                    "spec",
                    ResourceQuota::get_spec_for_reflect,
                    ResourceQuota::mut_spec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceQuotaStatus>>(
                    "status",
                    ResourceQuota::get_status_for_reflect,
                    ResourceQuota::mut_status_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceQuota>(
                    "ResourceQuota",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceQuota {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_spec();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceQuota {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceQuota {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceQuotaList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<ResourceQuota>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceQuotaList {}

impl ResourceQuotaList {
    pub fn new() -> ResourceQuotaList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceQuotaList {
        static mut instance: ::protobuf::lazy::Lazy<ResourceQuotaList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceQuotaList,
        };
        unsafe {
            instance.get(ResourceQuotaList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.ResourceQuota items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ResourceQuota>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ResourceQuota> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ResourceQuota> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[ResourceQuota] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<ResourceQuota> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ResourceQuota> {
        &mut self.items
    }
}

impl ::protobuf::Message for ResourceQuotaList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceQuotaList {
    fn new() -> ResourceQuotaList {
        ResourceQuotaList::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceQuotaList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    ResourceQuotaList::get_metadata_for_reflect,
                    ResourceQuotaList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceQuota>>(
                    "items",
                    ResourceQuotaList::get_items_for_reflect,
                    ResourceQuotaList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceQuotaList>(
                    "ResourceQuotaList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceQuotaList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceQuotaList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceQuotaList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceQuotaSpec {
    // message fields
    pub hard: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    scopes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceQuotaSpec {}

impl ResourceQuotaSpec {
    pub fn new() -> ResourceQuotaSpec {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceQuotaSpec {
        static mut instance: ::protobuf::lazy::Lazy<ResourceQuotaSpec> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceQuotaSpec,
        };
        unsafe {
            instance.get(ResourceQuotaSpec::new)
        }
    }

    // repeated .k8s.io.api.core.v1.ResourceQuotaSpec.HardEntry hard = 1;

    pub fn clear_hard(&mut self) {
        self.hard.clear();
    }

    // Param is passed by value, moved
    pub fn set_hard(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.hard = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hard(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.hard
    }

    // Take field
    pub fn take_hard(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.hard, ::std::collections::HashMap::new())
    }

    pub fn get_hard(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.hard
    }

    fn get_hard_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.hard
    }

    fn mut_hard_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.hard
    }

    // repeated string scopes = 2;

    pub fn clear_scopes(&mut self) {
        self.scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_scopes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scopes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.scopes
    }

    // Take field
    pub fn take_scopes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.scopes, ::protobuf::RepeatedField::new())
    }

    pub fn get_scopes(&self) -> &[::std::string::String] {
        &self.scopes
    }

    fn get_scopes_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.scopes
    }

    fn mut_scopes_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.scopes
    }
}

impl ::protobuf::Message for ResourceQuotaSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.hard)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.scopes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(1, &self.hard);
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(1, &self.hard, os)?;
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceQuotaSpec {
    fn new() -> ResourceQuotaSpec {
        ResourceQuotaSpec::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceQuotaSpec>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "hard",
                    ResourceQuotaSpec::get_hard_for_reflect,
                    ResourceQuotaSpec::mut_hard_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "scopes",
                    ResourceQuotaSpec::get_scopes_for_reflect,
                    ResourceQuotaSpec::mut_scopes_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceQuotaSpec>(
                    "ResourceQuotaSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceQuotaSpec {
    fn clear(&mut self) {
        self.clear_hard();
        self.clear_scopes();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceQuotaSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceQuotaSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceQuotaStatus {
    // message fields
    pub hard: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    pub used: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceQuotaStatus {}

impl ResourceQuotaStatus {
    pub fn new() -> ResourceQuotaStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceQuotaStatus {
        static mut instance: ::protobuf::lazy::Lazy<ResourceQuotaStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceQuotaStatus,
        };
        unsafe {
            instance.get(ResourceQuotaStatus::new)
        }
    }

    // repeated .k8s.io.api.core.v1.ResourceQuotaStatus.HardEntry hard = 1;

    pub fn clear_hard(&mut self) {
        self.hard.clear();
    }

    // Param is passed by value, moved
    pub fn set_hard(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.hard = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hard(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.hard
    }

    // Take field
    pub fn take_hard(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.hard, ::std::collections::HashMap::new())
    }

    pub fn get_hard(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.hard
    }

    fn get_hard_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.hard
    }

    fn mut_hard_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.hard
    }

    // repeated .k8s.io.api.core.v1.ResourceQuotaStatus.UsedEntry used = 2;

    pub fn clear_used(&mut self) {
        self.used.clear();
    }

    // Param is passed by value, moved
    pub fn set_used(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.used = v;
    }

    // Mutable pointer to the field.
    pub fn mut_used(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.used
    }

    // Take field
    pub fn take_used(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.used, ::std::collections::HashMap::new())
    }

    pub fn get_used(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.used
    }

    fn get_used_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.used
    }

    fn mut_used_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.used
    }
}

impl ::protobuf::Message for ResourceQuotaStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.hard)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.used)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(1, &self.hard);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(2, &self.used);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(1, &self.hard, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(2, &self.used, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceQuotaStatus {
    fn new() -> ResourceQuotaStatus {
        ResourceQuotaStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceQuotaStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "hard",
                    ResourceQuotaStatus::get_hard_for_reflect,
                    ResourceQuotaStatus::mut_hard_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "used",
                    ResourceQuotaStatus::get_used_for_reflect,
                    ResourceQuotaStatus::mut_used_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceQuotaStatus>(
                    "ResourceQuotaStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceQuotaStatus {
    fn clear(&mut self) {
        self.clear_hard();
        self.clear_used();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceQuotaStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceQuotaStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceRequirements {
    // message fields
    pub limits: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    pub requests: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceRequirements {}

impl ResourceRequirements {
    pub fn new() -> ResourceRequirements {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceRequirements {
        static mut instance: ::protobuf::lazy::Lazy<ResourceRequirements> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceRequirements,
        };
        unsafe {
            instance.get(ResourceRequirements::new)
        }
    }

    // repeated .k8s.io.api.core.v1.ResourceRequirements.LimitsEntry limits = 1;

    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limits(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.limits
    }

    // Take field
    pub fn take_limits(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.limits, ::std::collections::HashMap::new())
    }

    pub fn get_limits(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.limits
    }

    fn get_limits_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.limits
    }

    fn mut_limits_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.limits
    }

    // repeated .k8s.io.api.core.v1.ResourceRequirements.RequestsEntry requests = 2;

    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::collections::HashMap<::std::string::String, super::generated::Quantity>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        ::std::mem::replace(&mut self.requests, ::std::collections::HashMap::new())
    }

    pub fn get_requests(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.requests
    }

    fn get_requests_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &self.requests
    }

    fn mut_requests_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::generated::Quantity> {
        &mut self.requests
    }
}

impl ::protobuf::Message for ResourceRequirements {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.limits)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(wire_type, is, &mut self.requests)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(1, &self.limits);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(2, &self.requests);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(1, &self.limits, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(2, &self.requests, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceRequirements {
    fn new() -> ResourceRequirements {
        ResourceRequirements::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceRequirements>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "limits",
                    ResourceRequirements::get_limits_for_reflect,
                    ResourceRequirements::mut_limits_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::generated::Quantity>>(
                    "requests",
                    ResourceRequirements::get_requests_for_reflect,
                    ResourceRequirements::mut_requests_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceRequirements>(
                    "ResourceRequirements",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceRequirements {
    fn clear(&mut self) {
        self.clear_limits();
        self.clear_requests();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceRequirements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceRequirements {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SELinuxOptions {
    // message fields
    user: ::protobuf::SingularField<::std::string::String>,
    role: ::protobuf::SingularField<::std::string::String>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    level: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SELinuxOptions {}

impl SELinuxOptions {
    pub fn new() -> SELinuxOptions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SELinuxOptions {
        static mut instance: ::protobuf::lazy::Lazy<SELinuxOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SELinuxOptions,
        };
        unsafe {
            instance.get(SELinuxOptions::new)
        }
    }

    // optional string user = 1;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_user_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.user
    }

    fn mut_user_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.user
    }

    // optional string role = 2;

    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        if self.role.is_none() {
            self.role.set_default();
        }
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        self.role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_role(&self) -> &str {
        match self.role.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_role_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.role
    }

    fn mut_role_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.role
    }

    // optional string type = 3;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_field_type_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.field_type
    }

    // optional string level = 4;

    pub fn clear_level(&mut self) {
        self.level.clear();
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: ::std::string::String) {
        self.level = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level(&mut self) -> &mut ::std::string::String {
        if self.level.is_none() {
            self.level.set_default();
        }
        self.level.as_mut().unwrap()
    }

    // Take field
    pub fn take_level(&mut self) -> ::std::string::String {
        self.level.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_level(&self) -> &str {
        match self.level.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_level_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.level
    }

    fn mut_level_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.level
    }
}

impl ::protobuf::Message for SELinuxOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.role)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.level)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.role.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.level.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.role.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.level.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SELinuxOptions {
    fn new() -> SELinuxOptions {
        SELinuxOptions::new()
    }

    fn descriptor_static(_: ::std::option::Option<SELinuxOptions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "user",
                    SELinuxOptions::get_user_for_reflect,
                    SELinuxOptions::mut_user_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "role",
                    SELinuxOptions::get_role_for_reflect,
                    SELinuxOptions::mut_role_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    SELinuxOptions::get_field_type_for_reflect,
                    SELinuxOptions::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "level",
                    SELinuxOptions::get_level_for_reflect,
                    SELinuxOptions::mut_level_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SELinuxOptions>(
                    "SELinuxOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SELinuxOptions {
    fn clear(&mut self) {
        self.clear_user();
        self.clear_role();
        self.clear_field_type();
        self.clear_level();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SELinuxOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SELinuxOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScaleIOVolumeSource {
    // message fields
    gateway: ::protobuf::SingularField<::std::string::String>,
    system: ::protobuf::SingularField<::std::string::String>,
    secretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    sslEnabled: ::std::option::Option<bool>,
    protectionDomain: ::protobuf::SingularField<::std::string::String>,
    storagePool: ::protobuf::SingularField<::std::string::String>,
    storageMode: ::protobuf::SingularField<::std::string::String>,
    volumeName: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ScaleIOVolumeSource {}

impl ScaleIOVolumeSource {
    pub fn new() -> ScaleIOVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ScaleIOVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<ScaleIOVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ScaleIOVolumeSource,
        };
        unsafe {
            instance.get(ScaleIOVolumeSource::new)
        }
    }

    // optional string gateway = 1;

    pub fn clear_gateway(&mut self) {
        self.gateway.clear();
    }

    pub fn has_gateway(&self) -> bool {
        self.gateway.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gateway(&mut self, v: ::std::string::String) {
        self.gateway = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway(&mut self) -> &mut ::std::string::String {
        if self.gateway.is_none() {
            self.gateway.set_default();
        }
        self.gateway.as_mut().unwrap()
    }

    // Take field
    pub fn take_gateway(&mut self) -> ::std::string::String {
        self.gateway.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_gateway(&self) -> &str {
        match self.gateway.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_gateway_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.gateway
    }

    fn mut_gateway_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.gateway
    }

    // optional string system = 2;

    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: ::std::string::String) {
        self.system = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut ::std::string::String {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> ::std::string::String {
        self.system.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_system(&self) -> &str {
        match self.system.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_system_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.system
    }

    fn mut_system_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.system
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 3;

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    pub fn get_secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| LocalObjectReference::default_instance())
    }

    fn get_secretRef_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalObjectReference> {
        &self.secretRef
    }

    fn mut_secretRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalObjectReference> {
        &mut self.secretRef
    }

    // optional bool sslEnabled = 4;

    pub fn clear_sslEnabled(&mut self) {
        self.sslEnabled = ::std::option::Option::None;
    }

    pub fn has_sslEnabled(&self) -> bool {
        self.sslEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sslEnabled(&mut self, v: bool) {
        self.sslEnabled = ::std::option::Option::Some(v);
    }

    pub fn get_sslEnabled(&self) -> bool {
        self.sslEnabled.unwrap_or(false)
    }

    fn get_sslEnabled_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.sslEnabled
    }

    fn mut_sslEnabled_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.sslEnabled
    }

    // optional string protectionDomain = 5;

    pub fn clear_protectionDomain(&mut self) {
        self.protectionDomain.clear();
    }

    pub fn has_protectionDomain(&self) -> bool {
        self.protectionDomain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protectionDomain(&mut self, v: ::std::string::String) {
        self.protectionDomain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protectionDomain(&mut self) -> &mut ::std::string::String {
        if self.protectionDomain.is_none() {
            self.protectionDomain.set_default();
        }
        self.protectionDomain.as_mut().unwrap()
    }

    // Take field
    pub fn take_protectionDomain(&mut self) -> ::std::string::String {
        self.protectionDomain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protectionDomain(&self) -> &str {
        match self.protectionDomain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_protectionDomain_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.protectionDomain
    }

    fn mut_protectionDomain_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.protectionDomain
    }

    // optional string storagePool = 6;

    pub fn clear_storagePool(&mut self) {
        self.storagePool.clear();
    }

    pub fn has_storagePool(&self) -> bool {
        self.storagePool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePool(&mut self, v: ::std::string::String) {
        self.storagePool = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePool(&mut self) -> &mut ::std::string::String {
        if self.storagePool.is_none() {
            self.storagePool.set_default();
        }
        self.storagePool.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePool(&mut self) -> ::std::string::String {
        self.storagePool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_storagePool(&self) -> &str {
        match self.storagePool.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_storagePool_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.storagePool
    }

    fn mut_storagePool_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.storagePool
    }

    // optional string storageMode = 7;

    pub fn clear_storageMode(&mut self) {
        self.storageMode.clear();
    }

    pub fn has_storageMode(&self) -> bool {
        self.storageMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageMode(&mut self, v: ::std::string::String) {
        self.storageMode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageMode(&mut self) -> &mut ::std::string::String {
        if self.storageMode.is_none() {
            self.storageMode.set_default();
        }
        self.storageMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageMode(&mut self) -> ::std::string::String {
        self.storageMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_storageMode(&self) -> &str {
        match self.storageMode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_storageMode_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.storageMode
    }

    fn mut_storageMode_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.storageMode
    }

    // optional string volumeName = 8;

    pub fn clear_volumeName(&mut self) {
        self.volumeName.clear();
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName.set_default();
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volumeName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volumeName
    }

    fn mut_volumeName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volumeName
    }

    // optional string fsType = 9;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }

    // optional bool readOnly = 10;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }
}

impl ::protobuf::Message for ScaleIOVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gateway)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.system)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sslEnabled = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protectionDomain)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storagePool)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageMode)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeName)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gateway.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.system.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sslEnabled {
            my_size += 2;
        }
        if let Some(ref v) = self.protectionDomain.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.storagePool.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.storageMode.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gateway.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.system.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.sslEnabled {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.protectionDomain.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.storagePool.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.storageMode.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.volumeName.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ScaleIOVolumeSource {
    fn new() -> ScaleIOVolumeSource {
        ScaleIOVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<ScaleIOVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "gateway",
                    ScaleIOVolumeSource::get_gateway_for_reflect,
                    ScaleIOVolumeSource::mut_gateway_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "system",
                    ScaleIOVolumeSource::get_system_for_reflect,
                    ScaleIOVolumeSource::mut_system_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "secretRef",
                    ScaleIOVolumeSource::get_secretRef_for_reflect,
                    ScaleIOVolumeSource::mut_secretRef_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "sslEnabled",
                    ScaleIOVolumeSource::get_sslEnabled_for_reflect,
                    ScaleIOVolumeSource::mut_sslEnabled_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "protectionDomain",
                    ScaleIOVolumeSource::get_protectionDomain_for_reflect,
                    ScaleIOVolumeSource::mut_protectionDomain_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storagePool",
                    ScaleIOVolumeSource::get_storagePool_for_reflect,
                    ScaleIOVolumeSource::mut_storagePool_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storageMode",
                    ScaleIOVolumeSource::get_storageMode_for_reflect,
                    ScaleIOVolumeSource::mut_storageMode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volumeName",
                    ScaleIOVolumeSource::get_volumeName_for_reflect,
                    ScaleIOVolumeSource::mut_volumeName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    ScaleIOVolumeSource::get_fsType_for_reflect,
                    ScaleIOVolumeSource::mut_fsType_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    ScaleIOVolumeSource::get_readOnly_for_reflect,
                    ScaleIOVolumeSource::mut_readOnly_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ScaleIOVolumeSource>(
                    "ScaleIOVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ScaleIOVolumeSource {
    fn clear(&mut self) {
        self.clear_gateway();
        self.clear_system();
        self.clear_secretRef();
        self.clear_sslEnabled();
        self.clear_protectionDomain();
        self.clear_storagePool();
        self.clear_storageMode();
        self.clear_volumeName();
        self.clear_fsType();
        self.clear_readOnly();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScaleIOVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScaleIOVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Secret {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    pub data: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    pub stringData: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Secret {}

impl Secret {
    pub fn new() -> Secret {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Secret {
        static mut instance: ::protobuf::lazy::Lazy<Secret> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Secret,
        };
        unsafe {
            instance.get(Secret::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.Secret.DataEntry data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.data, ::std::collections::HashMap::new())
    }

    pub fn get_data(&self) -> &::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &self.data
    }

    fn get_data_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &self.data
    }

    fn mut_data_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &mut self.data
    }

    // repeated .k8s.io.api.core.v1.Secret.StringDataEntry stringData = 4;

    pub fn clear_stringData(&mut self) {
        self.stringData.clear();
    }

    // Param is passed by value, moved
    pub fn set_stringData(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.stringData = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stringData(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.stringData
    }

    // Take field
    pub fn take_stringData(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.stringData, ::std::collections::HashMap::new())
    }

    pub fn get_stringData(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.stringData
    }

    fn get_stringData_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.stringData
    }

    fn mut_stringData_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.stringData
    }

    // optional string type = 3;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_field_type_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.field_type
    }
}

impl ::protobuf::Message for Secret {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.data)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.stringData)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(2, &self.data);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.stringData);
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(2, &self.data, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.stringData, os)?;
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Secret {
    fn new() -> Secret {
        Secret::new()
    }

    fn descriptor_static(_: ::std::option::Option<Secret>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    Secret::get_metadata_for_reflect,
                    Secret::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    Secret::get_data_for_reflect,
                    Secret::mut_data_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "stringData",
                    Secret::get_stringData_for_reflect,
                    Secret::mut_stringData_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    Secret::get_field_type_for_reflect,
                    Secret::mut_field_type_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Secret>(
                    "Secret",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Secret {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_data();
        self.clear_stringData();
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Secret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Secret {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretEnvSource {
    // message fields
    localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    optional: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SecretEnvSource {}

impl SecretEnvSource {
    pub fn new() -> SecretEnvSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SecretEnvSource {
        static mut instance: ::protobuf::lazy::Lazy<SecretEnvSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SecretEnvSource,
        };
        unsafe {
            instance.get(SecretEnvSource::new)
        }
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| LocalObjectReference::default_instance())
    }

    fn get_localObjectReference_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalObjectReference> {
        &self.localObjectReference
    }

    fn mut_localObjectReference_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalObjectReference> {
        &mut self.localObjectReference
    }

    // optional bool optional = 2;

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    fn get_optional_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.optional
    }

    fn mut_optional_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.optional
    }
}

impl ::protobuf::Message for SecretEnvSource {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SecretEnvSource {
    fn new() -> SecretEnvSource {
        SecretEnvSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<SecretEnvSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "localObjectReference",
                    SecretEnvSource::get_localObjectReference_for_reflect,
                    SecretEnvSource::mut_localObjectReference_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "optional",
                    SecretEnvSource::get_optional_for_reflect,
                    SecretEnvSource::mut_optional_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SecretEnvSource>(
                    "SecretEnvSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SecretEnvSource {
    fn clear(&mut self) {
        self.clear_localObjectReference();
        self.clear_optional();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretEnvSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretEnvSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretKeySelector {
    // message fields
    localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    key: ::protobuf::SingularField<::std::string::String>,
    optional: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SecretKeySelector {}

impl SecretKeySelector {
    pub fn new() -> SecretKeySelector {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SecretKeySelector {
        static mut instance: ::protobuf::lazy::Lazy<SecretKeySelector> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SecretKeySelector,
        };
        unsafe {
            instance.get(SecretKeySelector::new)
        }
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| LocalObjectReference::default_instance())
    }

    fn get_localObjectReference_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalObjectReference> {
        &self.localObjectReference
    }

    fn mut_localObjectReference_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalObjectReference> {
        &mut self.localObjectReference
    }

    // optional string key = 2;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_key_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.key
    }

    fn mut_key_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.key
    }

    // optional bool optional = 3;

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    fn get_optional_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.optional
    }

    fn mut_optional_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.optional
    }
}

impl ::protobuf::Message for SecretKeySelector {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SecretKeySelector {
    fn new() -> SecretKeySelector {
        SecretKeySelector::new()
    }

    fn descriptor_static(_: ::std::option::Option<SecretKeySelector>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "localObjectReference",
                    SecretKeySelector::get_localObjectReference_for_reflect,
                    SecretKeySelector::mut_localObjectReference_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    SecretKeySelector::get_key_for_reflect,
                    SecretKeySelector::mut_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "optional",
                    SecretKeySelector::get_optional_for_reflect,
                    SecretKeySelector::mut_optional_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SecretKeySelector>(
                    "SecretKeySelector",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SecretKeySelector {
    fn clear(&mut self) {
        self.clear_localObjectReference();
        self.clear_key();
        self.clear_optional();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretKeySelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretKeySelector {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<Secret>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SecretList {}

impl SecretList {
    pub fn new() -> SecretList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SecretList {
        static mut instance: ::protobuf::lazy::Lazy<SecretList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SecretList,
        };
        unsafe {
            instance.get(SecretList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.Secret items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Secret>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Secret> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Secret> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[Secret] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<Secret> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Secret> {
        &mut self.items
    }
}

impl ::protobuf::Message for SecretList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SecretList {
    fn new() -> SecretList {
        SecretList::new()
    }

    fn descriptor_static(_: ::std::option::Option<SecretList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    SecretList::get_metadata_for_reflect,
                    SecretList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret>>(
                    "items",
                    SecretList::get_items_for_reflect,
                    SecretList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SecretList>(
                    "SecretList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SecretList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretProjection {
    // message fields
    localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    items: ::protobuf::RepeatedField<KeyToPath>,
    optional: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SecretProjection {}

impl SecretProjection {
    pub fn new() -> SecretProjection {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SecretProjection {
        static mut instance: ::protobuf::lazy::Lazy<SecretProjection> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SecretProjection,
        };
        unsafe {
            instance.get(SecretProjection::new)
        }
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;

    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| LocalObjectReference::default_instance())
    }

    fn get_localObjectReference_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalObjectReference> {
        &self.localObjectReference
    }

    fn mut_localObjectReference_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalObjectReference> {
        &mut self.localObjectReference
    }

    // repeated .k8s.io.api.core.v1.KeyToPath items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<KeyToPath>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<KeyToPath> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<KeyToPath> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[KeyToPath] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<KeyToPath> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<KeyToPath> {
        &mut self.items
    }

    // optional bool optional = 4;

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    fn get_optional_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.optional
    }

    fn mut_optional_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.optional
    }
}

impl ::protobuf::Message for SecretProjection {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.optional {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SecretProjection {
    fn new() -> SecretProjection {
        SecretProjection::new()
    }

    fn descriptor_static(_: ::std::option::Option<SecretProjection>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "localObjectReference",
                    SecretProjection::get_localObjectReference_for_reflect,
                    SecretProjection::mut_localObjectReference_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyToPath>>(
                    "items",
                    SecretProjection::get_items_for_reflect,
                    SecretProjection::mut_items_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "optional",
                    SecretProjection::get_optional_for_reflect,
                    SecretProjection::mut_optional_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SecretProjection>(
                    "SecretProjection",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SecretProjection {
    fn clear(&mut self) {
        self.clear_localObjectReference();
        self.clear_items();
        self.clear_optional();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretProjection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretVolumeSource {
    // message fields
    secretName: ::protobuf::SingularField<::std::string::String>,
    items: ::protobuf::RepeatedField<KeyToPath>,
    defaultMode: ::std::option::Option<i32>,
    optional: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SecretVolumeSource {}

impl SecretVolumeSource {
    pub fn new() -> SecretVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SecretVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<SecretVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SecretVolumeSource,
        };
        unsafe {
            instance.get(SecretVolumeSource::new)
        }
    }

    // optional string secretName = 1;

    pub fn clear_secretName(&mut self) {
        self.secretName.clear();
    }

    pub fn has_secretName(&self) -> bool {
        self.secretName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretName(&mut self, v: ::std::string::String) {
        self.secretName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretName(&mut self) -> &mut ::std::string::String {
        if self.secretName.is_none() {
            self.secretName.set_default();
        }
        self.secretName.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretName(&mut self) -> ::std::string::String {
        self.secretName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_secretName(&self) -> &str {
        match self.secretName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_secretName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.secretName
    }

    fn mut_secretName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.secretName
    }

    // repeated .k8s.io.api.core.v1.KeyToPath items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<KeyToPath>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<KeyToPath> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<KeyToPath> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[KeyToPath] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<KeyToPath> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<KeyToPath> {
        &mut self.items
    }

    // optional int32 defaultMode = 3;

    pub fn clear_defaultMode(&mut self) {
        self.defaultMode = ::std::option::Option::None;
    }

    pub fn has_defaultMode(&self) -> bool {
        self.defaultMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultMode(&mut self, v: i32) {
        self.defaultMode = ::std::option::Option::Some(v);
    }

    pub fn get_defaultMode(&self) -> i32 {
        self.defaultMode.unwrap_or(0)
    }

    fn get_defaultMode_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.defaultMode
    }

    fn mut_defaultMode_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.defaultMode
    }

    // optional bool optional = 4;

    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }

    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }

    fn get_optional_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.optional
    }

    fn mut_optional_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.optional
    }
}

impl ::protobuf::Message for SecretVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secretName)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.defaultMode = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secretName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.defaultMode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secretName.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.defaultMode {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SecretVolumeSource {
    fn new() -> SecretVolumeSource {
        SecretVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<SecretVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "secretName",
                    SecretVolumeSource::get_secretName_for_reflect,
                    SecretVolumeSource::mut_secretName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyToPath>>(
                    "items",
                    SecretVolumeSource::get_items_for_reflect,
                    SecretVolumeSource::mut_items_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "defaultMode",
                    SecretVolumeSource::get_defaultMode_for_reflect,
                    SecretVolumeSource::mut_defaultMode_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "optional",
                    SecretVolumeSource::get_optional_for_reflect,
                    SecretVolumeSource::mut_optional_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SecretVolumeSource>(
                    "SecretVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SecretVolumeSource {
    fn clear(&mut self) {
        self.clear_secretName();
        self.clear_items();
        self.clear_defaultMode();
        self.clear_optional();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecurityContext {
    // message fields
    capabilities: ::protobuf::SingularPtrField<Capabilities>,
    privileged: ::std::option::Option<bool>,
    seLinuxOptions: ::protobuf::SingularPtrField<SELinuxOptions>,
    runAsUser: ::std::option::Option<i64>,
    runAsNonRoot: ::std::option::Option<bool>,
    readOnlyRootFilesystem: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SecurityContext {}

impl SecurityContext {
    pub fn new() -> SecurityContext {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SecurityContext {
        static mut instance: ::protobuf::lazy::Lazy<SecurityContext> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SecurityContext,
        };
        unsafe {
            instance.get(SecurityContext::new)
        }
    }

    // optional .k8s.io.api.core.v1.Capabilities capabilities = 1;

    pub fn clear_capabilities(&mut self) {
        self.capabilities.clear();
    }

    pub fn has_capabilities(&self) -> bool {
        self.capabilities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: Capabilities) {
        self.capabilities = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_capabilities(&mut self) -> &mut Capabilities {
        if self.capabilities.is_none() {
            self.capabilities.set_default();
        }
        self.capabilities.as_mut().unwrap()
    }

    // Take field
    pub fn take_capabilities(&mut self) -> Capabilities {
        self.capabilities.take().unwrap_or_else(|| Capabilities::new())
    }

    pub fn get_capabilities(&self) -> &Capabilities {
        self.capabilities.as_ref().unwrap_or_else(|| Capabilities::default_instance())
    }

    fn get_capabilities_for_reflect(&self) -> &::protobuf::SingularPtrField<Capabilities> {
        &self.capabilities
    }

    fn mut_capabilities_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<Capabilities> {
        &mut self.capabilities
    }

    // optional bool privileged = 2;

    pub fn clear_privileged(&mut self) {
        self.privileged = ::std::option::Option::None;
    }

    pub fn has_privileged(&self) -> bool {
        self.privileged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privileged(&mut self, v: bool) {
        self.privileged = ::std::option::Option::Some(v);
    }

    pub fn get_privileged(&self) -> bool {
        self.privileged.unwrap_or(false)
    }

    fn get_privileged_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.privileged
    }

    fn mut_privileged_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.privileged
    }

    // optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 3;

    pub fn clear_seLinuxOptions(&mut self) {
        self.seLinuxOptions.clear();
    }

    pub fn has_seLinuxOptions(&self) -> bool {
        self.seLinuxOptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seLinuxOptions(&mut self, v: SELinuxOptions) {
        self.seLinuxOptions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seLinuxOptions(&mut self) -> &mut SELinuxOptions {
        if self.seLinuxOptions.is_none() {
            self.seLinuxOptions.set_default();
        }
        self.seLinuxOptions.as_mut().unwrap()
    }

    // Take field
    pub fn take_seLinuxOptions(&mut self) -> SELinuxOptions {
        self.seLinuxOptions.take().unwrap_or_else(|| SELinuxOptions::new())
    }

    pub fn get_seLinuxOptions(&self) -> &SELinuxOptions {
        self.seLinuxOptions.as_ref().unwrap_or_else(|| SELinuxOptions::default_instance())
    }

    fn get_seLinuxOptions_for_reflect(&self) -> &::protobuf::SingularPtrField<SELinuxOptions> {
        &self.seLinuxOptions
    }

    fn mut_seLinuxOptions_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<SELinuxOptions> {
        &mut self.seLinuxOptions
    }

    // optional int64 runAsUser = 4;

    pub fn clear_runAsUser(&mut self) {
        self.runAsUser = ::std::option::Option::None;
    }

    pub fn has_runAsUser(&self) -> bool {
        self.runAsUser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsUser(&mut self, v: i64) {
        self.runAsUser = ::std::option::Option::Some(v);
    }

    pub fn get_runAsUser(&self) -> i64 {
        self.runAsUser.unwrap_or(0)
    }

    fn get_runAsUser_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.runAsUser
    }

    fn mut_runAsUser_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.runAsUser
    }

    // optional bool runAsNonRoot = 5;

    pub fn clear_runAsNonRoot(&mut self) {
        self.runAsNonRoot = ::std::option::Option::None;
    }

    pub fn has_runAsNonRoot(&self) -> bool {
        self.runAsNonRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsNonRoot(&mut self, v: bool) {
        self.runAsNonRoot = ::std::option::Option::Some(v);
    }

    pub fn get_runAsNonRoot(&self) -> bool {
        self.runAsNonRoot.unwrap_or(false)
    }

    fn get_runAsNonRoot_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.runAsNonRoot
    }

    fn mut_runAsNonRoot_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.runAsNonRoot
    }

    // optional bool readOnlyRootFilesystem = 6;

    pub fn clear_readOnlyRootFilesystem(&mut self) {
        self.readOnlyRootFilesystem = ::std::option::Option::None;
    }

    pub fn has_readOnlyRootFilesystem(&self) -> bool {
        self.readOnlyRootFilesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnlyRootFilesystem(&mut self, v: bool) {
        self.readOnlyRootFilesystem = ::std::option::Option::Some(v);
    }

    pub fn get_readOnlyRootFilesystem(&self) -> bool {
        self.readOnlyRootFilesystem.unwrap_or(false)
    }

    fn get_readOnlyRootFilesystem_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnlyRootFilesystem
    }

    fn mut_readOnlyRootFilesystem_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnlyRootFilesystem
    }
}

impl ::protobuf::Message for SecurityContext {
    fn is_initialized(&self) -> bool {
        for v in &self.capabilities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.seLinuxOptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.capabilities)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.privileged = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.seLinuxOptions)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.runAsUser = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.runAsNonRoot = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnlyRootFilesystem = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.privileged {
            my_size += 2;
        }
        if let Some(ref v) = self.seLinuxOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.runAsUser {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.runAsNonRoot {
            my_size += 2;
        }
        if let Some(v) = self.readOnlyRootFilesystem {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.capabilities.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.privileged {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.seLinuxOptions.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.runAsUser {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.runAsNonRoot {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.readOnlyRootFilesystem {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SecurityContext {
    fn new() -> SecurityContext {
        SecurityContext::new()
    }

    fn descriptor_static(_: ::std::option::Option<SecurityContext>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Capabilities>>(
                    "capabilities",
                    SecurityContext::get_capabilities_for_reflect,
                    SecurityContext::mut_capabilities_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "privileged",
                    SecurityContext::get_privileged_for_reflect,
                    SecurityContext::mut_privileged_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SELinuxOptions>>(
                    "seLinuxOptions",
                    SecurityContext::get_seLinuxOptions_for_reflect,
                    SecurityContext::mut_seLinuxOptions_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "runAsUser",
                    SecurityContext::get_runAsUser_for_reflect,
                    SecurityContext::mut_runAsUser_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "runAsNonRoot",
                    SecurityContext::get_runAsNonRoot_for_reflect,
                    SecurityContext::mut_runAsNonRoot_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnlyRootFilesystem",
                    SecurityContext::get_readOnlyRootFilesystem_for_reflect,
                    SecurityContext::mut_readOnlyRootFilesystem_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SecurityContext>(
                    "SecurityContext",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SecurityContext {
    fn clear(&mut self) {
        self.clear_capabilities();
        self.clear_privileged();
        self.clear_seLinuxOptions();
        self.clear_runAsUser();
        self.clear_runAsNonRoot();
        self.clear_readOnlyRootFilesystem();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecurityContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurityContext {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SerializedReference {
    // message fields
    reference: ::protobuf::SingularPtrField<ObjectReference>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SerializedReference {}

impl SerializedReference {
    pub fn new() -> SerializedReference {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SerializedReference {
        static mut instance: ::protobuf::lazy::Lazy<SerializedReference> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SerializedReference,
        };
        unsafe {
            instance.get(SerializedReference::new)
        }
    }

    // optional .k8s.io.api.core.v1.ObjectReference reference = 1;

    pub fn clear_reference(&mut self) {
        self.reference.clear();
    }

    pub fn has_reference(&self) -> bool {
        self.reference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference(&mut self, v: ObjectReference) {
        self.reference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reference(&mut self) -> &mut ObjectReference {
        if self.reference.is_none() {
            self.reference.set_default();
        }
        self.reference.as_mut().unwrap()
    }

    // Take field
    pub fn take_reference(&mut self) -> ObjectReference {
        self.reference.take().unwrap_or_else(|| ObjectReference::new())
    }

    pub fn get_reference(&self) -> &ObjectReference {
        self.reference.as_ref().unwrap_or_else(|| ObjectReference::default_instance())
    }

    fn get_reference_for_reflect(&self) -> &::protobuf::SingularPtrField<ObjectReference> {
        &self.reference
    }

    fn mut_reference_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ObjectReference> {
        &mut self.reference
    }
}

impl ::protobuf::Message for SerializedReference {
    fn is_initialized(&self) -> bool {
        for v in &self.reference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reference)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SerializedReference {
    fn new() -> SerializedReference {
        SerializedReference::new()
    }

    fn descriptor_static(_: ::std::option::Option<SerializedReference>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                    "reference",
                    SerializedReference::get_reference_for_reflect,
                    SerializedReference::mut_reference_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SerializedReference>(
                    "SerializedReference",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SerializedReference {
    fn clear(&mut self) {
        self.clear_reference();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SerializedReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SerializedReference {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Service {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    spec: ::protobuf::SingularPtrField<ServiceSpec>,
    status: ::protobuf::SingularPtrField<ServiceStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Service {}

impl Service {
    pub fn new() -> Service {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Service {
        static mut instance: ::protobuf::lazy::Lazy<Service> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Service,
        };
        unsafe {
            instance.get(Service::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // optional .k8s.io.api.core.v1.ServiceSpec spec = 2;

    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ServiceSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ServiceSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> ServiceSpec {
        self.spec.take().unwrap_or_else(|| ServiceSpec::new())
    }

    pub fn get_spec(&self) -> &ServiceSpec {
        self.spec.as_ref().unwrap_or_else(|| ServiceSpec::default_instance())
    }

    fn get_spec_for_reflect(&self) -> &::protobuf::SingularPtrField<ServiceSpec> {
        &self.spec
    }

    fn mut_spec_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ServiceSpec> {
        &mut self.spec
    }

    // optional .k8s.io.api.core.v1.ServiceStatus status = 3;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ServiceStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ServiceStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ServiceStatus {
        self.status.take().unwrap_or_else(|| ServiceStatus::new())
    }

    pub fn get_status(&self) -> &ServiceStatus {
        self.status.as_ref().unwrap_or_else(|| ServiceStatus::default_instance())
    }

    fn get_status_for_reflect(&self) -> &::protobuf::SingularPtrField<ServiceStatus> {
        &self.status
    }

    fn mut_status_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ServiceStatus> {
        &mut self.status
    }
}

impl ::protobuf::Message for Service {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Service {
    fn new() -> Service {
        Service::new()
    }

    fn descriptor_static(_: ::std::option::Option<Service>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    Service::get_metadata_for_reflect,
                    Service::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServiceSpec>>(
                    "spec",
                    Service::get_spec_for_reflect,
                    Service::mut_spec_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServiceStatus>>(
                    "status",
                    Service::get_status_for_reflect,
                    Service::mut_status_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Service>(
                    "Service",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Service {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_spec();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Service {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceAccount {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ObjectMeta>,
    secrets: ::protobuf::RepeatedField<ObjectReference>,
    imagePullSecrets: ::protobuf::RepeatedField<LocalObjectReference>,
    automountServiceAccountToken: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ServiceAccount {}

impl ServiceAccount {
    pub fn new() -> ServiceAccount {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ServiceAccount {
        static mut instance: ::protobuf::lazy::Lazy<ServiceAccount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServiceAccount,
        };
        unsafe {
            instance.get(ServiceAccount::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ObjectMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ObjectMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ObjectMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.ObjectReference secrets = 2;

    pub fn clear_secrets(&mut self) {
        self.secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_secrets(&mut self, v: ::protobuf::RepeatedField<ObjectReference>) {
        self.secrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_secrets(&mut self) -> &mut ::protobuf::RepeatedField<ObjectReference> {
        &mut self.secrets
    }

    // Take field
    pub fn take_secrets(&mut self) -> ::protobuf::RepeatedField<ObjectReference> {
        ::std::mem::replace(&mut self.secrets, ::protobuf::RepeatedField::new())
    }

    pub fn get_secrets(&self) -> &[ObjectReference] {
        &self.secrets
    }

    fn get_secrets_for_reflect(&self) -> &::protobuf::RepeatedField<ObjectReference> {
        &self.secrets
    }

    fn mut_secrets_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ObjectReference> {
        &mut self.secrets
    }

    // repeated .k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 3;

    pub fn clear_imagePullSecrets(&mut self) {
        self.imagePullSecrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_imagePullSecrets(&mut self, v: ::protobuf::RepeatedField<LocalObjectReference>) {
        self.imagePullSecrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_imagePullSecrets(&mut self) -> &mut ::protobuf::RepeatedField<LocalObjectReference> {
        &mut self.imagePullSecrets
    }

    // Take field
    pub fn take_imagePullSecrets(&mut self) -> ::protobuf::RepeatedField<LocalObjectReference> {
        ::std::mem::replace(&mut self.imagePullSecrets, ::protobuf::RepeatedField::new())
    }

    pub fn get_imagePullSecrets(&self) -> &[LocalObjectReference] {
        &self.imagePullSecrets
    }

    fn get_imagePullSecrets_for_reflect(&self) -> &::protobuf::RepeatedField<LocalObjectReference> {
        &self.imagePullSecrets
    }

    fn mut_imagePullSecrets_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<LocalObjectReference> {
        &mut self.imagePullSecrets
    }

    // optional bool automountServiceAccountToken = 4;

    pub fn clear_automountServiceAccountToken(&mut self) {
        self.automountServiceAccountToken = ::std::option::Option::None;
    }

    pub fn has_automountServiceAccountToken(&self) -> bool {
        self.automountServiceAccountToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_automountServiceAccountToken(&mut self, v: bool) {
        self.automountServiceAccountToken = ::std::option::Option::Some(v);
    }

    pub fn get_automountServiceAccountToken(&self) -> bool {
        self.automountServiceAccountToken.unwrap_or(false)
    }

    fn get_automountServiceAccountToken_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.automountServiceAccountToken
    }

    fn mut_automountServiceAccountToken_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.automountServiceAccountToken
    }
}

impl ::protobuf::Message for ServiceAccount {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secrets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.imagePullSecrets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.secrets)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.imagePullSecrets)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.automountServiceAccountToken = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.secrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.imagePullSecrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.automountServiceAccountToken {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.secrets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.imagePullSecrets {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.automountServiceAccountToken {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ServiceAccount {
    fn new() -> ServiceAccount {
        ServiceAccount::new()
    }

    fn descriptor_static(_: ::std::option::Option<ServiceAccount>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectMeta>>(
                    "metadata",
                    ServiceAccount::get_metadata_for_reflect,
                    ServiceAccount::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                    "secrets",
                    ServiceAccount::get_secrets_for_reflect,
                    ServiceAccount::mut_secrets_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "imagePullSecrets",
                    ServiceAccount::get_imagePullSecrets_for_reflect,
                    ServiceAccount::mut_imagePullSecrets_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "automountServiceAccountToken",
                    ServiceAccount::get_automountServiceAccountToken_for_reflect,
                    ServiceAccount::mut_automountServiceAccountToken_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServiceAccount>(
                    "ServiceAccount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ServiceAccount {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_secrets();
        self.clear_imagePullSecrets();
        self.clear_automountServiceAccountToken();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceAccountList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<ServiceAccount>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ServiceAccountList {}

impl ServiceAccountList {
    pub fn new() -> ServiceAccountList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ServiceAccountList {
        static mut instance: ::protobuf::lazy::Lazy<ServiceAccountList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServiceAccountList,
        };
        unsafe {
            instance.get(ServiceAccountList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.ServiceAccount items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ServiceAccount>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ServiceAccount> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ServiceAccount> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[ServiceAccount] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<ServiceAccount> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ServiceAccount> {
        &mut self.items
    }
}

impl ::protobuf::Message for ServiceAccountList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ServiceAccountList {
    fn new() -> ServiceAccountList {
        ServiceAccountList::new()
    }

    fn descriptor_static(_: ::std::option::Option<ServiceAccountList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    ServiceAccountList::get_metadata_for_reflect,
                    ServiceAccountList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServiceAccount>>(
                    "items",
                    ServiceAccountList::get_items_for_reflect,
                    ServiceAccountList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServiceAccountList>(
                    "ServiceAccountList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ServiceAccountList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceAccountList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceAccountList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceList {
    // message fields
    metadata: ::protobuf::SingularPtrField<super::generated::ListMeta>,
    items: ::protobuf::RepeatedField<Service>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ServiceList {}

impl ServiceList {
    pub fn new() -> ServiceList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ServiceList {
        static mut instance: ::protobuf::lazy::Lazy<ServiceList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServiceList,
        };
        unsafe {
            instance.get(ServiceList::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::generated::ListMeta::new())
    }

    pub fn get_metadata(&self) -> &super::generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| super::generated::ListMeta::default_instance())
    }

    fn get_metadata_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::ListMeta> {
        &self.metadata
    }

    fn mut_metadata_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::ListMeta> {
        &mut self.metadata
    }

    // repeated .k8s.io.api.core.v1.Service items = 2;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Service>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Service> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Service> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[Service] {
        &self.items
    }

    fn get_items_for_reflect(&self) -> &::protobuf::RepeatedField<Service> {
        &self.items
    }

    fn mut_items_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<Service> {
        &mut self.items
    }
}

impl ::protobuf::Message for ServiceList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ServiceList {
    fn new() -> ServiceList {
        ServiceList::new()
    }

    fn descriptor_static(_: ::std::option::Option<ServiceList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ListMeta>>(
                    "metadata",
                    ServiceList::get_metadata_for_reflect,
                    ServiceList::mut_metadata_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                    "items",
                    ServiceList::get_items_for_reflect,
                    ServiceList::mut_items_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServiceList>(
                    "ServiceList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ServiceList {
    fn clear(&mut self) {
        self.clear_metadata();
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServicePort {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    targetPort: ::protobuf::SingularPtrField<super::generated::IntOrString>,
    nodePort: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ServicePort {}

impl ServicePort {
    pub fn new() -> ServicePort {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ServicePort {
        static mut instance: ::protobuf::lazy::Lazy<ServicePort> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServicePort,
        };
        unsafe {
            instance.get(ServicePort::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string protocol = 2;

    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_protocol_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.protocol
    }

    fn mut_protocol_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.protocol
    }

    // optional int32 port = 3;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    fn get_port_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.port
    }

    fn mut_port_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.port
    }

    // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString targetPort = 4;

    pub fn clear_targetPort(&mut self) {
        self.targetPort.clear();
    }

    pub fn has_targetPort(&self) -> bool {
        self.targetPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPort(&mut self, v: super::generated::IntOrString) {
        self.targetPort = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPort(&mut self) -> &mut super::generated::IntOrString {
        if self.targetPort.is_none() {
            self.targetPort.set_default();
        }
        self.targetPort.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPort(&mut self) -> super::generated::IntOrString {
        self.targetPort.take().unwrap_or_else(|| super::generated::IntOrString::new())
    }

    pub fn get_targetPort(&self) -> &super::generated::IntOrString {
        self.targetPort.as_ref().unwrap_or_else(|| super::generated::IntOrString::default_instance())
    }

    fn get_targetPort_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::IntOrString> {
        &self.targetPort
    }

    fn mut_targetPort_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::IntOrString> {
        &mut self.targetPort
    }

    // optional int32 nodePort = 5;

    pub fn clear_nodePort(&mut self) {
        self.nodePort = ::std::option::Option::None;
    }

    pub fn has_nodePort(&self) -> bool {
        self.nodePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodePort(&mut self, v: i32) {
        self.nodePort = ::std::option::Option::Some(v);
    }

    pub fn get_nodePort(&self) -> i32 {
        self.nodePort.unwrap_or(0)
    }

    fn get_nodePort_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.nodePort
    }

    fn mut_nodePort_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.nodePort
    }
}

impl ::protobuf::Message for ServicePort {
    fn is_initialized(&self) -> bool {
        for v in &self.targetPort {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.targetPort)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nodePort = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.targetPort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.nodePort {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.targetPort.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.nodePort {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ServicePort {
    fn new() -> ServicePort {
        ServicePort::new()
    }

    fn descriptor_static(_: ::std::option::Option<ServicePort>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    ServicePort::get_name_for_reflect,
                    ServicePort::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "protocol",
                    ServicePort::get_protocol_for_reflect,
                    ServicePort::mut_protocol_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "port",
                    ServicePort::get_port_for_reflect,
                    ServicePort::mut_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::IntOrString>>(
                    "targetPort",
                    ServicePort::get_targetPort_for_reflect,
                    ServicePort::mut_targetPort_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "nodePort",
                    ServicePort::get_nodePort_for_reflect,
                    ServicePort::mut_nodePort_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServicePort>(
                    "ServicePort",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ServicePort {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_protocol();
        self.clear_port();
        self.clear_targetPort();
        self.clear_nodePort();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePort {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceProxyOptions {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ServiceProxyOptions {}

impl ServiceProxyOptions {
    pub fn new() -> ServiceProxyOptions {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ServiceProxyOptions {
        static mut instance: ::protobuf::lazy::Lazy<ServiceProxyOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServiceProxyOptions,
        };
        unsafe {
            instance.get(ServiceProxyOptions::new)
        }
    }

    // optional string path = 1;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_path_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.path
    }

    fn mut_path_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.path
    }
}

impl ::protobuf::Message for ServiceProxyOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ServiceProxyOptions {
    fn new() -> ServiceProxyOptions {
        ServiceProxyOptions::new()
    }

    fn descriptor_static(_: ::std::option::Option<ServiceProxyOptions>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "path",
                    ServiceProxyOptions::get_path_for_reflect,
                    ServiceProxyOptions::mut_path_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServiceProxyOptions>(
                    "ServiceProxyOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ServiceProxyOptions {
    fn clear(&mut self) {
        self.clear_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceProxyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceProxyOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceSpec {
    // message fields
    ports: ::protobuf::RepeatedField<ServicePort>,
    pub selector: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    clusterIP: ::protobuf::SingularField<::std::string::String>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    externalIPs: ::protobuf::RepeatedField<::std::string::String>,
    sessionAffinity: ::protobuf::SingularField<::std::string::String>,
    loadBalancerIP: ::protobuf::SingularField<::std::string::String>,
    loadBalancerSourceRanges: ::protobuf::RepeatedField<::std::string::String>,
    externalName: ::protobuf::SingularField<::std::string::String>,
    externalTrafficPolicy: ::protobuf::SingularField<::std::string::String>,
    healthCheckNodePort: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ServiceSpec {}

impl ServiceSpec {
    pub fn new() -> ServiceSpec {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ServiceSpec {
        static mut instance: ::protobuf::lazy::Lazy<ServiceSpec> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServiceSpec,
        };
        unsafe {
            instance.get(ServiceSpec::new)
        }
    }

    // repeated .k8s.io.api.core.v1.ServicePort ports = 1;

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::protobuf::RepeatedField<ServicePort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::protobuf::RepeatedField<ServicePort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::protobuf::RepeatedField<ServicePort> {
        ::std::mem::replace(&mut self.ports, ::protobuf::RepeatedField::new())
    }

    pub fn get_ports(&self) -> &[ServicePort] {
        &self.ports
    }

    fn get_ports_for_reflect(&self) -> &::protobuf::RepeatedField<ServicePort> {
        &self.ports
    }

    fn mut_ports_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<ServicePort> {
        &mut self.ports
    }

    // repeated .k8s.io.api.core.v1.ServiceSpec.SelectorEntry selector = 2;

    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.selector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selector(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.selector
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.selector, ::std::collections::HashMap::new())
    }

    pub fn get_selector(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.selector
    }

    fn get_selector_for_reflect(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.selector
    }

    fn mut_selector_for_reflect(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.selector
    }

    // optional string clusterIP = 3;

    pub fn clear_clusterIP(&mut self) {
        self.clusterIP.clear();
    }

    pub fn has_clusterIP(&self) -> bool {
        self.clusterIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clusterIP(&mut self, v: ::std::string::String) {
        self.clusterIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clusterIP(&mut self) -> &mut ::std::string::String {
        if self.clusterIP.is_none() {
            self.clusterIP.set_default();
        }
        self.clusterIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_clusterIP(&mut self) -> ::std::string::String {
        self.clusterIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clusterIP(&self) -> &str {
        match self.clusterIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_clusterIP_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.clusterIP
    }

    fn mut_clusterIP_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.clusterIP
    }

    // optional string type = 4;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_field_type_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.field_type
    }

    fn mut_field_type_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.field_type
    }

    // repeated string externalIPs = 5;

    pub fn clear_externalIPs(&mut self) {
        self.externalIPs.clear();
    }

    // Param is passed by value, moved
    pub fn set_externalIPs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.externalIPs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_externalIPs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.externalIPs
    }

    // Take field
    pub fn take_externalIPs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.externalIPs, ::protobuf::RepeatedField::new())
    }

    pub fn get_externalIPs(&self) -> &[::std::string::String] {
        &self.externalIPs
    }

    fn get_externalIPs_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.externalIPs
    }

    fn mut_externalIPs_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.externalIPs
    }

    // optional string sessionAffinity = 7;

    pub fn clear_sessionAffinity(&mut self) {
        self.sessionAffinity.clear();
    }

    pub fn has_sessionAffinity(&self) -> bool {
        self.sessionAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionAffinity(&mut self, v: ::std::string::String) {
        self.sessionAffinity = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sessionAffinity(&mut self) -> &mut ::std::string::String {
        if self.sessionAffinity.is_none() {
            self.sessionAffinity.set_default();
        }
        self.sessionAffinity.as_mut().unwrap()
    }

    // Take field
    pub fn take_sessionAffinity(&mut self) -> ::std::string::String {
        self.sessionAffinity.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_sessionAffinity(&self) -> &str {
        match self.sessionAffinity.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_sessionAffinity_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.sessionAffinity
    }

    fn mut_sessionAffinity_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.sessionAffinity
    }

    // optional string loadBalancerIP = 8;

    pub fn clear_loadBalancerIP(&mut self) {
        self.loadBalancerIP.clear();
    }

    pub fn has_loadBalancerIP(&self) -> bool {
        self.loadBalancerIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadBalancerIP(&mut self, v: ::std::string::String) {
        self.loadBalancerIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadBalancerIP(&mut self) -> &mut ::std::string::String {
        if self.loadBalancerIP.is_none() {
            self.loadBalancerIP.set_default();
        }
        self.loadBalancerIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadBalancerIP(&mut self) -> ::std::string::String {
        self.loadBalancerIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_loadBalancerIP(&self) -> &str {
        match self.loadBalancerIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_loadBalancerIP_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.loadBalancerIP
    }

    fn mut_loadBalancerIP_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.loadBalancerIP
    }

    // repeated string loadBalancerSourceRanges = 9;

    pub fn clear_loadBalancerSourceRanges(&mut self) {
        self.loadBalancerSourceRanges.clear();
    }

    // Param is passed by value, moved
    pub fn set_loadBalancerSourceRanges(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.loadBalancerSourceRanges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_loadBalancerSourceRanges(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.loadBalancerSourceRanges
    }

    // Take field
    pub fn take_loadBalancerSourceRanges(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.loadBalancerSourceRanges, ::protobuf::RepeatedField::new())
    }

    pub fn get_loadBalancerSourceRanges(&self) -> &[::std::string::String] {
        &self.loadBalancerSourceRanges
    }

    fn get_loadBalancerSourceRanges_for_reflect(&self) -> &::protobuf::RepeatedField<::std::string::String> {
        &self.loadBalancerSourceRanges
    }

    fn mut_loadBalancerSourceRanges_for_reflect(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.loadBalancerSourceRanges
    }

    // optional string externalName = 10;

    pub fn clear_externalName(&mut self) {
        self.externalName.clear();
    }

    pub fn has_externalName(&self) -> bool {
        self.externalName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalName(&mut self, v: ::std::string::String) {
        self.externalName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_externalName(&mut self) -> &mut ::std::string::String {
        if self.externalName.is_none() {
            self.externalName.set_default();
        }
        self.externalName.as_mut().unwrap()
    }

    // Take field
    pub fn take_externalName(&mut self) -> ::std::string::String {
        self.externalName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_externalName(&self) -> &str {
        match self.externalName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_externalName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.externalName
    }

    fn mut_externalName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.externalName
    }

    // optional string externalTrafficPolicy = 11;

    pub fn clear_externalTrafficPolicy(&mut self) {
        self.externalTrafficPolicy.clear();
    }

    pub fn has_externalTrafficPolicy(&self) -> bool {
        self.externalTrafficPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalTrafficPolicy(&mut self, v: ::std::string::String) {
        self.externalTrafficPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_externalTrafficPolicy(&mut self) -> &mut ::std::string::String {
        if self.externalTrafficPolicy.is_none() {
            self.externalTrafficPolicy.set_default();
        }
        self.externalTrafficPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_externalTrafficPolicy(&mut self) -> ::std::string::String {
        self.externalTrafficPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_externalTrafficPolicy(&self) -> &str {
        match self.externalTrafficPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_externalTrafficPolicy_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.externalTrafficPolicy
    }

    fn mut_externalTrafficPolicy_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.externalTrafficPolicy
    }

    // optional int32 healthCheckNodePort = 12;

    pub fn clear_healthCheckNodePort(&mut self) {
        self.healthCheckNodePort = ::std::option::Option::None;
    }

    pub fn has_healthCheckNodePort(&self) -> bool {
        self.healthCheckNodePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthCheckNodePort(&mut self, v: i32) {
        self.healthCheckNodePort = ::std::option::Option::Some(v);
    }

    pub fn get_healthCheckNodePort(&self) -> i32 {
        self.healthCheckNodePort.unwrap_or(0)
    }

    fn get_healthCheckNodePort_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.healthCheckNodePort
    }

    fn mut_healthCheckNodePort_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.healthCheckNodePort
    }
}

impl ::protobuf::Message for ServiceSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.ports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ports)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.selector)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clusterIP)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.externalIPs)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sessionAffinity)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loadBalancerIP)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.loadBalancerSourceRanges)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.externalName)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.externalTrafficPolicy)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.healthCheckNodePort = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.selector);
        if let Some(ref v) = self.clusterIP.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.externalIPs {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(ref v) = self.sessionAffinity.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.loadBalancerIP.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        for value in &self.loadBalancerSourceRanges {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if let Some(ref v) = self.externalName.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.externalTrafficPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.healthCheckNodePort {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ports {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.selector, os)?;
        if let Some(ref v) = self.clusterIP.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.externalIPs {
            os.write_string(5, &v)?;
        };
        if let Some(ref v) = self.sessionAffinity.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.loadBalancerIP.as_ref() {
            os.write_string(8, &v)?;
        }
        for v in &self.loadBalancerSourceRanges {
            os.write_string(9, &v)?;
        };
        if let Some(ref v) = self.externalName.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.externalTrafficPolicy.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.healthCheckNodePort {
            os.write_int32(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ServiceSpec {
    fn new() -> ServiceSpec {
        ServiceSpec::new()
    }

    fn descriptor_static(_: ::std::option::Option<ServiceSpec>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePort>>(
                    "ports",
                    ServiceSpec::get_ports_for_reflect,
                    ServiceSpec::mut_ports_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "selector",
                    ServiceSpec::get_selector_for_reflect,
                    ServiceSpec::mut_selector_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "clusterIP",
                    ServiceSpec::get_clusterIP_for_reflect,
                    ServiceSpec::mut_clusterIP_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    ServiceSpec::get_field_type_for_reflect,
                    ServiceSpec::mut_field_type_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "externalIPs",
                    ServiceSpec::get_externalIPs_for_reflect,
                    ServiceSpec::mut_externalIPs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sessionAffinity",
                    ServiceSpec::get_sessionAffinity_for_reflect,
                    ServiceSpec::mut_sessionAffinity_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "loadBalancerIP",
                    ServiceSpec::get_loadBalancerIP_for_reflect,
                    ServiceSpec::mut_loadBalancerIP_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "loadBalancerSourceRanges",
                    ServiceSpec::get_loadBalancerSourceRanges_for_reflect,
                    ServiceSpec::mut_loadBalancerSourceRanges_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "externalName",
                    ServiceSpec::get_externalName_for_reflect,
                    ServiceSpec::mut_externalName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "externalTrafficPolicy",
                    ServiceSpec::get_externalTrafficPolicy_for_reflect,
                    ServiceSpec::mut_externalTrafficPolicy_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "healthCheckNodePort",
                    ServiceSpec::get_healthCheckNodePort_for_reflect,
                    ServiceSpec::mut_healthCheckNodePort_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServiceSpec>(
                    "ServiceSpec",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ServiceSpec {
    fn clear(&mut self) {
        self.clear_ports();
        self.clear_selector();
        self.clear_clusterIP();
        self.clear_field_type();
        self.clear_externalIPs();
        self.clear_sessionAffinity();
        self.clear_loadBalancerIP();
        self.clear_loadBalancerSourceRanges();
        self.clear_externalName();
        self.clear_externalTrafficPolicy();
        self.clear_healthCheckNodePort();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceStatus {
    // message fields
    loadBalancer: ::protobuf::SingularPtrField<LoadBalancerStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ServiceStatus {}

impl ServiceStatus {
    pub fn new() -> ServiceStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ServiceStatus {
        static mut instance: ::protobuf::lazy::Lazy<ServiceStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServiceStatus,
        };
        unsafe {
            instance.get(ServiceStatus::new)
        }
    }

    // optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;

    pub fn clear_loadBalancer(&mut self) {
        self.loadBalancer.clear();
    }

    pub fn has_loadBalancer(&self) -> bool {
        self.loadBalancer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadBalancer(&mut self, v: LoadBalancerStatus) {
        self.loadBalancer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadBalancer(&mut self) -> &mut LoadBalancerStatus {
        if self.loadBalancer.is_none() {
            self.loadBalancer.set_default();
        }
        self.loadBalancer.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadBalancer(&mut self) -> LoadBalancerStatus {
        self.loadBalancer.take().unwrap_or_else(|| LoadBalancerStatus::new())
    }

    pub fn get_loadBalancer(&self) -> &LoadBalancerStatus {
        self.loadBalancer.as_ref().unwrap_or_else(|| LoadBalancerStatus::default_instance())
    }

    fn get_loadBalancer_for_reflect(&self) -> &::protobuf::SingularPtrField<LoadBalancerStatus> {
        &self.loadBalancer
    }

    fn mut_loadBalancer_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LoadBalancerStatus> {
        &mut self.loadBalancer
    }
}

impl ::protobuf::Message for ServiceStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.loadBalancer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loadBalancer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.loadBalancer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.loadBalancer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ServiceStatus {
    fn new() -> ServiceStatus {
        ServiceStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<ServiceStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadBalancerStatus>>(
                    "loadBalancer",
                    ServiceStatus::get_loadBalancer_for_reflect,
                    ServiceStatus::mut_loadBalancer_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServiceStatus>(
                    "ServiceStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ServiceStatus {
    fn clear(&mut self) {
        self.clear_loadBalancer();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageOSPersistentVolumeSource {
    // message fields
    volumeName: ::protobuf::SingularField<::std::string::String>,
    volumeNamespace: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    secretRef: ::protobuf::SingularPtrField<ObjectReference>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for StorageOSPersistentVolumeSource {}

impl StorageOSPersistentVolumeSource {
    pub fn new() -> StorageOSPersistentVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static StorageOSPersistentVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<StorageOSPersistentVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageOSPersistentVolumeSource,
        };
        unsafe {
            instance.get(StorageOSPersistentVolumeSource::new)
        }
    }

    // optional string volumeName = 1;

    pub fn clear_volumeName(&mut self) {
        self.volumeName.clear();
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName.set_default();
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volumeName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volumeName
    }

    fn mut_volumeName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volumeName
    }

    // optional string volumeNamespace = 2;

    pub fn clear_volumeNamespace(&mut self) {
        self.volumeNamespace.clear();
    }

    pub fn has_volumeNamespace(&self) -> bool {
        self.volumeNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeNamespace(&mut self, v: ::std::string::String) {
        self.volumeNamespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeNamespace(&mut self) -> &mut ::std::string::String {
        if self.volumeNamespace.is_none() {
            self.volumeNamespace.set_default();
        }
        self.volumeNamespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeNamespace(&mut self) -> ::std::string::String {
        self.volumeNamespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volumeNamespace(&self) -> &str {
        match self.volumeNamespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volumeNamespace_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volumeNamespace
    }

    fn mut_volumeNamespace_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volumeNamespace
    }

    // optional string fsType = 3;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }

    // optional bool readOnly = 4;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }

    // optional .k8s.io.api.core.v1.ObjectReference secretRef = 5;

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: ObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut ObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> ObjectReference {
        self.secretRef.take().unwrap_or_else(|| ObjectReference::new())
    }

    pub fn get_secretRef(&self) -> &ObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| ObjectReference::default_instance())
    }

    fn get_secretRef_for_reflect(&self) -> &::protobuf::SingularPtrField<ObjectReference> {
        &self.secretRef
    }

    fn mut_secretRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ObjectReference> {
        &mut self.secretRef
    }
}

impl ::protobuf::Message for StorageOSPersistentVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeNamespace)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.volumeNamespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumeName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.volumeNamespace.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for StorageOSPersistentVolumeSource {
    fn new() -> StorageOSPersistentVolumeSource {
        StorageOSPersistentVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<StorageOSPersistentVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volumeName",
                    StorageOSPersistentVolumeSource::get_volumeName_for_reflect,
                    StorageOSPersistentVolumeSource::mut_volumeName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volumeNamespace",
                    StorageOSPersistentVolumeSource::get_volumeNamespace_for_reflect,
                    StorageOSPersistentVolumeSource::mut_volumeNamespace_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    StorageOSPersistentVolumeSource::get_fsType_for_reflect,
                    StorageOSPersistentVolumeSource::mut_fsType_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    StorageOSPersistentVolumeSource::get_readOnly_for_reflect,
                    StorageOSPersistentVolumeSource::mut_readOnly_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                    "secretRef",
                    StorageOSPersistentVolumeSource::get_secretRef_for_reflect,
                    StorageOSPersistentVolumeSource::mut_secretRef_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorageOSPersistentVolumeSource>(
                    "StorageOSPersistentVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for StorageOSPersistentVolumeSource {
    fn clear(&mut self) {
        self.clear_volumeName();
        self.clear_volumeNamespace();
        self.clear_fsType();
        self.clear_readOnly();
        self.clear_secretRef();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageOSPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageOSPersistentVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageOSVolumeSource {
    // message fields
    volumeName: ::protobuf::SingularField<::std::string::String>,
    volumeNamespace: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    secretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for StorageOSVolumeSource {}

impl StorageOSVolumeSource {
    pub fn new() -> StorageOSVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static StorageOSVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<StorageOSVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StorageOSVolumeSource,
        };
        unsafe {
            instance.get(StorageOSVolumeSource::new)
        }
    }

    // optional string volumeName = 1;

    pub fn clear_volumeName(&mut self) {
        self.volumeName.clear();
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName.set_default();
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volumeName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volumeName
    }

    fn mut_volumeName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volumeName
    }

    // optional string volumeNamespace = 2;

    pub fn clear_volumeNamespace(&mut self) {
        self.volumeNamespace.clear();
    }

    pub fn has_volumeNamespace(&self) -> bool {
        self.volumeNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeNamespace(&mut self, v: ::std::string::String) {
        self.volumeNamespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeNamespace(&mut self) -> &mut ::std::string::String {
        if self.volumeNamespace.is_none() {
            self.volumeNamespace.set_default();
        }
        self.volumeNamespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeNamespace(&mut self) -> ::std::string::String {
        self.volumeNamespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volumeNamespace(&self) -> &str {
        match self.volumeNamespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volumeNamespace_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volumeNamespace
    }

    fn mut_volumeNamespace_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volumeNamespace
    }

    // optional string fsType = 3;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }

    // optional bool readOnly = 4;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 5;

    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    pub fn get_secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| LocalObjectReference::default_instance())
    }

    fn get_secretRef_for_reflect(&self) -> &::protobuf::SingularPtrField<LocalObjectReference> {
        &self.secretRef
    }

    fn mut_secretRef_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<LocalObjectReference> {
        &mut self.secretRef
    }
}

impl ::protobuf::Message for StorageOSVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeNamespace)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.volumeNamespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumeName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.volumeNamespace.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for StorageOSVolumeSource {
    fn new() -> StorageOSVolumeSource {
        StorageOSVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<StorageOSVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volumeName",
                    StorageOSVolumeSource::get_volumeName_for_reflect,
                    StorageOSVolumeSource::mut_volumeName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volumeNamespace",
                    StorageOSVolumeSource::get_volumeNamespace_for_reflect,
                    StorageOSVolumeSource::mut_volumeNamespace_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    StorageOSVolumeSource::get_fsType_for_reflect,
                    StorageOSVolumeSource::mut_fsType_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    StorageOSVolumeSource::get_readOnly_for_reflect,
                    StorageOSVolumeSource::mut_readOnly_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                    "secretRef",
                    StorageOSVolumeSource::get_secretRef_for_reflect,
                    StorageOSVolumeSource::mut_secretRef_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StorageOSVolumeSource>(
                    "StorageOSVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for StorageOSVolumeSource {
    fn clear(&mut self) {
        self.clear_volumeName();
        self.clear_volumeNamespace();
        self.clear_fsType();
        self.clear_readOnly();
        self.clear_secretRef();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageOSVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageOSVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Sysctl {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Sysctl {}

impl Sysctl {
    pub fn new() -> Sysctl {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Sysctl {
        static mut instance: ::protobuf::lazy::Lazy<Sysctl> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Sysctl,
        };
        unsafe {
            instance.get(Sysctl::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }
}

impl ::protobuf::Message for Sysctl {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Sysctl {
    fn new() -> Sysctl {
        Sysctl::new()
    }

    fn descriptor_static(_: ::std::option::Option<Sysctl>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Sysctl::get_name_for_reflect,
                    Sysctl::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    Sysctl::get_value_for_reflect,
                    Sysctl::mut_value_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Sysctl>(
                    "Sysctl",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Sysctl {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Sysctl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sysctl {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TCPSocketAction {
    // message fields
    port: ::protobuf::SingularPtrField<super::generated::IntOrString>,
    host: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TCPSocketAction {}

impl TCPSocketAction {
    pub fn new() -> TCPSocketAction {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TCPSocketAction {
        static mut instance: ::protobuf::lazy::Lazy<TCPSocketAction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TCPSocketAction,
        };
        unsafe {
            instance.get(TCPSocketAction::new)
        }
    }

    // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 1;

    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: super::generated::IntOrString) {
        self.port = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut super::generated::IntOrString {
        if self.port.is_none() {
            self.port.set_default();
        }
        self.port.as_mut().unwrap()
    }

    // Take field
    pub fn take_port(&mut self) -> super::generated::IntOrString {
        self.port.take().unwrap_or_else(|| super::generated::IntOrString::new())
    }

    pub fn get_port(&self) -> &super::generated::IntOrString {
        self.port.as_ref().unwrap_or_else(|| super::generated::IntOrString::default_instance())
    }

    fn get_port_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::IntOrString> {
        &self.port
    }

    fn mut_port_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::IntOrString> {
        &mut self.port
    }

    // optional string host = 2;

    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host.set_default();
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_host_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.host
    }

    fn mut_host_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.host
    }
}

impl ::protobuf::Message for TCPSocketAction {
    fn is_initialized(&self) -> bool {
        for v in &self.port {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.port)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.port.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.host.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TCPSocketAction {
    fn new() -> TCPSocketAction {
        TCPSocketAction::new()
    }

    fn descriptor_static(_: ::std::option::Option<TCPSocketAction>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::IntOrString>>(
                    "port",
                    TCPSocketAction::get_port_for_reflect,
                    TCPSocketAction::mut_port_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "host",
                    TCPSocketAction::get_host_for_reflect,
                    TCPSocketAction::mut_host_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TCPSocketAction>(
                    "TCPSocketAction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TCPSocketAction {
    fn clear(&mut self) {
        self.clear_port();
        self.clear_host();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TCPSocketAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TCPSocketAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Taint {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    effect: ::protobuf::SingularField<::std::string::String>,
    timeAdded: ::protobuf::SingularPtrField<super::generated::Time>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Taint {}

impl Taint {
    pub fn new() -> Taint {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Taint {
        static mut instance: ::protobuf::lazy::Lazy<Taint> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Taint,
        };
        unsafe {
            instance.get(Taint::new)
        }
    }

    // optional string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_key_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.key
    }

    fn mut_key_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.key
    }

    // optional string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }

    // optional string effect = 3;

    pub fn clear_effect(&mut self) {
        self.effect.clear();
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        if self.effect.is_none() {
            self.effect.set_default();
        }
        self.effect.as_mut().unwrap()
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        self.effect.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_effect(&self) -> &str {
        match self.effect.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_effect_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.effect
    }

    fn mut_effect_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.effect
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time timeAdded = 4;

    pub fn clear_timeAdded(&mut self) {
        self.timeAdded.clear();
    }

    pub fn has_timeAdded(&self) -> bool {
        self.timeAdded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeAdded(&mut self, v: super::generated::Time) {
        self.timeAdded = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeAdded(&mut self) -> &mut super::generated::Time {
        if self.timeAdded.is_none() {
            self.timeAdded.set_default();
        }
        self.timeAdded.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeAdded(&mut self) -> super::generated::Time {
        self.timeAdded.take().unwrap_or_else(|| super::generated::Time::new())
    }

    pub fn get_timeAdded(&self) -> &super::generated::Time {
        self.timeAdded.as_ref().unwrap_or_else(|| super::generated::Time::default_instance())
    }

    fn get_timeAdded_for_reflect(&self) -> &::protobuf::SingularPtrField<super::generated::Time> {
        &self.timeAdded
    }

    fn mut_timeAdded_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<super::generated::Time> {
        &mut self.timeAdded
    }
}

impl ::protobuf::Message for Taint {
    fn is_initialized(&self) -> bool {
        for v in &self.timeAdded {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.effect)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timeAdded)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.effect.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.timeAdded.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.effect.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.timeAdded.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Taint {
    fn new() -> Taint {
        Taint::new()
    }

    fn descriptor_static(_: ::std::option::Option<Taint>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    Taint::get_key_for_reflect,
                    Taint::mut_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    Taint::get_value_for_reflect,
                    Taint::mut_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "effect",
                    Taint::get_effect_for_reflect,
                    Taint::mut_effect_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::Time>>(
                    "timeAdded",
                    Taint::get_timeAdded_for_reflect,
                    Taint::mut_timeAdded_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Taint>(
                    "Taint",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Taint {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.clear_effect();
        self.clear_timeAdded();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Taint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Taint {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Toleration {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    operator: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    effect: ::protobuf::SingularField<::std::string::String>,
    tolerationSeconds: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Toleration {}

impl Toleration {
    pub fn new() -> Toleration {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Toleration {
        static mut instance: ::protobuf::lazy::Lazy<Toleration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Toleration,
        };
        unsafe {
            instance.get(Toleration::new)
        }
    }

    // optional string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_key_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.key
    }

    fn mut_key_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.key
    }

    // optional string operator = 2;

    pub fn clear_operator(&mut self) {
        self.operator.clear();
    }

    pub fn has_operator(&self) -> bool {
        self.operator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operator(&mut self, v: ::std::string::String) {
        self.operator = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator(&mut self) -> &mut ::std::string::String {
        if self.operator.is_none() {
            self.operator.set_default();
        }
        self.operator.as_mut().unwrap()
    }

    // Take field
    pub fn take_operator(&mut self) -> ::std::string::String {
        self.operator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_operator(&self) -> &str {
        match self.operator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_operator_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.operator
    }

    fn mut_operator_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.operator
    }

    // optional string value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_value_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.value
    }

    fn mut_value_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.value
    }

    // optional string effect = 4;

    pub fn clear_effect(&mut self) {
        self.effect.clear();
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        if self.effect.is_none() {
            self.effect.set_default();
        }
        self.effect.as_mut().unwrap()
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        self.effect.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_effect(&self) -> &str {
        match self.effect.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_effect_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.effect
    }

    fn mut_effect_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.effect
    }

    // optional int64 tolerationSeconds = 5;

    pub fn clear_tolerationSeconds(&mut self) {
        self.tolerationSeconds = ::std::option::Option::None;
    }

    pub fn has_tolerationSeconds(&self) -> bool {
        self.tolerationSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tolerationSeconds(&mut self, v: i64) {
        self.tolerationSeconds = ::std::option::Option::Some(v);
    }

    pub fn get_tolerationSeconds(&self) -> i64 {
        self.tolerationSeconds.unwrap_or(0)
    }

    fn get_tolerationSeconds_for_reflect(&self) -> &::std::option::Option<i64> {
        &self.tolerationSeconds
    }

    fn mut_tolerationSeconds_for_reflect(&mut self) -> &mut ::std::option::Option<i64> {
        &mut self.tolerationSeconds
    }
}

impl ::protobuf::Message for Toleration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operator)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.effect)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tolerationSeconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.operator.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.effect.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.tolerationSeconds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.operator.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.effect.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.tolerationSeconds {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Toleration {
    fn new() -> Toleration {
        Toleration::new()
    }

    fn descriptor_static(_: ::std::option::Option<Toleration>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key",
                    Toleration::get_key_for_reflect,
                    Toleration::mut_key_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "operator",
                    Toleration::get_operator_for_reflect,
                    Toleration::mut_operator_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "value",
                    Toleration::get_value_for_reflect,
                    Toleration::mut_value_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "effect",
                    Toleration::get_effect_for_reflect,
                    Toleration::mut_effect_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "tolerationSeconds",
                    Toleration::get_tolerationSeconds_for_reflect,
                    Toleration::mut_tolerationSeconds_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Toleration>(
                    "Toleration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Toleration {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_operator();
        self.clear_value();
        self.clear_effect();
        self.clear_tolerationSeconds();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Toleration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Toleration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Volume {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    volumeSource: ::protobuf::SingularPtrField<VolumeSource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Volume {}

impl Volume {
    pub fn new() -> Volume {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Volume {
        static mut instance: ::protobuf::lazy::Lazy<Volume> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Volume,
        };
        unsafe {
            instance.get(Volume::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional .k8s.io.api.core.v1.VolumeSource volumeSource = 2;

    pub fn clear_volumeSource(&mut self) {
        self.volumeSource.clear();
    }

    pub fn has_volumeSource(&self) -> bool {
        self.volumeSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeSource(&mut self, v: VolumeSource) {
        self.volumeSource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeSource(&mut self) -> &mut VolumeSource {
        if self.volumeSource.is_none() {
            self.volumeSource.set_default();
        }
        self.volumeSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeSource(&mut self) -> VolumeSource {
        self.volumeSource.take().unwrap_or_else(|| VolumeSource::new())
    }

    pub fn get_volumeSource(&self) -> &VolumeSource {
        self.volumeSource.as_ref().unwrap_or_else(|| VolumeSource::default_instance())
    }

    fn get_volumeSource_for_reflect(&self) -> &::protobuf::SingularPtrField<VolumeSource> {
        &self.volumeSource
    }

    fn mut_volumeSource_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<VolumeSource> {
        &mut self.volumeSource
    }
}

impl ::protobuf::Message for Volume {
    fn is_initialized(&self) -> bool {
        for v in &self.volumeSource {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.volumeSource)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.volumeSource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.volumeSource.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Volume {
    fn new() -> Volume {
        Volume::new()
    }

    fn descriptor_static(_: ::std::option::Option<Volume>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    Volume::get_name_for_reflect,
                    Volume::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VolumeSource>>(
                    "volumeSource",
                    Volume::get_volumeSource_for_reflect,
                    Volume::mut_volumeSource_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Volume>(
                    "Volume",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Volume {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_volumeSource();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Volume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Volume {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VolumeMount {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    mountPath: ::protobuf::SingularField<::std::string::String>,
    subPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for VolumeMount {}

impl VolumeMount {
    pub fn new() -> VolumeMount {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static VolumeMount {
        static mut instance: ::protobuf::lazy::Lazy<VolumeMount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VolumeMount,
        };
        unsafe {
            instance.get(VolumeMount::new)
        }
    }

    // optional string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_name_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.name
    }

    fn mut_name_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.name
    }

    // optional bool readOnly = 2;

    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }

    fn get_readOnly_for_reflect(&self) -> &::std::option::Option<bool> {
        &self.readOnly
    }

    fn mut_readOnly_for_reflect(&mut self) -> &mut ::std::option::Option<bool> {
        &mut self.readOnly
    }

    // optional string mountPath = 3;

    pub fn clear_mountPath(&mut self) {
        self.mountPath.clear();
    }

    pub fn has_mountPath(&self) -> bool {
        self.mountPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mountPath(&mut self, v: ::std::string::String) {
        self.mountPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mountPath(&mut self) -> &mut ::std::string::String {
        if self.mountPath.is_none() {
            self.mountPath.set_default();
        }
        self.mountPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_mountPath(&mut self) -> ::std::string::String {
        self.mountPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_mountPath(&self) -> &str {
        match self.mountPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_mountPath_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.mountPath
    }

    fn mut_mountPath_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.mountPath
    }

    // optional string subPath = 4;

    pub fn clear_subPath(&mut self) {
        self.subPath.clear();
    }

    pub fn has_subPath(&self) -> bool {
        self.subPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subPath(&mut self, v: ::std::string::String) {
        self.subPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subPath(&mut self) -> &mut ::std::string::String {
        if self.subPath.is_none() {
            self.subPath.set_default();
        }
        self.subPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_subPath(&mut self) -> ::std::string::String {
        self.subPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_subPath(&self) -> &str {
        match self.subPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_subPath_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.subPath
    }

    fn mut_subPath_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.subPath
    }
}

impl ::protobuf::Message for VolumeMount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mountPath)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.mountPath.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.subPath.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.mountPath.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.subPath.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for VolumeMount {
    fn new() -> VolumeMount {
        VolumeMount::new()
    }

    fn descriptor_static(_: ::std::option::Option<VolumeMount>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    VolumeMount::get_name_for_reflect,
                    VolumeMount::mut_name_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "readOnly",
                    VolumeMount::get_readOnly_for_reflect,
                    VolumeMount::mut_readOnly_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mountPath",
                    VolumeMount::get_mountPath_for_reflect,
                    VolumeMount::mut_mountPath_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "subPath",
                    VolumeMount::get_subPath_for_reflect,
                    VolumeMount::mut_subPath_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VolumeMount>(
                    "VolumeMount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for VolumeMount {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_readOnly();
        self.clear_mountPath();
        self.clear_subPath();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VolumeMount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeMount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VolumeProjection {
    // message fields
    secret: ::protobuf::SingularPtrField<SecretProjection>,
    downwardAPI: ::protobuf::SingularPtrField<DownwardAPIProjection>,
    configMap: ::protobuf::SingularPtrField<ConfigMapProjection>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for VolumeProjection {}

impl VolumeProjection {
    pub fn new() -> VolumeProjection {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static VolumeProjection {
        static mut instance: ::protobuf::lazy::Lazy<VolumeProjection> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VolumeProjection,
        };
        unsafe {
            instance.get(VolumeProjection::new)
        }
    }

    // optional .k8s.io.api.core.v1.SecretProjection secret = 1;

    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: SecretProjection) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut SecretProjection {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> SecretProjection {
        self.secret.take().unwrap_or_else(|| SecretProjection::new())
    }

    pub fn get_secret(&self) -> &SecretProjection {
        self.secret.as_ref().unwrap_or_else(|| SecretProjection::default_instance())
    }

    fn get_secret_for_reflect(&self) -> &::protobuf::SingularPtrField<SecretProjection> {
        &self.secret
    }

    fn mut_secret_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<SecretProjection> {
        &mut self.secret
    }

    // optional .k8s.io.api.core.v1.DownwardAPIProjection downwardAPI = 2;

    pub fn clear_downwardAPI(&mut self) {
        self.downwardAPI.clear();
    }

    pub fn has_downwardAPI(&self) -> bool {
        self.downwardAPI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downwardAPI(&mut self, v: DownwardAPIProjection) {
        self.downwardAPI = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downwardAPI(&mut self) -> &mut DownwardAPIProjection {
        if self.downwardAPI.is_none() {
            self.downwardAPI.set_default();
        }
        self.downwardAPI.as_mut().unwrap()
    }

    // Take field
    pub fn take_downwardAPI(&mut self) -> DownwardAPIProjection {
        self.downwardAPI.take().unwrap_or_else(|| DownwardAPIProjection::new())
    }

    pub fn get_downwardAPI(&self) -> &DownwardAPIProjection {
        self.downwardAPI.as_ref().unwrap_or_else(|| DownwardAPIProjection::default_instance())
    }

    fn get_downwardAPI_for_reflect(&self) -> &::protobuf::SingularPtrField<DownwardAPIProjection> {
        &self.downwardAPI
    }

    fn mut_downwardAPI_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DownwardAPIProjection> {
        &mut self.downwardAPI
    }

    // optional .k8s.io.api.core.v1.ConfigMapProjection configMap = 3;

    pub fn clear_configMap(&mut self) {
        self.configMap.clear();
    }

    pub fn has_configMap(&self) -> bool {
        self.configMap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMap(&mut self, v: ConfigMapProjection) {
        self.configMap = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMap(&mut self) -> &mut ConfigMapProjection {
        if self.configMap.is_none() {
            self.configMap.set_default();
        }
        self.configMap.as_mut().unwrap()
    }

    // Take field
    pub fn take_configMap(&mut self) -> ConfigMapProjection {
        self.configMap.take().unwrap_or_else(|| ConfigMapProjection::new())
    }

    pub fn get_configMap(&self) -> &ConfigMapProjection {
        self.configMap.as_ref().unwrap_or_else(|| ConfigMapProjection::default_instance())
    }

    fn get_configMap_for_reflect(&self) -> &::protobuf::SingularPtrField<ConfigMapProjection> {
        &self.configMap
    }

    fn mut_configMap_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ConfigMapProjection> {
        &mut self.configMap
    }
}

impl ::protobuf::Message for VolumeProjection {
    fn is_initialized(&self) -> bool {
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downwardAPI {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configMap {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.downwardAPI)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configMap)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.downwardAPI.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.configMap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.downwardAPI.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.configMap.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for VolumeProjection {
    fn new() -> VolumeProjection {
        VolumeProjection::new()
    }

    fn descriptor_static(_: ::std::option::Option<VolumeProjection>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretProjection>>(
                    "secret",
                    VolumeProjection::get_secret_for_reflect,
                    VolumeProjection::mut_secret_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownwardAPIProjection>>(
                    "downwardAPI",
                    VolumeProjection::get_downwardAPI_for_reflect,
                    VolumeProjection::mut_downwardAPI_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigMapProjection>>(
                    "configMap",
                    VolumeProjection::get_configMap_for_reflect,
                    VolumeProjection::mut_configMap_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VolumeProjection>(
                    "VolumeProjection",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for VolumeProjection {
    fn clear(&mut self) {
        self.clear_secret();
        self.clear_downwardAPI();
        self.clear_configMap();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VolumeProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeProjection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VolumeSource {
    // message fields
    hostPath: ::protobuf::SingularPtrField<HostPathVolumeSource>,
    emptyDir: ::protobuf::SingularPtrField<EmptyDirVolumeSource>,
    gcePersistentDisk: ::protobuf::SingularPtrField<GCEPersistentDiskVolumeSource>,
    awsElasticBlockStore: ::protobuf::SingularPtrField<AWSElasticBlockStoreVolumeSource>,
    gitRepo: ::protobuf::SingularPtrField<GitRepoVolumeSource>,
    secret: ::protobuf::SingularPtrField<SecretVolumeSource>,
    nfs: ::protobuf::SingularPtrField<NFSVolumeSource>,
    iscsi: ::protobuf::SingularPtrField<ISCSIVolumeSource>,
    glusterfs: ::protobuf::SingularPtrField<GlusterfsVolumeSource>,
    persistentVolumeClaim: ::protobuf::SingularPtrField<PersistentVolumeClaimVolumeSource>,
    rbd: ::protobuf::SingularPtrField<RBDVolumeSource>,
    flexVolume: ::protobuf::SingularPtrField<FlexVolumeSource>,
    cinder: ::protobuf::SingularPtrField<CinderVolumeSource>,
    cephfs: ::protobuf::SingularPtrField<CephFSVolumeSource>,
    flocker: ::protobuf::SingularPtrField<FlockerVolumeSource>,
    downwardAPI: ::protobuf::SingularPtrField<DownwardAPIVolumeSource>,
    fc: ::protobuf::SingularPtrField<FCVolumeSource>,
    azureFile: ::protobuf::SingularPtrField<AzureFileVolumeSource>,
    configMap: ::protobuf::SingularPtrField<ConfigMapVolumeSource>,
    vsphereVolume: ::protobuf::SingularPtrField<VsphereVirtualDiskVolumeSource>,
    quobyte: ::protobuf::SingularPtrField<QuobyteVolumeSource>,
    azureDisk: ::protobuf::SingularPtrField<AzureDiskVolumeSource>,
    photonPersistentDisk: ::protobuf::SingularPtrField<PhotonPersistentDiskVolumeSource>,
    projected: ::protobuf::SingularPtrField<ProjectedVolumeSource>,
    portworxVolume: ::protobuf::SingularPtrField<PortworxVolumeSource>,
    scaleIO: ::protobuf::SingularPtrField<ScaleIOVolumeSource>,
    storageos: ::protobuf::SingularPtrField<StorageOSVolumeSource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for VolumeSource {}

impl VolumeSource {
    pub fn new() -> VolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static VolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<VolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VolumeSource,
        };
        unsafe {
            instance.get(VolumeSource::new)
        }
    }

    // optional .k8s.io.api.core.v1.HostPathVolumeSource hostPath = 1;

    pub fn clear_hostPath(&mut self) {
        self.hostPath.clear();
    }

    pub fn has_hostPath(&self) -> bool {
        self.hostPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostPath(&mut self, v: HostPathVolumeSource) {
        self.hostPath = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostPath(&mut self) -> &mut HostPathVolumeSource {
        if self.hostPath.is_none() {
            self.hostPath.set_default();
        }
        self.hostPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostPath(&mut self) -> HostPathVolumeSource {
        self.hostPath.take().unwrap_or_else(|| HostPathVolumeSource::new())
    }

    pub fn get_hostPath(&self) -> &HostPathVolumeSource {
        self.hostPath.as_ref().unwrap_or_else(|| HostPathVolumeSource::default_instance())
    }

    fn get_hostPath_for_reflect(&self) -> &::protobuf::SingularPtrField<HostPathVolumeSource> {
        &self.hostPath
    }

    fn mut_hostPath_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<HostPathVolumeSource> {
        &mut self.hostPath
    }

    // optional .k8s.io.api.core.v1.EmptyDirVolumeSource emptyDir = 2;

    pub fn clear_emptyDir(&mut self) {
        self.emptyDir.clear();
    }

    pub fn has_emptyDir(&self) -> bool {
        self.emptyDir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emptyDir(&mut self, v: EmptyDirVolumeSource) {
        self.emptyDir = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emptyDir(&mut self) -> &mut EmptyDirVolumeSource {
        if self.emptyDir.is_none() {
            self.emptyDir.set_default();
        }
        self.emptyDir.as_mut().unwrap()
    }

    // Take field
    pub fn take_emptyDir(&mut self) -> EmptyDirVolumeSource {
        self.emptyDir.take().unwrap_or_else(|| EmptyDirVolumeSource::new())
    }

    pub fn get_emptyDir(&self) -> &EmptyDirVolumeSource {
        self.emptyDir.as_ref().unwrap_or_else(|| EmptyDirVolumeSource::default_instance())
    }

    fn get_emptyDir_for_reflect(&self) -> &::protobuf::SingularPtrField<EmptyDirVolumeSource> {
        &self.emptyDir
    }

    fn mut_emptyDir_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<EmptyDirVolumeSource> {
        &mut self.emptyDir
    }

    // optional .k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 3;

    pub fn clear_gcePersistentDisk(&mut self) {
        self.gcePersistentDisk.clear();
    }

    pub fn has_gcePersistentDisk(&self) -> bool {
        self.gcePersistentDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcePersistentDisk(&mut self, v: GCEPersistentDiskVolumeSource) {
        self.gcePersistentDisk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcePersistentDisk(&mut self) -> &mut GCEPersistentDiskVolumeSource {
        if self.gcePersistentDisk.is_none() {
            self.gcePersistentDisk.set_default();
        }
        self.gcePersistentDisk.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcePersistentDisk(&mut self) -> GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.take().unwrap_or_else(|| GCEPersistentDiskVolumeSource::new())
    }

    pub fn get_gcePersistentDisk(&self) -> &GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.as_ref().unwrap_or_else(|| GCEPersistentDiskVolumeSource::default_instance())
    }

    fn get_gcePersistentDisk_for_reflect(&self) -> &::protobuf::SingularPtrField<GCEPersistentDiskVolumeSource> {
        &self.gcePersistentDisk
    }

    fn mut_gcePersistentDisk_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<GCEPersistentDiskVolumeSource> {
        &mut self.gcePersistentDisk
    }

    // optional .k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 4;

    pub fn clear_awsElasticBlockStore(&mut self) {
        self.awsElasticBlockStore.clear();
    }

    pub fn has_awsElasticBlockStore(&self) -> bool {
        self.awsElasticBlockStore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_awsElasticBlockStore(&mut self, v: AWSElasticBlockStoreVolumeSource) {
        self.awsElasticBlockStore = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_awsElasticBlockStore(&mut self) -> &mut AWSElasticBlockStoreVolumeSource {
        if self.awsElasticBlockStore.is_none() {
            self.awsElasticBlockStore.set_default();
        }
        self.awsElasticBlockStore.as_mut().unwrap()
    }

    // Take field
    pub fn take_awsElasticBlockStore(&mut self) -> AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.take().unwrap_or_else(|| AWSElasticBlockStoreVolumeSource::new())
    }

    pub fn get_awsElasticBlockStore(&self) -> &AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.as_ref().unwrap_or_else(|| AWSElasticBlockStoreVolumeSource::default_instance())
    }

    fn get_awsElasticBlockStore_for_reflect(&self) -> &::protobuf::SingularPtrField<AWSElasticBlockStoreVolumeSource> {
        &self.awsElasticBlockStore
    }

    fn mut_awsElasticBlockStore_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AWSElasticBlockStoreVolumeSource> {
        &mut self.awsElasticBlockStore
    }

    // optional .k8s.io.api.core.v1.GitRepoVolumeSource gitRepo = 5;

    pub fn clear_gitRepo(&mut self) {
        self.gitRepo.clear();
    }

    pub fn has_gitRepo(&self) -> bool {
        self.gitRepo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gitRepo(&mut self, v: GitRepoVolumeSource) {
        self.gitRepo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gitRepo(&mut self) -> &mut GitRepoVolumeSource {
        if self.gitRepo.is_none() {
            self.gitRepo.set_default();
        }
        self.gitRepo.as_mut().unwrap()
    }

    // Take field
    pub fn take_gitRepo(&mut self) -> GitRepoVolumeSource {
        self.gitRepo.take().unwrap_or_else(|| GitRepoVolumeSource::new())
    }

    pub fn get_gitRepo(&self) -> &GitRepoVolumeSource {
        self.gitRepo.as_ref().unwrap_or_else(|| GitRepoVolumeSource::default_instance())
    }

    fn get_gitRepo_for_reflect(&self) -> &::protobuf::SingularPtrField<GitRepoVolumeSource> {
        &self.gitRepo
    }

    fn mut_gitRepo_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<GitRepoVolumeSource> {
        &mut self.gitRepo
    }

    // optional .k8s.io.api.core.v1.SecretVolumeSource secret = 6;

    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: SecretVolumeSource) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut SecretVolumeSource {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> SecretVolumeSource {
        self.secret.take().unwrap_or_else(|| SecretVolumeSource::new())
    }

    pub fn get_secret(&self) -> &SecretVolumeSource {
        self.secret.as_ref().unwrap_or_else(|| SecretVolumeSource::default_instance())
    }

    fn get_secret_for_reflect(&self) -> &::protobuf::SingularPtrField<SecretVolumeSource> {
        &self.secret
    }

    fn mut_secret_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<SecretVolumeSource> {
        &mut self.secret
    }

    // optional .k8s.io.api.core.v1.NFSVolumeSource nfs = 7;

    pub fn clear_nfs(&mut self) {
        self.nfs.clear();
    }

    pub fn has_nfs(&self) -> bool {
        self.nfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nfs(&mut self, v: NFSVolumeSource) {
        self.nfs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nfs(&mut self) -> &mut NFSVolumeSource {
        if self.nfs.is_none() {
            self.nfs.set_default();
        }
        self.nfs.as_mut().unwrap()
    }

    // Take field
    pub fn take_nfs(&mut self) -> NFSVolumeSource {
        self.nfs.take().unwrap_or_else(|| NFSVolumeSource::new())
    }

    pub fn get_nfs(&self) -> &NFSVolumeSource {
        self.nfs.as_ref().unwrap_or_else(|| NFSVolumeSource::default_instance())
    }

    fn get_nfs_for_reflect(&self) -> &::protobuf::SingularPtrField<NFSVolumeSource> {
        &self.nfs
    }

    fn mut_nfs_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<NFSVolumeSource> {
        &mut self.nfs
    }

    // optional .k8s.io.api.core.v1.ISCSIVolumeSource iscsi = 8;

    pub fn clear_iscsi(&mut self) {
        self.iscsi.clear();
    }

    pub fn has_iscsi(&self) -> bool {
        self.iscsi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iscsi(&mut self, v: ISCSIVolumeSource) {
        self.iscsi = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iscsi(&mut self) -> &mut ISCSIVolumeSource {
        if self.iscsi.is_none() {
            self.iscsi.set_default();
        }
        self.iscsi.as_mut().unwrap()
    }

    // Take field
    pub fn take_iscsi(&mut self) -> ISCSIVolumeSource {
        self.iscsi.take().unwrap_or_else(|| ISCSIVolumeSource::new())
    }

    pub fn get_iscsi(&self) -> &ISCSIVolumeSource {
        self.iscsi.as_ref().unwrap_or_else(|| ISCSIVolumeSource::default_instance())
    }

    fn get_iscsi_for_reflect(&self) -> &::protobuf::SingularPtrField<ISCSIVolumeSource> {
        &self.iscsi
    }

    fn mut_iscsi_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ISCSIVolumeSource> {
        &mut self.iscsi
    }

    // optional .k8s.io.api.core.v1.GlusterfsVolumeSource glusterfs = 9;

    pub fn clear_glusterfs(&mut self) {
        self.glusterfs.clear();
    }

    pub fn has_glusterfs(&self) -> bool {
        self.glusterfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_glusterfs(&mut self, v: GlusterfsVolumeSource) {
        self.glusterfs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_glusterfs(&mut self) -> &mut GlusterfsVolumeSource {
        if self.glusterfs.is_none() {
            self.glusterfs.set_default();
        }
        self.glusterfs.as_mut().unwrap()
    }

    // Take field
    pub fn take_glusterfs(&mut self) -> GlusterfsVolumeSource {
        self.glusterfs.take().unwrap_or_else(|| GlusterfsVolumeSource::new())
    }

    pub fn get_glusterfs(&self) -> &GlusterfsVolumeSource {
        self.glusterfs.as_ref().unwrap_or_else(|| GlusterfsVolumeSource::default_instance())
    }

    fn get_glusterfs_for_reflect(&self) -> &::protobuf::SingularPtrField<GlusterfsVolumeSource> {
        &self.glusterfs
    }

    fn mut_glusterfs_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<GlusterfsVolumeSource> {
        &mut self.glusterfs
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource persistentVolumeClaim = 10;

    pub fn clear_persistentVolumeClaim(&mut self) {
        self.persistentVolumeClaim.clear();
    }

    pub fn has_persistentVolumeClaim(&self) -> bool {
        self.persistentVolumeClaim.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistentVolumeClaim(&mut self, v: PersistentVolumeClaimVolumeSource) {
        self.persistentVolumeClaim = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistentVolumeClaim(&mut self) -> &mut PersistentVolumeClaimVolumeSource {
        if self.persistentVolumeClaim.is_none() {
            self.persistentVolumeClaim.set_default();
        }
        self.persistentVolumeClaim.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistentVolumeClaim(&mut self) -> PersistentVolumeClaimVolumeSource {
        self.persistentVolumeClaim.take().unwrap_or_else(|| PersistentVolumeClaimVolumeSource::new())
    }

    pub fn get_persistentVolumeClaim(&self) -> &PersistentVolumeClaimVolumeSource {
        self.persistentVolumeClaim.as_ref().unwrap_or_else(|| PersistentVolumeClaimVolumeSource::default_instance())
    }

    fn get_persistentVolumeClaim_for_reflect(&self) -> &::protobuf::SingularPtrField<PersistentVolumeClaimVolumeSource> {
        &self.persistentVolumeClaim
    }

    fn mut_persistentVolumeClaim_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PersistentVolumeClaimVolumeSource> {
        &mut self.persistentVolumeClaim
    }

    // optional .k8s.io.api.core.v1.RBDVolumeSource rbd = 11;

    pub fn clear_rbd(&mut self) {
        self.rbd.clear();
    }

    pub fn has_rbd(&self) -> bool {
        self.rbd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rbd(&mut self, v: RBDVolumeSource) {
        self.rbd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rbd(&mut self) -> &mut RBDVolumeSource {
        if self.rbd.is_none() {
            self.rbd.set_default();
        }
        self.rbd.as_mut().unwrap()
    }

    // Take field
    pub fn take_rbd(&mut self) -> RBDVolumeSource {
        self.rbd.take().unwrap_or_else(|| RBDVolumeSource::new())
    }

    pub fn get_rbd(&self) -> &RBDVolumeSource {
        self.rbd.as_ref().unwrap_or_else(|| RBDVolumeSource::default_instance())
    }

    fn get_rbd_for_reflect(&self) -> &::protobuf::SingularPtrField<RBDVolumeSource> {
        &self.rbd
    }

    fn mut_rbd_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<RBDVolumeSource> {
        &mut self.rbd
    }

    // optional .k8s.io.api.core.v1.FlexVolumeSource flexVolume = 12;

    pub fn clear_flexVolume(&mut self) {
        self.flexVolume.clear();
    }

    pub fn has_flexVolume(&self) -> bool {
        self.flexVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flexVolume(&mut self, v: FlexVolumeSource) {
        self.flexVolume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flexVolume(&mut self) -> &mut FlexVolumeSource {
        if self.flexVolume.is_none() {
            self.flexVolume.set_default();
        }
        self.flexVolume.as_mut().unwrap()
    }

    // Take field
    pub fn take_flexVolume(&mut self) -> FlexVolumeSource {
        self.flexVolume.take().unwrap_or_else(|| FlexVolumeSource::new())
    }

    pub fn get_flexVolume(&self) -> &FlexVolumeSource {
        self.flexVolume.as_ref().unwrap_or_else(|| FlexVolumeSource::default_instance())
    }

    fn get_flexVolume_for_reflect(&self) -> &::protobuf::SingularPtrField<FlexVolumeSource> {
        &self.flexVolume
    }

    fn mut_flexVolume_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<FlexVolumeSource> {
        &mut self.flexVolume
    }

    // optional .k8s.io.api.core.v1.CinderVolumeSource cinder = 13;

    pub fn clear_cinder(&mut self) {
        self.cinder.clear();
    }

    pub fn has_cinder(&self) -> bool {
        self.cinder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cinder(&mut self, v: CinderVolumeSource) {
        self.cinder = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cinder(&mut self) -> &mut CinderVolumeSource {
        if self.cinder.is_none() {
            self.cinder.set_default();
        }
        self.cinder.as_mut().unwrap()
    }

    // Take field
    pub fn take_cinder(&mut self) -> CinderVolumeSource {
        self.cinder.take().unwrap_or_else(|| CinderVolumeSource::new())
    }

    pub fn get_cinder(&self) -> &CinderVolumeSource {
        self.cinder.as_ref().unwrap_or_else(|| CinderVolumeSource::default_instance())
    }

    fn get_cinder_for_reflect(&self) -> &::protobuf::SingularPtrField<CinderVolumeSource> {
        &self.cinder
    }

    fn mut_cinder_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CinderVolumeSource> {
        &mut self.cinder
    }

    // optional .k8s.io.api.core.v1.CephFSVolumeSource cephfs = 14;

    pub fn clear_cephfs(&mut self) {
        self.cephfs.clear();
    }

    pub fn has_cephfs(&self) -> bool {
        self.cephfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cephfs(&mut self, v: CephFSVolumeSource) {
        self.cephfs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cephfs(&mut self) -> &mut CephFSVolumeSource {
        if self.cephfs.is_none() {
            self.cephfs.set_default();
        }
        self.cephfs.as_mut().unwrap()
    }

    // Take field
    pub fn take_cephfs(&mut self) -> CephFSVolumeSource {
        self.cephfs.take().unwrap_or_else(|| CephFSVolumeSource::new())
    }

    pub fn get_cephfs(&self) -> &CephFSVolumeSource {
        self.cephfs.as_ref().unwrap_or_else(|| CephFSVolumeSource::default_instance())
    }

    fn get_cephfs_for_reflect(&self) -> &::protobuf::SingularPtrField<CephFSVolumeSource> {
        &self.cephfs
    }

    fn mut_cephfs_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<CephFSVolumeSource> {
        &mut self.cephfs
    }

    // optional .k8s.io.api.core.v1.FlockerVolumeSource flocker = 15;

    pub fn clear_flocker(&mut self) {
        self.flocker.clear();
    }

    pub fn has_flocker(&self) -> bool {
        self.flocker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flocker(&mut self, v: FlockerVolumeSource) {
        self.flocker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flocker(&mut self) -> &mut FlockerVolumeSource {
        if self.flocker.is_none() {
            self.flocker.set_default();
        }
        self.flocker.as_mut().unwrap()
    }

    // Take field
    pub fn take_flocker(&mut self) -> FlockerVolumeSource {
        self.flocker.take().unwrap_or_else(|| FlockerVolumeSource::new())
    }

    pub fn get_flocker(&self) -> &FlockerVolumeSource {
        self.flocker.as_ref().unwrap_or_else(|| FlockerVolumeSource::default_instance())
    }

    fn get_flocker_for_reflect(&self) -> &::protobuf::SingularPtrField<FlockerVolumeSource> {
        &self.flocker
    }

    fn mut_flocker_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<FlockerVolumeSource> {
        &mut self.flocker
    }

    // optional .k8s.io.api.core.v1.DownwardAPIVolumeSource downwardAPI = 16;

    pub fn clear_downwardAPI(&mut self) {
        self.downwardAPI.clear();
    }

    pub fn has_downwardAPI(&self) -> bool {
        self.downwardAPI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downwardAPI(&mut self, v: DownwardAPIVolumeSource) {
        self.downwardAPI = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downwardAPI(&mut self) -> &mut DownwardAPIVolumeSource {
        if self.downwardAPI.is_none() {
            self.downwardAPI.set_default();
        }
        self.downwardAPI.as_mut().unwrap()
    }

    // Take field
    pub fn take_downwardAPI(&mut self) -> DownwardAPIVolumeSource {
        self.downwardAPI.take().unwrap_or_else(|| DownwardAPIVolumeSource::new())
    }

    pub fn get_downwardAPI(&self) -> &DownwardAPIVolumeSource {
        self.downwardAPI.as_ref().unwrap_or_else(|| DownwardAPIVolumeSource::default_instance())
    }

    fn get_downwardAPI_for_reflect(&self) -> &::protobuf::SingularPtrField<DownwardAPIVolumeSource> {
        &self.downwardAPI
    }

    fn mut_downwardAPI_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<DownwardAPIVolumeSource> {
        &mut self.downwardAPI
    }

    // optional .k8s.io.api.core.v1.FCVolumeSource fc = 17;

    pub fn clear_fc(&mut self) {
        self.fc.clear();
    }

    pub fn has_fc(&self) -> bool {
        self.fc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fc(&mut self, v: FCVolumeSource) {
        self.fc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fc(&mut self) -> &mut FCVolumeSource {
        if self.fc.is_none() {
            self.fc.set_default();
        }
        self.fc.as_mut().unwrap()
    }

    // Take field
    pub fn take_fc(&mut self) -> FCVolumeSource {
        self.fc.take().unwrap_or_else(|| FCVolumeSource::new())
    }

    pub fn get_fc(&self) -> &FCVolumeSource {
        self.fc.as_ref().unwrap_or_else(|| FCVolumeSource::default_instance())
    }

    fn get_fc_for_reflect(&self) -> &::protobuf::SingularPtrField<FCVolumeSource> {
        &self.fc
    }

    fn mut_fc_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<FCVolumeSource> {
        &mut self.fc
    }

    // optional .k8s.io.api.core.v1.AzureFileVolumeSource azureFile = 18;

    pub fn clear_azureFile(&mut self) {
        self.azureFile.clear();
    }

    pub fn has_azureFile(&self) -> bool {
        self.azureFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azureFile(&mut self, v: AzureFileVolumeSource) {
        self.azureFile = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azureFile(&mut self) -> &mut AzureFileVolumeSource {
        if self.azureFile.is_none() {
            self.azureFile.set_default();
        }
        self.azureFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_azureFile(&mut self) -> AzureFileVolumeSource {
        self.azureFile.take().unwrap_or_else(|| AzureFileVolumeSource::new())
    }

    pub fn get_azureFile(&self) -> &AzureFileVolumeSource {
        self.azureFile.as_ref().unwrap_or_else(|| AzureFileVolumeSource::default_instance())
    }

    fn get_azureFile_for_reflect(&self) -> &::protobuf::SingularPtrField<AzureFileVolumeSource> {
        &self.azureFile
    }

    fn mut_azureFile_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AzureFileVolumeSource> {
        &mut self.azureFile
    }

    // optional .k8s.io.api.core.v1.ConfigMapVolumeSource configMap = 19;

    pub fn clear_configMap(&mut self) {
        self.configMap.clear();
    }

    pub fn has_configMap(&self) -> bool {
        self.configMap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMap(&mut self, v: ConfigMapVolumeSource) {
        self.configMap = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMap(&mut self) -> &mut ConfigMapVolumeSource {
        if self.configMap.is_none() {
            self.configMap.set_default();
        }
        self.configMap.as_mut().unwrap()
    }

    // Take field
    pub fn take_configMap(&mut self) -> ConfigMapVolumeSource {
        self.configMap.take().unwrap_or_else(|| ConfigMapVolumeSource::new())
    }

    pub fn get_configMap(&self) -> &ConfigMapVolumeSource {
        self.configMap.as_ref().unwrap_or_else(|| ConfigMapVolumeSource::default_instance())
    }

    fn get_configMap_for_reflect(&self) -> &::protobuf::SingularPtrField<ConfigMapVolumeSource> {
        &self.configMap
    }

    fn mut_configMap_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ConfigMapVolumeSource> {
        &mut self.configMap
    }

    // optional .k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 20;

    pub fn clear_vsphereVolume(&mut self) {
        self.vsphereVolume.clear();
    }

    pub fn has_vsphereVolume(&self) -> bool {
        self.vsphereVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vsphereVolume(&mut self, v: VsphereVirtualDiskVolumeSource) {
        self.vsphereVolume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vsphereVolume(&mut self) -> &mut VsphereVirtualDiskVolumeSource {
        if self.vsphereVolume.is_none() {
            self.vsphereVolume.set_default();
        }
        self.vsphereVolume.as_mut().unwrap()
    }

    // Take field
    pub fn take_vsphereVolume(&mut self) -> VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.take().unwrap_or_else(|| VsphereVirtualDiskVolumeSource::new())
    }

    pub fn get_vsphereVolume(&self) -> &VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.as_ref().unwrap_or_else(|| VsphereVirtualDiskVolumeSource::default_instance())
    }

    fn get_vsphereVolume_for_reflect(&self) -> &::protobuf::SingularPtrField<VsphereVirtualDiskVolumeSource> {
        &self.vsphereVolume
    }

    fn mut_vsphereVolume_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<VsphereVirtualDiskVolumeSource> {
        &mut self.vsphereVolume
    }

    // optional .k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 21;

    pub fn clear_quobyte(&mut self) {
        self.quobyte.clear();
    }

    pub fn has_quobyte(&self) -> bool {
        self.quobyte.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quobyte(&mut self, v: QuobyteVolumeSource) {
        self.quobyte = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quobyte(&mut self) -> &mut QuobyteVolumeSource {
        if self.quobyte.is_none() {
            self.quobyte.set_default();
        }
        self.quobyte.as_mut().unwrap()
    }

    // Take field
    pub fn take_quobyte(&mut self) -> QuobyteVolumeSource {
        self.quobyte.take().unwrap_or_else(|| QuobyteVolumeSource::new())
    }

    pub fn get_quobyte(&self) -> &QuobyteVolumeSource {
        self.quobyte.as_ref().unwrap_or_else(|| QuobyteVolumeSource::default_instance())
    }

    fn get_quobyte_for_reflect(&self) -> &::protobuf::SingularPtrField<QuobyteVolumeSource> {
        &self.quobyte
    }

    fn mut_quobyte_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<QuobyteVolumeSource> {
        &mut self.quobyte
    }

    // optional .k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 22;

    pub fn clear_azureDisk(&mut self) {
        self.azureDisk.clear();
    }

    pub fn has_azureDisk(&self) -> bool {
        self.azureDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azureDisk(&mut self, v: AzureDiskVolumeSource) {
        self.azureDisk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azureDisk(&mut self) -> &mut AzureDiskVolumeSource {
        if self.azureDisk.is_none() {
            self.azureDisk.set_default();
        }
        self.azureDisk.as_mut().unwrap()
    }

    // Take field
    pub fn take_azureDisk(&mut self) -> AzureDiskVolumeSource {
        self.azureDisk.take().unwrap_or_else(|| AzureDiskVolumeSource::new())
    }

    pub fn get_azureDisk(&self) -> &AzureDiskVolumeSource {
        self.azureDisk.as_ref().unwrap_or_else(|| AzureDiskVolumeSource::default_instance())
    }

    fn get_azureDisk_for_reflect(&self) -> &::protobuf::SingularPtrField<AzureDiskVolumeSource> {
        &self.azureDisk
    }

    fn mut_azureDisk_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<AzureDiskVolumeSource> {
        &mut self.azureDisk
    }

    // optional .k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 23;

    pub fn clear_photonPersistentDisk(&mut self) {
        self.photonPersistentDisk.clear();
    }

    pub fn has_photonPersistentDisk(&self) -> bool {
        self.photonPersistentDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_photonPersistentDisk(&mut self, v: PhotonPersistentDiskVolumeSource) {
        self.photonPersistentDisk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_photonPersistentDisk(&mut self) -> &mut PhotonPersistentDiskVolumeSource {
        if self.photonPersistentDisk.is_none() {
            self.photonPersistentDisk.set_default();
        }
        self.photonPersistentDisk.as_mut().unwrap()
    }

    // Take field
    pub fn take_photonPersistentDisk(&mut self) -> PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.take().unwrap_or_else(|| PhotonPersistentDiskVolumeSource::new())
    }

    pub fn get_photonPersistentDisk(&self) -> &PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.as_ref().unwrap_or_else(|| PhotonPersistentDiskVolumeSource::default_instance())
    }

    fn get_photonPersistentDisk_for_reflect(&self) -> &::protobuf::SingularPtrField<PhotonPersistentDiskVolumeSource> {
        &self.photonPersistentDisk
    }

    fn mut_photonPersistentDisk_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PhotonPersistentDiskVolumeSource> {
        &mut self.photonPersistentDisk
    }

    // optional .k8s.io.api.core.v1.ProjectedVolumeSource projected = 26;

    pub fn clear_projected(&mut self) {
        self.projected.clear();
    }

    pub fn has_projected(&self) -> bool {
        self.projected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_projected(&mut self, v: ProjectedVolumeSource) {
        self.projected = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_projected(&mut self) -> &mut ProjectedVolumeSource {
        if self.projected.is_none() {
            self.projected.set_default();
        }
        self.projected.as_mut().unwrap()
    }

    // Take field
    pub fn take_projected(&mut self) -> ProjectedVolumeSource {
        self.projected.take().unwrap_or_else(|| ProjectedVolumeSource::new())
    }

    pub fn get_projected(&self) -> &ProjectedVolumeSource {
        self.projected.as_ref().unwrap_or_else(|| ProjectedVolumeSource::default_instance())
    }

    fn get_projected_for_reflect(&self) -> &::protobuf::SingularPtrField<ProjectedVolumeSource> {
        &self.projected
    }

    fn mut_projected_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ProjectedVolumeSource> {
        &mut self.projected
    }

    // optional .k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 24;

    pub fn clear_portworxVolume(&mut self) {
        self.portworxVolume.clear();
    }

    pub fn has_portworxVolume(&self) -> bool {
        self.portworxVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portworxVolume(&mut self, v: PortworxVolumeSource) {
        self.portworxVolume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portworxVolume(&mut self) -> &mut PortworxVolumeSource {
        if self.portworxVolume.is_none() {
            self.portworxVolume.set_default();
        }
        self.portworxVolume.as_mut().unwrap()
    }

    // Take field
    pub fn take_portworxVolume(&mut self) -> PortworxVolumeSource {
        self.portworxVolume.take().unwrap_or_else(|| PortworxVolumeSource::new())
    }

    pub fn get_portworxVolume(&self) -> &PortworxVolumeSource {
        self.portworxVolume.as_ref().unwrap_or_else(|| PortworxVolumeSource::default_instance())
    }

    fn get_portworxVolume_for_reflect(&self) -> &::protobuf::SingularPtrField<PortworxVolumeSource> {
        &self.portworxVolume
    }

    fn mut_portworxVolume_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PortworxVolumeSource> {
        &mut self.portworxVolume
    }

    // optional .k8s.io.api.core.v1.ScaleIOVolumeSource scaleIO = 25;

    pub fn clear_scaleIO(&mut self) {
        self.scaleIO.clear();
    }

    pub fn has_scaleIO(&self) -> bool {
        self.scaleIO.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaleIO(&mut self, v: ScaleIOVolumeSource) {
        self.scaleIO = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scaleIO(&mut self) -> &mut ScaleIOVolumeSource {
        if self.scaleIO.is_none() {
            self.scaleIO.set_default();
        }
        self.scaleIO.as_mut().unwrap()
    }

    // Take field
    pub fn take_scaleIO(&mut self) -> ScaleIOVolumeSource {
        self.scaleIO.take().unwrap_or_else(|| ScaleIOVolumeSource::new())
    }

    pub fn get_scaleIO(&self) -> &ScaleIOVolumeSource {
        self.scaleIO.as_ref().unwrap_or_else(|| ScaleIOVolumeSource::default_instance())
    }

    fn get_scaleIO_for_reflect(&self) -> &::protobuf::SingularPtrField<ScaleIOVolumeSource> {
        &self.scaleIO
    }

    fn mut_scaleIO_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<ScaleIOVolumeSource> {
        &mut self.scaleIO
    }

    // optional .k8s.io.api.core.v1.StorageOSVolumeSource storageos = 27;

    pub fn clear_storageos(&mut self) {
        self.storageos.clear();
    }

    pub fn has_storageos(&self) -> bool {
        self.storageos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageos(&mut self, v: StorageOSVolumeSource) {
        self.storageos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageos(&mut self) -> &mut StorageOSVolumeSource {
        if self.storageos.is_none() {
            self.storageos.set_default();
        }
        self.storageos.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageos(&mut self) -> StorageOSVolumeSource {
        self.storageos.take().unwrap_or_else(|| StorageOSVolumeSource::new())
    }

    pub fn get_storageos(&self) -> &StorageOSVolumeSource {
        self.storageos.as_ref().unwrap_or_else(|| StorageOSVolumeSource::default_instance())
    }

    fn get_storageos_for_reflect(&self) -> &::protobuf::SingularPtrField<StorageOSVolumeSource> {
        &self.storageos
    }

    fn mut_storageos_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<StorageOSVolumeSource> {
        &mut self.storageos
    }
}

impl ::protobuf::Message for VolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.hostPath {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.emptyDir {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gcePersistentDisk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.awsElasticBlockStore {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gitRepo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nfs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.iscsi {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.glusterfs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.persistentVolumeClaim {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rbd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flexVolume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cinder {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cephfs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flocker {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downwardAPI {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.azureFile {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configMap {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vsphereVolume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quobyte {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.azureDisk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.photonPersistentDisk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.projected {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.portworxVolume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scaleIO {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storageos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hostPath)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.emptyDir)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gcePersistentDisk)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.awsElasticBlockStore)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gitRepo)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nfs)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iscsi)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.glusterfs)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.persistentVolumeClaim)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rbd)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flexVolume)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cinder)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cephfs)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flocker)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.downwardAPI)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fc)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.azureFile)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configMap)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vsphereVolume)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quobyte)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.azureDisk)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.photonPersistentDisk)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.projected)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.portworxVolume)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scaleIO)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storageos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hostPath.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.emptyDir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gcePersistentDisk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.awsElasticBlockStore.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gitRepo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.iscsi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.glusterfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.persistentVolumeClaim.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rbd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flexVolume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cinder.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cephfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flocker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.downwardAPI.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fc.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.azureFile.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.configMap.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vsphereVolume.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quobyte.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.azureDisk.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.photonPersistentDisk.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.projected.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.portworxVolume.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scaleIO.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.storageos.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hostPath.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.emptyDir.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gcePersistentDisk.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.awsElasticBlockStore.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gitRepo.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nfs.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.iscsi.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.glusterfs.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.persistentVolumeClaim.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rbd.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flexVolume.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cinder.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cephfs.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flocker.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.downwardAPI.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fc.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.azureFile.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.configMap.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vsphereVolume.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quobyte.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.azureDisk.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.photonPersistentDisk.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.projected.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.portworxVolume.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scaleIO.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.storageos.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for VolumeSource {
    fn new() -> VolumeSource {
        VolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<VolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HostPathVolumeSource>>(
                    "hostPath",
                    VolumeSource::get_hostPath_for_reflect,
                    VolumeSource::mut_hostPath_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EmptyDirVolumeSource>>(
                    "emptyDir",
                    VolumeSource::get_emptyDir_for_reflect,
                    VolumeSource::mut_emptyDir_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GCEPersistentDiskVolumeSource>>(
                    "gcePersistentDisk",
                    VolumeSource::get_gcePersistentDisk_for_reflect,
                    VolumeSource::mut_gcePersistentDisk_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AWSElasticBlockStoreVolumeSource>>(
                    "awsElasticBlockStore",
                    VolumeSource::get_awsElasticBlockStore_for_reflect,
                    VolumeSource::mut_awsElasticBlockStore_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GitRepoVolumeSource>>(
                    "gitRepo",
                    VolumeSource::get_gitRepo_for_reflect,
                    VolumeSource::mut_gitRepo_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretVolumeSource>>(
                    "secret",
                    VolumeSource::get_secret_for_reflect,
                    VolumeSource::mut_secret_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NFSVolumeSource>>(
                    "nfs",
                    VolumeSource::get_nfs_for_reflect,
                    VolumeSource::mut_nfs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ISCSIVolumeSource>>(
                    "iscsi",
                    VolumeSource::get_iscsi_for_reflect,
                    VolumeSource::mut_iscsi_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlusterfsVolumeSource>>(
                    "glusterfs",
                    VolumeSource::get_glusterfs_for_reflect,
                    VolumeSource::mut_glusterfs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeClaimVolumeSource>>(
                    "persistentVolumeClaim",
                    VolumeSource::get_persistentVolumeClaim_for_reflect,
                    VolumeSource::mut_persistentVolumeClaim_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RBDVolumeSource>>(
                    "rbd",
                    VolumeSource::get_rbd_for_reflect,
                    VolumeSource::mut_rbd_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FlexVolumeSource>>(
                    "flexVolume",
                    VolumeSource::get_flexVolume_for_reflect,
                    VolumeSource::mut_flexVolume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CinderVolumeSource>>(
                    "cinder",
                    VolumeSource::get_cinder_for_reflect,
                    VolumeSource::mut_cinder_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CephFSVolumeSource>>(
                    "cephfs",
                    VolumeSource::get_cephfs_for_reflect,
                    VolumeSource::mut_cephfs_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FlockerVolumeSource>>(
                    "flocker",
                    VolumeSource::get_flocker_for_reflect,
                    VolumeSource::mut_flocker_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownwardAPIVolumeSource>>(
                    "downwardAPI",
                    VolumeSource::get_downwardAPI_for_reflect,
                    VolumeSource::mut_downwardAPI_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FCVolumeSource>>(
                    "fc",
                    VolumeSource::get_fc_for_reflect,
                    VolumeSource::mut_fc_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AzureFileVolumeSource>>(
                    "azureFile",
                    VolumeSource::get_azureFile_for_reflect,
                    VolumeSource::mut_azureFile_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigMapVolumeSource>>(
                    "configMap",
                    VolumeSource::get_configMap_for_reflect,
                    VolumeSource::mut_configMap_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VsphereVirtualDiskVolumeSource>>(
                    "vsphereVolume",
                    VolumeSource::get_vsphereVolume_for_reflect,
                    VolumeSource::mut_vsphereVolume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuobyteVolumeSource>>(
                    "quobyte",
                    VolumeSource::get_quobyte_for_reflect,
                    VolumeSource::mut_quobyte_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AzureDiskVolumeSource>>(
                    "azureDisk",
                    VolumeSource::get_azureDisk_for_reflect,
                    VolumeSource::mut_azureDisk_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PhotonPersistentDiskVolumeSource>>(
                    "photonPersistentDisk",
                    VolumeSource::get_photonPersistentDisk_for_reflect,
                    VolumeSource::mut_photonPersistentDisk_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProjectedVolumeSource>>(
                    "projected",
                    VolumeSource::get_projected_for_reflect,
                    VolumeSource::mut_projected_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortworxVolumeSource>>(
                    "portworxVolume",
                    VolumeSource::get_portworxVolume_for_reflect,
                    VolumeSource::mut_portworxVolume_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScaleIOVolumeSource>>(
                    "scaleIO",
                    VolumeSource::get_scaleIO_for_reflect,
                    VolumeSource::mut_scaleIO_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageOSVolumeSource>>(
                    "storageos",
                    VolumeSource::get_storageos_for_reflect,
                    VolumeSource::mut_storageos_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VolumeSource>(
                    "VolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for VolumeSource {
    fn clear(&mut self) {
        self.clear_hostPath();
        self.clear_emptyDir();
        self.clear_gcePersistentDisk();
        self.clear_awsElasticBlockStore();
        self.clear_gitRepo();
        self.clear_secret();
        self.clear_nfs();
        self.clear_iscsi();
        self.clear_glusterfs();
        self.clear_persistentVolumeClaim();
        self.clear_rbd();
        self.clear_flexVolume();
        self.clear_cinder();
        self.clear_cephfs();
        self.clear_flocker();
        self.clear_downwardAPI();
        self.clear_fc();
        self.clear_azureFile();
        self.clear_configMap();
        self.clear_vsphereVolume();
        self.clear_quobyte();
        self.clear_azureDisk();
        self.clear_photonPersistentDisk();
        self.clear_projected();
        self.clear_portworxVolume();
        self.clear_scaleIO();
        self.clear_storageos();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VsphereVirtualDiskVolumeSource {
    // message fields
    volumePath: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    storagePolicyName: ::protobuf::SingularField<::std::string::String>,
    storagePolicyID: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for VsphereVirtualDiskVolumeSource {}

impl VsphereVirtualDiskVolumeSource {
    pub fn new() -> VsphereVirtualDiskVolumeSource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static VsphereVirtualDiskVolumeSource {
        static mut instance: ::protobuf::lazy::Lazy<VsphereVirtualDiskVolumeSource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VsphereVirtualDiskVolumeSource,
        };
        unsafe {
            instance.get(VsphereVirtualDiskVolumeSource::new)
        }
    }

    // optional string volumePath = 1;

    pub fn clear_volumePath(&mut self) {
        self.volumePath.clear();
    }

    pub fn has_volumePath(&self) -> bool {
        self.volumePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumePath(&mut self, v: ::std::string::String) {
        self.volumePath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumePath(&mut self) -> &mut ::std::string::String {
        if self.volumePath.is_none() {
            self.volumePath.set_default();
        }
        self.volumePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumePath(&mut self) -> ::std::string::String {
        self.volumePath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volumePath(&self) -> &str {
        match self.volumePath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_volumePath_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.volumePath
    }

    fn mut_volumePath_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.volumePath
    }

    // optional string fsType = 2;

    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_fsType_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.fsType
    }

    fn mut_fsType_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.fsType
    }

    // optional string storagePolicyName = 3;

    pub fn clear_storagePolicyName(&mut self) {
        self.storagePolicyName.clear();
    }

    pub fn has_storagePolicyName(&self) -> bool {
        self.storagePolicyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePolicyName(&mut self, v: ::std::string::String) {
        self.storagePolicyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePolicyName(&mut self) -> &mut ::std::string::String {
        if self.storagePolicyName.is_none() {
            self.storagePolicyName.set_default();
        }
        self.storagePolicyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePolicyName(&mut self) -> ::std::string::String {
        self.storagePolicyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_storagePolicyName(&self) -> &str {
        match self.storagePolicyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_storagePolicyName_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.storagePolicyName
    }

    fn mut_storagePolicyName_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.storagePolicyName
    }

    // optional string storagePolicyID = 4;

    pub fn clear_storagePolicyID(&mut self) {
        self.storagePolicyID.clear();
    }

    pub fn has_storagePolicyID(&self) -> bool {
        self.storagePolicyID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePolicyID(&mut self, v: ::std::string::String) {
        self.storagePolicyID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePolicyID(&mut self) -> &mut ::std::string::String {
        if self.storagePolicyID.is_none() {
            self.storagePolicyID.set_default();
        }
        self.storagePolicyID.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePolicyID(&mut self) -> ::std::string::String {
        self.storagePolicyID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_storagePolicyID(&self) -> &str {
        match self.storagePolicyID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    fn get_storagePolicyID_for_reflect(&self) -> &::protobuf::SingularField<::std::string::String> {
        &self.storagePolicyID
    }

    fn mut_storagePolicyID_for_reflect(&mut self) -> &mut ::protobuf::SingularField<::std::string::String> {
        &mut self.storagePolicyID
    }
}

impl ::protobuf::Message for VsphereVirtualDiskVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumePath)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storagePolicyName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storagePolicyID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumePath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.storagePolicyName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.storagePolicyID.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumePath.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.storagePolicyName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.storagePolicyID.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for VsphereVirtualDiskVolumeSource {
    fn new() -> VsphereVirtualDiskVolumeSource {
        VsphereVirtualDiskVolumeSource::new()
    }

    fn descriptor_static(_: ::std::option::Option<VsphereVirtualDiskVolumeSource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "volumePath",
                    VsphereVirtualDiskVolumeSource::get_volumePath_for_reflect,
                    VsphereVirtualDiskVolumeSource::mut_volumePath_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "fsType",
                    VsphereVirtualDiskVolumeSource::get_fsType_for_reflect,
                    VsphereVirtualDiskVolumeSource::mut_fsType_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storagePolicyName",
                    VsphereVirtualDiskVolumeSource::get_storagePolicyName_for_reflect,
                    VsphereVirtualDiskVolumeSource::mut_storagePolicyName_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storagePolicyID",
                    VsphereVirtualDiskVolumeSource::get_storagePolicyID_for_reflect,
                    VsphereVirtualDiskVolumeSource::mut_storagePolicyID_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VsphereVirtualDiskVolumeSource>(
                    "VsphereVirtualDiskVolumeSource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for VsphereVirtualDiskVolumeSource {
    fn clear(&mut self) {
        self.clear_volumePath();
        self.clear_fsType();
        self.clear_storagePolicyName();
        self.clear_storagePolicyID();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VsphereVirtualDiskVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VsphereVirtualDiskVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WeightedPodAffinityTerm {
    // message fields
    weight: ::std::option::Option<i32>,
    podAffinityTerm: ::protobuf::SingularPtrField<PodAffinityTerm>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for WeightedPodAffinityTerm {}

impl WeightedPodAffinityTerm {
    pub fn new() -> WeightedPodAffinityTerm {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static WeightedPodAffinityTerm {
        static mut instance: ::protobuf::lazy::Lazy<WeightedPodAffinityTerm> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WeightedPodAffinityTerm,
        };
        unsafe {
            instance.get(WeightedPodAffinityTerm::new)
        }
    }

    // optional int32 weight = 1;

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i32) {
        self.weight = ::std::option::Option::Some(v);
    }

    pub fn get_weight(&self) -> i32 {
        self.weight.unwrap_or(0)
    }

    fn get_weight_for_reflect(&self) -> &::std::option::Option<i32> {
        &self.weight
    }

    fn mut_weight_for_reflect(&mut self) -> &mut ::std::option::Option<i32> {
        &mut self.weight
    }

    // optional .k8s.io.api.core.v1.PodAffinityTerm podAffinityTerm = 2;

    pub fn clear_podAffinityTerm(&mut self) {
        self.podAffinityTerm.clear();
    }

    pub fn has_podAffinityTerm(&self) -> bool {
        self.podAffinityTerm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podAffinityTerm(&mut self, v: PodAffinityTerm) {
        self.podAffinityTerm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podAffinityTerm(&mut self) -> &mut PodAffinityTerm {
        if self.podAffinityTerm.is_none() {
            self.podAffinityTerm.set_default();
        }
        self.podAffinityTerm.as_mut().unwrap()
    }

    // Take field
    pub fn take_podAffinityTerm(&mut self) -> PodAffinityTerm {
        self.podAffinityTerm.take().unwrap_or_else(|| PodAffinityTerm::new())
    }

    pub fn get_podAffinityTerm(&self) -> &PodAffinityTerm {
        self.podAffinityTerm.as_ref().unwrap_or_else(|| PodAffinityTerm::default_instance())
    }

    fn get_podAffinityTerm_for_reflect(&self) -> &::protobuf::SingularPtrField<PodAffinityTerm> {
        &self.podAffinityTerm
    }

    fn mut_podAffinityTerm_for_reflect(&mut self) -> &mut ::protobuf::SingularPtrField<PodAffinityTerm> {
        &mut self.podAffinityTerm
    }
}

impl ::protobuf::Message for WeightedPodAffinityTerm {
    fn is_initialized(&self) -> bool {
        for v in &self.podAffinityTerm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.weight = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.podAffinityTerm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.podAffinityTerm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.weight {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.podAffinityTerm.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for WeightedPodAffinityTerm {
    fn new() -> WeightedPodAffinityTerm {
        WeightedPodAffinityTerm::new()
    }

    fn descriptor_static(_: ::std::option::Option<WeightedPodAffinityTerm>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "weight",
                    WeightedPodAffinityTerm::get_weight_for_reflect,
                    WeightedPodAffinityTerm::mut_weight_for_reflect,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodAffinityTerm>>(
                    "podAffinityTerm",
                    WeightedPodAffinityTerm::get_podAffinityTerm_for_reflect,
                    WeightedPodAffinityTerm::mut_podAffinityTerm_for_reflect,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WeightedPodAffinityTerm>(
                    "WeightedPodAffinityTerm",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for WeightedPodAffinityTerm {
    fn clear(&mut self) {
        self.clear_weight();
        self.clear_podAffinityTerm();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WeightedPodAffinityTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WeightedPodAffinityTerm {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"k8s.io/api/core/v1/generated.proto\x12\x12k8s.io.api.core.v1\x1a4k8s\
    .io/apimachinery/pkg/api/resource/generated.proto\x1a4k8s.io/apimachiner\
    y/pkg/apis/meta/v1/generated.proto\x1a/k8s.io/apimachinery/pkg/runtime/g\
    enerated.proto\x1a6k8s.io/apimachinery/pkg/runtime/schema/generated.prot\
    o\x1a3k8s.io/apimachinery/pkg/util/intstr/generated.proto\"\x90\x01\n\
    \x20AWSElasticBlockStoreVolumeSource\x12\x1a\n\x08volumeID\x18\x01\x20\
    \x01(\tR\x08volumeID\x12\x16\n\x06fsType\x18\x02\x20\x01(\tR\x06fsType\
    \x12\x1c\n\tpartition\x18\x03\x20\x01(\x05R\tpartition\x12\x1a\n\x08read\
    Only\x18\x04\x20\x01(\x08R\x08readOnly\"\xe2\x01\n\x08Affinity\x12D\n\
    \x0cnodeAffinity\x18\x01\x20\x01(\x0b2\x20.k8s.io.api.core.v1.NodeAffini\
    tyR\x0cnodeAffinity\x12A\n\x0bpodAffinity\x18\x02\x20\x01(\x0b2\x1f.k8s.\
    io.api.core.v1.PodAffinityR\x0bpodAffinity\x12M\n\x0fpodAntiAffinity\x18\
    \x03\x20\x01(\x0b2#.k8s.io.api.core.v1.PodAntiAffinityR\x0fpodAntiAffini\
    ty\"D\n\x0eAttachedVolume\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x1e\n\ndevicePath\x18\x02\x20\x01(\tR\ndevicePath\"_\n\tAvoidPods\
    \x12R\n\x0fpreferAvoidPods\x18\x01\x20\x03(\x0b2(.k8s.io.api.core.v1.Pre\
    ferAvoidPodsEntryR\x0fpreferAvoidPods\"\xb7\x01\n\x15AzureDiskVolumeSour\
    ce\x12\x1a\n\x08diskName\x18\x01\x20\x01(\tR\x08diskName\x12\x18\n\x07di\
    skURI\x18\x02\x20\x01(\tR\x07diskURI\x12\x20\n\x0bcachingMode\x18\x03\
    \x20\x01(\tR\x0bcachingMode\x12\x16\n\x06fsType\x18\x04\x20\x01(\tR\x06f\
    sType\x12\x1a\n\x08readOnly\x18\x05\x20\x01(\x08R\x08readOnly\x12\x12\n\
    \x04kind\x18\x06\x20\x01(\tR\x04kind\"q\n\x15AzureFileVolumeSource\x12\
    \x1e\n\nsecretName\x18\x01\x20\x01(\tR\nsecretName\x12\x1c\n\tshareName\
    \x18\x02\x20\x01(\tR\tshareName\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\
    \x08R\x08readOnly\"\x94\x01\n\x07Binding\x12L\n\x08metadata\x18\x01\x20\
    \x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\
    \x12;\n\x06target\x18\x02\x20\x01(\x0b2#.k8s.io.api.core.v1.ObjectRefere\
    nceR\x06target\"4\n\x0cCapabilities\x12\x10\n\x03add\x18\x01\x20\x03(\tR\
    \x03add\x12\x12\n\x04drop\x18\x02\x20\x03(\tR\x04drop\"\xdc\x01\n\x12Cep\
    hFSVolumeSource\x12\x1a\n\x08monitors\x18\x01\x20\x03(\tR\x08monitors\
    \x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12\x12\n\x04user\x18\x03\
    \x20\x01(\tR\x04user\x12\x1e\n\nsecretFile\x18\x04\x20\x01(\tR\nsecretFi\
    le\x12F\n\tsecretRef\x18\x05\x20\x01(\x0b2(.k8s.io.api.core.v1.LocalObje\
    ctReferenceR\tsecretRef\x12\x1a\n\x08readOnly\x18\x06\x20\x01(\x08R\x08r\
    eadOnly\"d\n\x12CinderVolumeSource\x12\x1a\n\x08volumeID\x18\x01\x20\x01\
    (\tR\x08volumeID\x12\x16\n\x06fsType\x18\x02\x20\x01(\tR\x06fsType\x12\
    \x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\"p\n\x12ComponentCo\
    ndition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06statu\
    s\x18\x02\x20\x01(\tR\x06status\x12\x18\n\x07message\x18\x03\x20\x01(\tR\
    \x07message\x12\x14\n\x05error\x18\x04\x20\x01(\tR\x05error\"\xa7\x01\n\
    \x0fComponentStatus\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.api\
    machinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12F\n\nconditions\
    \x18\x02\x20\x03(\x0b2&.k8s.io.api.core.v1.ComponentConditionR\nconditio\
    ns\"\x9c\x01\n\x13ComponentStatusList\x12J\n\x08metadata\x18\x01\x20\x01\
    (\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x129\
    \n\x05items\x18\x02\x20\x03(\x0b2#.k8s.io.api.core.v1.ComponentStatusR\
    \x05items\"\xcf\x01\n\tConfigMap\x12L\n\x08metadata\x18\x01\x20\x01(\x0b\
    20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12;\n\
    \x04data\x18\x02\x20\x03(\x0b2'.k8s.io.api.core.v1.ConfigMap.DataEntryR\
    \x04data\x1a7\n\tDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x8e\x01\n\
    \x12ConfigMapEnvSource\x12\\\n\x14localObjectReference\x18\x01\x20\x01(\
    \x0b2(.k8s.io.api.core.v1.LocalObjectReferenceR\x14localObjectReference\
    \x12\x1a\n\x08optional\x18\x02\x20\x01(\x08R\x08optional\"\xa2\x01\n\x14\
    ConfigMapKeySelector\x12\\\n\x14localObjectReference\x18\x01\x20\x01(\
    \x0b2(.k8s.io.api.core.v1.LocalObjectReferenceR\x14localObjectReference\
    \x12\x10\n\x03key\x18\x02\x20\x01(\tR\x03key\x12\x1a\n\x08optional\x18\
    \x03\x20\x01(\x08R\x08optional\"\x90\x01\n\rConfigMapList\x12J\n\x08meta\
    data\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMet\
    aR\x08metadata\x123\n\x05items\x18\x02\x20\x03(\x0b2\x1d.k8s.io.api.core\
    .v1.ConfigMapR\x05items\"\xc4\x01\n\x13ConfigMapProjection\x12\\\n\x14lo\
    calObjectReference\x18\x01\x20\x01(\x0b2(.k8s.io.api.core.v1.LocalObject\
    ReferenceR\x14localObjectReference\x123\n\x05items\x18\x02\x20\x03(\x0b2\
    \x1d.k8s.io.api.core.v1.KeyToPathR\x05items\x12\x1a\n\x08optional\x18\
    \x04\x20\x01(\x08R\x08optional\"\xe8\x01\n\x15ConfigMapVolumeSource\x12\
    \\\n\x14localObjectReference\x18\x01\x20\x01(\x0b2(.k8s.io.api.core.v1.L\
    ocalObjectReferenceR\x14localObjectReference\x123\n\x05items\x18\x02\x20\
    \x03(\x0b2\x1d.k8s.io.api.core.v1.KeyToPathR\x05items\x12\x20\n\x0bdefau\
    ltMode\x18\x03\x20\x01(\x05R\x0bdefaultMode\x12\x1a\n\x08optional\x18\
    \x04\x20\x01(\x08R\x08optional\"\xa8\x07\n\tContainer\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05image\x18\x02\x20\x01(\tR\x05i\
    mage\x12\x18\n\x07command\x18\x03\x20\x03(\tR\x07command\x12\x12\n\x04ar\
    gs\x18\x04\x20\x03(\tR\x04args\x12\x1e\n\nworkingDir\x18\x05\x20\x01(\tR\
    \nworkingDir\x127\n\x05ports\x18\x06\x20\x03(\x0b2!.k8s.io.api.core.v1.C\
    ontainerPortR\x05ports\x12;\n\x07envFrom\x18\x13\x20\x03(\x0b2!.k8s.io.a\
    pi.core.v1.EnvFromSourceR\x07envFrom\x12,\n\x03env\x18\x07\x20\x03(\x0b2\
    \x1a.k8s.io.api.core.v1.EnvVarR\x03env\x12F\n\tresources\x18\x08\x20\x01\
    (\x0b2(.k8s.io.api.core.v1.ResourceRequirementsR\tresources\x12C\n\x0cvo\
    lumeMounts\x18\t\x20\x03(\x0b2\x1f.k8s.io.api.core.v1.VolumeMountR\x0cvo\
    lumeMounts\x12?\n\rlivenessProbe\x18\n\x20\x01(\x0b2\x19.k8s.io.api.core\
    .v1.ProbeR\rlivenessProbe\x12A\n\x0ereadinessProbe\x18\x0b\x20\x01(\x0b2\
    \x19.k8s.io.api.core.v1.ProbeR\x0ereadinessProbe\x12;\n\tlifecycle\x18\
    \x0c\x20\x01(\x0b2\x1d.k8s.io.api.core.v1.LifecycleR\tlifecycle\x126\n\
    \x16terminationMessagePath\x18\r\x20\x01(\tR\x16terminationMessagePath\
    \x12:\n\x18terminationMessagePolicy\x18\x14\x20\x01(\tR\x18terminationMe\
    ssagePolicy\x12(\n\x0fimagePullPolicy\x18\x0e\x20\x01(\tR\x0fimagePullPo\
    licy\x12M\n\x0fsecurityContext\x18\x0f\x20\x01(\x0b2#.k8s.io.api.core.v1\
    .SecurityContextR\x0fsecurityContext\x12\x14\n\x05stdin\x18\x10\x20\x01(\
    \x08R\x05stdin\x12\x1c\n\tstdinOnce\x18\x11\x20\x01(\x08R\tstdinOnce\x12\
    \x10\n\x03tty\x18\x12\x20\x01(\x08R\x03tty\"D\n\x0eContainerImage\x12\
    \x14\n\x05names\x18\x01\x20\x03(\tR\x05names\x12\x1c\n\tsizeBytes\x18\
    \x02\x20\x01(\x03R\tsizeBytes\"\x99\x01\n\rContainerPort\x12\x12\n\x04na\
    me\x18\x01\x20\x01(\tR\x04name\x12\x1a\n\x08hostPort\x18\x02\x20\x01(\
    \x05R\x08hostPort\x12$\n\rcontainerPort\x18\x03\x20\x01(\x05R\rcontainer\
    Port\x12\x1a\n\x08protocol\x18\x04\x20\x01(\tR\x08protocol\x12\x16\n\x06\
    hostIP\x18\x05\x20\x01(\tR\x06hostIP\"\xe8\x01\n\x0eContainerState\x12C\
    \n\x07waiting\x18\x01\x20\x01(\x0b2).k8s.io.api.core.v1.ContainerStateWa\
    itingR\x07waiting\x12C\n\x07running\x18\x02\x20\x01(\x0b2).k8s.io.api.co\
    re.v1.ContainerStateRunningR\x07running\x12L\n\nterminated\x18\x03\x20\
    \x01(\x0b2,.k8s.io.api.core.v1.ContainerStateTerminatedR\nterminated\"a\
    \n\x15ContainerStateRunning\x12H\n\tstartedAt\x18\x01\x20\x01(\x0b2*.k8s\
    .io.apimachinery.pkg.apis.meta.v1.TimeR\tstartedAt\"\xb8\x02\n\x18Contai\
    nerStateTerminated\x12\x1a\n\x08exitCode\x18\x01\x20\x01(\x05R\x08exitCo\
    de\x12\x16\n\x06signal\x18\x02\x20\x01(\x05R\x06signal\x12\x16\n\x06reas\
    on\x18\x03\x20\x01(\tR\x06reason\x12\x18\n\x07message\x18\x04\x20\x01(\t\
    R\x07message\x12H\n\tstartedAt\x18\x05\x20\x01(\x0b2*.k8s.io.apimachiner\
    y.pkg.apis.meta.v1.TimeR\tstartedAt\x12J\n\nfinishedAt\x18\x06\x20\x01(\
    \x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\nfinishedAt\x12\x20\n\
    \x0bcontainerID\x18\x07\x20\x01(\tR\x0bcontainerID\"I\n\x15ContainerStat\
    eWaiting\x12\x16\n\x06reason\x18\x01\x20\x01(\tR\x06reason\x12\x18\n\x07\
    message\x18\x02\x20\x01(\tR\x07message\"\xad\x02\n\x0fContainerStatus\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x128\n\x05state\x18\x02\
    \x20\x01(\x0b2\".k8s.io.api.core.v1.ContainerStateR\x05state\x12@\n\tlas\
    tState\x18\x03\x20\x01(\x0b2\".k8s.io.api.core.v1.ContainerStateR\tlastS\
    tate\x12\x14\n\x05ready\x18\x04\x20\x01(\x08R\x05ready\x12\"\n\x0crestar\
    tCount\x18\x05\x20\x01(\x05R\x0crestartCount\x12\x14\n\x05image\x18\x06\
    \x20\x01(\tR\x05image\x12\x18\n\x07imageID\x18\x07\x20\x01(\tR\x07imageI\
    D\x12\x20\n\x0bcontainerID\x18\x08\x20\x01(\tR\x0bcontainerID\"$\n\x0eDa\
    emonEndpoint\x12\x12\n\x04Port\x18\x01\x20\x01(\x05R\x04Port\"\xe2\x01\n\
    \rDeleteOptions\x12.\n\x12gracePeriodSeconds\x18\x01\x20\x01(\x03R\x12gr\
    acePeriodSeconds\x12G\n\rpreconditions\x18\x02\x20\x01(\x0b2!.k8s.io.api\
    .core.v1.PreconditionsR\rpreconditions\x12*\n\x10orphanDependents\x18\
    \x03\x20\x01(\x08R\x10orphanDependents\x12,\n\x11propagationPolicy\x18\
    \x04\x20\x01(\tR\x11propagationPolicy\"X\n\x15DownwardAPIProjection\x12?\
    \n\x05items\x18\x01\x20\x03(\x0b2).k8s.io.api.core.v1.DownwardAPIVolumeF\
    ileR\x05items\"\xdb\x01\n\x15DownwardAPIVolumeFile\x12\x12\n\x04path\x18\
    \x01\x20\x01(\tR\x04path\x12C\n\x08fieldRef\x18\x02\x20\x01(\x0b2'.k8s.i\
    o.api.core.v1.ObjectFieldSelectorR\x08fieldRef\x12U\n\x10resourceFieldRe\
    f\x18\x03\x20\x01(\x0b2).k8s.io.api.core.v1.ResourceFieldSelectorR\x10re\
    sourceFieldRef\x12\x12\n\x04mode\x18\x04\x20\x01(\x05R\x04mode\"|\n\x17D\
    ownwardAPIVolumeSource\x12?\n\x05items\x18\x01\x20\x03(\x0b2).k8s.io.api\
    .core.v1.DownwardAPIVolumeFileR\x05items\x12\x20\n\x0bdefaultMode\x18\
    \x02\x20\x01(\x05R\x0bdefaultMode\"|\n\x14EmptyDirVolumeSource\x12\x16\n\
    \x06medium\x18\x01\x20\x01(\tR\x06medium\x12L\n\tsizeLimit\x18\x02\x20\
    \x01(\x0b2..k8s.io.apimachinery.pkg.api.resource.QuantityR\tsizeLimit\"\
    \x9c\x01\n\x0fEndpointAddress\x12\x0e\n\x02ip\x18\x01\x20\x01(\tR\x02ip\
    \x12\x1a\n\x08hostname\x18\x03\x20\x01(\tR\x08hostname\x12\x1a\n\x08node\
    Name\x18\x04\x20\x01(\tR\x08nodeName\x12A\n\ttargetRef\x18\x02\x20\x01(\
    \x0b2#.k8s.io.api.core.v1.ObjectReferenceR\ttargetRef\"R\n\x0cEndpointPo\
    rt\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04port\x18\
    \x02\x20\x01(\x05R\x04port\x12\x1a\n\x08protocol\x18\x03\x20\x01(\tR\x08\
    protocol\"\xde\x01\n\x0eEndpointSubset\x12A\n\taddresses\x18\x01\x20\x03\
    (\x0b2#.k8s.io.api.core.v1.EndpointAddressR\taddresses\x12Q\n\x11notRead\
    yAddresses\x18\x02\x20\x03(\x0b2#.k8s.io.api.core.v1.EndpointAddressR\
    \x11notReadyAddresses\x126\n\x05ports\x18\x03\x20\x03(\x0b2\x20.k8s.io.a\
    pi.core.v1.EndpointPortR\x05ports\"\x97\x01\n\tEndpoints\x12L\n\x08metad\
    ata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMe\
    taR\x08metadata\x12<\n\x07subsets\x18\x02\x20\x03(\x0b2\".k8s.io.api.cor\
    e.v1.EndpointSubsetR\x07subsets\"\x90\x01\n\rEndpointsList\x12J\n\x08met\
    adata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMe\
    taR\x08metadata\x123\n\x05items\x18\x02\x20\x03(\x0b2\x1d.k8s.io.api.cor\
    e.v1.EndpointsR\x05items\"\xb6\x01\n\rEnvFromSource\x12\x16\n\x06prefix\
    \x18\x01\x20\x01(\tR\x06prefix\x12J\n\x0cconfigMapRef\x18\x02\x20\x01(\
    \x0b2&.k8s.io.api.core.v1.ConfigMapEnvSourceR\x0cconfigMapRef\x12A\n\tse\
    cretRef\x18\x03\x20\x01(\x0b2#.k8s.io.api.core.v1.SecretEnvSourceR\tsecr\
    etRef\"r\n\x06EnvVar\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x12>\n\tvalueFrom\x18\x03\
    \x20\x01(\x0b2\x20.k8s.io.api.core.v1.EnvVarSourceR\tvalueFrom\"\xc9\x02\
    \n\x0cEnvVarSource\x12C\n\x08fieldRef\x18\x01\x20\x01(\x0b2'.k8s.io.api.\
    core.v1.ObjectFieldSelectorR\x08fieldRef\x12U\n\x10resourceFieldRef\x18\
    \x02\x20\x01(\x0b2).k8s.io.api.core.v1.ResourceFieldSelectorR\x10resourc\
    eFieldRef\x12R\n\x0fconfigMapKeyRef\x18\x03\x20\x01(\x0b2(.k8s.io.api.co\
    re.v1.ConfigMapKeySelectorR\x0fconfigMapKeyRef\x12I\n\x0csecretKeyRef\
    \x18\x04\x20\x01(\x0b2%.k8s.io.api.core.v1.SecretKeySelectorR\x0csecretK\
    eyRef\"\xdd\x03\n\x05Event\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s\
    .io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12K\n\x0einvo\
    lvedObject\x18\x02\x20\x01(\x0b2#.k8s.io.api.core.v1.ObjectReferenceR\
    \x0einvolvedObject\x12\x16\n\x06reason\x18\x03\x20\x01(\tR\x06reason\x12\
    \x18\n\x07message\x18\x04\x20\x01(\tR\x07message\x127\n\x06source\x18\
    \x05\x20\x01(\x0b2\x1f.k8s.io.api.core.v1.EventSourceR\x06source\x12R\n\
    \x0efirstTimestamp\x18\x06\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.m\
    eta.v1.TimeR\x0efirstTimestamp\x12P\n\rlastTimestamp\x18\x07\x20\x01(\
    \x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\rlastTimestamp\x12\x14\
    \n\x05count\x18\x08\x20\x01(\x05R\x05count\x12\x12\n\x04type\x18\t\x20\
    \x01(\tR\x04type\"\x88\x01\n\tEventList\x12J\n\x08metadata\x18\x01\x20\
    \x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\
    \x12/\n\x05items\x18\x02\x20\x03(\x0b2\x19.k8s.io.api.core.v1.EventR\x05\
    items\"?\n\x0bEventSource\x12\x1c\n\tcomponent\x18\x01\x20\x01(\tR\tcomp\
    onent\x12\x12\n\x04host\x18\x02\x20\x01(\tR\x04host\"&\n\nExecAction\x12\
    \x18\n\x07command\x18\x01\x20\x03(\tR\x07command\"v\n\x0eFCVolumeSource\
    \x12\x1e\n\ntargetWWNs\x18\x01\x20\x03(\tR\ntargetWWNs\x12\x10\n\x03lun\
    \x18\x02\x20\x01(\x05R\x03lun\x12\x16\n\x06fsType\x18\x03\x20\x01(\tR\
    \x06fsType\x12\x1a\n\x08readOnly\x18\x04\x20\x01(\x08R\x08readOnly\"\xaf\
    \x02\n\x10FlexVolumeSource\x12\x16\n\x06driver\x18\x01\x20\x01(\tR\x06dr\
    iver\x12\x16\n\x06fsType\x18\x02\x20\x01(\tR\x06fsType\x12F\n\tsecretRef\
    \x18\x03\x20\x01(\x0b2(.k8s.io.api.core.v1.LocalObjectReferenceR\tsecret\
    Ref\x12\x1a\n\x08readOnly\x18\x04\x20\x01(\x08R\x08readOnly\x12K\n\x07op\
    tions\x18\x05\x20\x03(\x0b21.k8s.io.api.core.v1.FlexVolumeSource.Options\
    EntryR\x07options\x1a:\n\x0cOptionsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"Y\n\x13FlockerVolumeSource\x12\x20\n\x0bdatasetName\x18\x01\x20\
    \x01(\tR\x0bdatasetName\x12\x20\n\x0bdatasetUUID\x18\x02\x20\x01(\tR\x0b\
    datasetUUID\"\x89\x01\n\x1dGCEPersistentDiskVolumeSource\x12\x16\n\x06pd\
    Name\x18\x01\x20\x01(\tR\x06pdName\x12\x16\n\x06fsType\x18\x02\x20\x01(\
    \tR\x06fsType\x12\x1c\n\tpartition\x18\x03\x20\x01(\x05R\tpartition\x12\
    \x1a\n\x08readOnly\x18\x04\x20\x01(\x08R\x08readOnly\"o\n\x13GitRepoVolu\
    meSource\x12\x1e\n\nrepository\x18\x01\x20\x01(\tR\nrepository\x12\x1a\n\
    \x08revision\x18\x02\x20\x01(\tR\x08revision\x12\x1c\n\tdirectory\x18\
    \x03\x20\x01(\tR\tdirectory\"e\n\x15GlusterfsVolumeSource\x12\x1c\n\tend\
    points\x18\x01\x20\x01(\tR\tendpoints\x12\x12\n\x04path\x18\x02\x20\x01(\
    \tR\x04path\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\"\
    \xd7\x01\n\rHTTPGetAction\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\
    \x12D\n\x04port\x18\x02\x20\x01(\x0b20.k8s.io.apimachinery.pkg.util.ints\
    tr.IntOrStringR\x04port\x12\x12\n\x04host\x18\x03\x20\x01(\tR\x04host\
    \x12\x16\n\x06scheme\x18\x04\x20\x01(\tR\x06scheme\x12@\n\x0bhttpHeaders\
    \x18\x05\x20\x03(\x0b2\x1e.k8s.io.api.core.v1.HTTPHeaderR\x0bhttpHeaders\
    \"6\n\nHTTPHeader\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\
    \n\x05value\x18\x02\x20\x01(\tR\x05value\"\xbd\x01\n\x07Handler\x122\n\
    \x04exec\x18\x01\x20\x01(\x0b2\x1e.k8s.io.api.core.v1.ExecActionR\x04exe\
    c\x12;\n\x07httpGet\x18\x02\x20\x01(\x0b2!.k8s.io.api.core.v1.HTTPGetAct\
    ionR\x07httpGet\x12A\n\ttcpSocket\x18\x03\x20\x01(\x0b2#.k8s.io.api.core\
    .v1.TCPSocketActionR\ttcpSocket\"9\n\tHostAlias\x12\x0e\n\x02ip\x18\x01\
    \x20\x01(\tR\x02ip\x12\x1c\n\thostnames\x18\x02\x20\x03(\tR\thostnames\"\
    *\n\x14HostPathVolumeSource\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04pat\
    h\"\xf1\x02\n\x11ISCSIVolumeSource\x12\"\n\x0ctargetPortal\x18\x01\x20\
    \x01(\tR\x0ctargetPortal\x12\x10\n\x03iqn\x18\x02\x20\x01(\tR\x03iqn\x12\
    \x10\n\x03lun\x18\x03\x20\x01(\x05R\x03lun\x12&\n\x0eiscsiInterface\x18\
    \x04\x20\x01(\tR\x0eiscsiInterface\x12\x16\n\x06fsType\x18\x05\x20\x01(\
    \tR\x06fsType\x12\x1a\n\x08readOnly\x18\x06\x20\x01(\x08R\x08readOnly\
    \x12\x18\n\x07portals\x18\x07\x20\x03(\tR\x07portals\x12,\n\x11chapAuthD\
    iscovery\x18\x08\x20\x01(\x08R\x11chapAuthDiscovery\x12(\n\x0fchapAuthSe\
    ssion\x18\x0b\x20\x01(\x08R\x0fchapAuthSession\x12F\n\tsecretRef\x18\n\
    \x20\x01(\x0b2(.k8s.io.api.core.v1.LocalObjectReferenceR\tsecretRef\"E\n\
    \tKeyToPath\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x12\n\x04pat\
    h\x18\x02\x20\x01(\tR\x04path\x12\x12\n\x04mode\x18\x03\x20\x01(\x05R\
    \x04mode\"}\n\tLifecycle\x129\n\tpostStart\x18\x01\x20\x01(\x0b2\x1b.k8s\
    .io.api.core.v1.HandlerR\tpostStart\x125\n\x07preStop\x18\x02\x20\x01(\
    \x0b2\x1b.k8s.io.api.core.v1.HandlerR\x07preStop\"\x92\x01\n\nLimitRange\
    \x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.\
    meta.v1.ObjectMetaR\x08metadata\x126\n\x04spec\x18\x02\x20\x01(\x0b2\".k\
    8s.io.api.core.v1.LimitRangeSpecR\x04spec\"\xe7\x07\n\x0eLimitRangeItem\
    \x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12=\n\x03max\x18\x02\x20\
    \x03(\x0b2+.k8s.io.api.core.v1.LimitRangeItem.MaxEntryR\x03max\x12=\n\
    \x03min\x18\x03\x20\x03(\x0b2+.k8s.io.api.core.v1.LimitRangeItem.MinEntr\
    yR\x03min\x12I\n\x07default\x18\x04\x20\x03(\x0b2/.k8s.io.api.core.v1.Li\
    mitRangeItem.DefaultEntryR\x07default\x12^\n\x0edefaultRequest\x18\x05\
    \x20\x03(\x0b26.k8s.io.api.core.v1.LimitRangeItem.DefaultRequestEntryR\
    \x0edefaultRequest\x12p\n\x14maxLimitRequestRatio\x18\x06\x20\x03(\x0b2<\
    .k8s.io.api.core.v1.LimitRangeItem.MaxLimitRequestRatioEntryR\x14maxLimi\
    tRequestRatio\x1af\n\x08MaxEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.a\
    pi.resource.QuantityR\x05value:\x028\x01\x1af\n\x08MinEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2\
    ..k8s.io.apimachinery.pkg.api.resource.QuantityR\x05value:\x028\x01\x1aj\
    \n\x0cDefaultEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12D\n\
    \x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.resource.Qu\
    antityR\x05value:\x028\x01\x1aq\n\x13DefaultRequestEntry\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.\
    io.apimachinery.pkg.api.resource.QuantityR\x05value:\x028\x01\x1aw\n\x19\
    MaxLimitRequestRatioEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.reso\
    urce.QuantityR\x05value:\x028\x01\"\x92\x01\n\x0eLimitRangeList\x12J\n\
    \x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1\
    .ListMetaR\x08metadata\x124\n\x05items\x18\x02\x20\x03(\x0b2\x1e.k8s.io.\
    api.core.v1.LimitRangeR\x05items\"L\n\x0eLimitRangeSpec\x12:\n\x06limits\
    \x18\x01\x20\x03(\x0b2\".k8s.io.api.core.v1.LimitRangeItemR\x06limits\"\
    \x97\x01\n\x04List\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apim\
    achinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12C\n\x05items\x18\x02\
    \x20\x03(\x0b2-.k8s.io.apimachinery.pkg.runtime.RawExtensionR\x05items\"\
    \xf5\x01\n\x0bListOptions\x12$\n\rlabelSelector\x18\x01\x20\x01(\tR\rlab\
    elSelector\x12$\n\rfieldSelector\x18\x02\x20\x01(\tR\rfieldSelector\x122\
    \n\x14includeUninitialized\x18\x06\x20\x01(\x08R\x14includeUninitialized\
    \x12\x14\n\x05watch\x18\x03\x20\x01(\x08R\x05watch\x12(\n\x0fresourceVer\
    sion\x18\x04\x20\x01(\tR\x0fresourceVersion\x12&\n\x0etimeoutSeconds\x18\
    \x05\x20\x01(\x03R\x0etimeoutSeconds\"A\n\x13LoadBalancerIngress\x12\x0e\
    \n\x02ip\x18\x01\x20\x01(\tR\x02ip\x12\x1a\n\x08hostname\x18\x02\x20\x01\
    (\tR\x08hostname\"W\n\x12LoadBalancerStatus\x12A\n\x07ingress\x18\x01\
    \x20\x03(\x0b2'.k8s.io.api.core.v1.LoadBalancerIngressR\x07ingress\"*\n\
    \x14LocalObjectReference\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"\
    '\n\x11LocalVolumeSource\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\"\
    Y\n\x0fNFSVolumeSource\x12\x16\n\x06server\x18\x01\x20\x01(\tR\x06server\
    \x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12\x1a\n\x08readOnly\x18\
    \x03\x20\x01(\x08R\x08readOnly\"\xcd\x01\n\tNamespace\x12L\n\x08metadata\
    \x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\
    \x08metadata\x125\n\x04spec\x18\x02\x20\x01(\x0b2!.k8s.io.api.core.v1.Na\
    mespaceSpecR\x04spec\x12;\n\x06status\x18\x03\x20\x01(\x0b2#.k8s.io.api.\
    core.v1.NamespaceStatusR\x06status\"\x90\x01\n\rNamespaceList\x12J\n\x08\
    metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.Lis\
    tMetaR\x08metadata\x123\n\x05items\x18\x02\x20\x03(\x0b2\x1d.k8s.io.api.\
    core.v1.NamespaceR\x05items\"/\n\rNamespaceSpec\x12\x1e\n\nfinalizers\
    \x18\x01\x20\x03(\tR\nfinalizers\"'\n\x0fNamespaceStatus\x12\x14\n\x05ph\
    ase\x18\x01\x20\x01(\tR\x05phase\"\xbe\x01\n\x04Node\x12L\n\x08metadata\
    \x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\
    \x08metadata\x120\n\x04spec\x18\x02\x20\x01(\x0b2\x1c.k8s.io.api.core.v1\
    .NodeSpecR\x04spec\x126\n\x06status\x18\x03\x20\x01(\x0b2\x1e.k8s.io.api\
    .core.v1.NodeStatusR\x06status\";\n\x0bNodeAddress\x12\x12\n\x04type\x18\
    \x01\x20\x01(\tR\x04type\x12\x18\n\x07address\x18\x02\x20\x01(\tR\x07add\
    ress\"\xb1\x02\n\x0cNodeAffinity\x12\x88\x01\n.requiredDuringSchedulingI\
    gnoredDuringExecution\x18\x01\x20\x01(\x0b2\x20.k8s.io.api.core.v1.NodeS\
    electorR.requiredDuringSchedulingIgnoredDuringExecution\x12\x95\x01\n/pr\
    eferredDuringSchedulingIgnoredDuringExecution\x18\x02\x20\x03(\x0b2+.k8s\
    .io.api.core.v1.PreferredSchedulingTermR/preferredDuringSchedulingIgnore\
    dDuringExecution\"\xa3\x02\n\rNodeCondition\x12\x12\n\x04type\x18\x01\
    \x20\x01(\tR\x04type\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\
    \x12X\n\x11lastHeartbeatTime\x18\x03\x20\x01(\x0b2*.k8s.io.apimachinery.\
    pkg.apis.meta.v1.TimeR\x11lastHeartbeatTime\x12Z\n\x12lastTransitionTime\
    \x18\x04\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\x12la\
    stTransitionTime\x12\x16\n\x06reason\x18\x05\x20\x01(\tR\x06reason\x12\
    \x18\n\x07message\x18\x06\x20\x01(\tR\x07message\"c\n\x13NodeDaemonEndpo\
    ints\x12L\n\x0fkubeletEndpoint\x18\x01\x20\x01(\x0b2\".k8s.io.api.core.v\
    1.DaemonEndpointR\x0fkubeletEndpoint\"\x86\x01\n\x08NodeList\x12J\n\x08m\
    etadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.List\
    MetaR\x08metadata\x12.\n\x05items\x18\x02\x20\x03(\x0b2\x18.k8s.io.api.c\
    ore.v1.NodeR\x05items\"&\n\x10NodeProxyOptions\x12\x12\n\x04path\x18\x01\
    \x20\x01(\tR\x04path\"\xc9\x01\n\rNodeResources\x12K\n\x08capacity\x18\
    \x01\x20\x03(\x0b2/.k8s.io.api.core.v1.NodeResources.CapacityEntryR\x08c\
    apacity\x1ak\n\rCapacityEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03ke\
    y\x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.res\
    ource.QuantityR\x05value:\x028\x01\"b\n\x0cNodeSelector\x12R\n\x11nodeSe\
    lectorTerms\x18\x01\x20\x03(\x0b2$.k8s.io.api.core.v1.NodeSelectorTermR\
    \x11nodeSelectorTerms\"_\n\x17NodeSelectorRequirement\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x1a\n\x08operator\x18\x02\x20\x01(\tR\
    \x08operator\x12\x16\n\x06values\x18\x03\x20\x03(\tR\x06values\"k\n\x10N\
    odeSelectorTerm\x12W\n\x10matchExpressions\x18\x01\x20\x03(\x0b2+.k8s.io\
    .api.core.v1.NodeSelectorRequirementR\x10matchExpressions\"\xbd\x01\n\
    \x08NodeSpec\x12\x18\n\x07podCIDR\x18\x01\x20\x01(\tR\x07podCIDR\x12\x1e\
    \n\nexternalID\x18\x02\x20\x01(\tR\nexternalID\x12\x1e\n\nproviderID\x18\
    \x03\x20\x01(\tR\nproviderID\x12$\n\runschedulable\x18\x04\x20\x01(\x08R\
    \runschedulable\x121\n\x06taints\x18\x05\x20\x03(\x0b2\x19.k8s.io.api.co\
    re.v1.TaintR\x06taints\"\xdf\x06\n\nNodeStatus\x12H\n\x08capacity\x18\
    \x01\x20\x03(\x0b2,.k8s.io.api.core.v1.NodeStatus.CapacityEntryR\x08capa\
    city\x12Q\n\x0ballocatable\x18\x02\x20\x03(\x0b2/.k8s.io.api.core.v1.Nod\
    eStatus.AllocatableEntryR\x0ballocatable\x12\x14\n\x05phase\x18\x03\x20\
    \x01(\tR\x05phase\x12A\n\nconditions\x18\x04\x20\x03(\x0b2!.k8s.io.api.c\
    ore.v1.NodeConditionR\nconditions\x12=\n\taddresses\x18\x05\x20\x03(\x0b\
    2\x1f.k8s.io.api.core.v1.NodeAddressR\taddresses\x12Q\n\x0fdaemonEndpoin\
    ts\x18\x06\x20\x01(\x0b2'.k8s.io.api.core.v1.NodeDaemonEndpointsR\x0fdae\
    monEndpoints\x12>\n\x08nodeInfo\x18\x07\x20\x01(\x0b2\".k8s.io.api.core.\
    v1.NodeSystemInfoR\x08nodeInfo\x12:\n\x06images\x18\x08\x20\x03(\x0b2\".\
    k8s.io.api.core.v1.ContainerImageR\x06images\x12\"\n\x0cvolumesInUse\x18\
    \t\x20\x03(\tR\x0cvolumesInUse\x12L\n\x0fvolumesAttached\x18\n\x20\x03(\
    \x0b2\".k8s.io.api.core.v1.AttachedVolumeR\x0fvolumesAttached\x1ak\n\rCa\
    pacityEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\
    \x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.resource.QuantityR\
    \x05value:\x028\x01\x1an\n\x10AllocatableEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimac\
    hinery.pkg.api.resource.QuantityR\x05value:\x028\x01\"\x82\x03\n\x0eNode\
    SystemInfo\x12\x1c\n\tmachineID\x18\x01\x20\x01(\tR\tmachineID\x12\x1e\n\
    \nsystemUUID\x18\x02\x20\x01(\tR\nsystemUUID\x12\x16\n\x06bootID\x18\x03\
    \x20\x01(\tR\x06bootID\x12$\n\rkernelVersion\x18\x04\x20\x01(\tR\rkernel\
    Version\x12\x18\n\x07osImage\x18\x05\x20\x01(\tR\x07osImage\x128\n\x17co\
    ntainerRuntimeVersion\x18\x06\x20\x01(\tR\x17containerRuntimeVersion\x12\
    &\n\x0ekubeletVersion\x18\x07\x20\x01(\tR\x0ekubeletVersion\x12*\n\x10ku\
    beProxyVersion\x18\x08\x20\x01(\tR\x10kubeProxyVersion\x12(\n\x0foperati\
    ngSystem\x18\t\x20\x01(\tR\x0foperatingSystem\x12\"\n\x0carchitecture\
    \x18\n\x20\x01(\tR\x0carchitecture\"S\n\x13ObjectFieldSelector\x12\x1e\n\
    \napiVersion\x18\x01\x20\x01(\tR\napiVersion\x12\x1c\n\tfieldPath\x18\
    \x02\x20\x01(\tR\tfieldPath\"\xda\x07\n\nObjectMeta\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\"\n\x0cgenerateName\x18\x02\x20\x01(\tR\
    \x0cgenerateName\x12\x1c\n\tnamespace\x18\x03\x20\x01(\tR\tnamespace\x12\
    \x1a\n\x08selfLink\x18\x04\x20\x01(\tR\x08selfLink\x12\x10\n\x03uid\x18\
    \x05\x20\x01(\tR\x03uid\x12(\n\x0fresourceVersion\x18\x06\x20\x01(\tR\
    \x0fresourceVersion\x12\x1e\n\ngeneration\x18\x07\x20\x01(\x03R\ngenerat\
    ion\x12X\n\x11creationTimestamp\x18\x08\x20\x01(\x0b2*.k8s.io.apimachine\
    ry.pkg.apis.meta.v1.TimeR\x11creationTimestamp\x12X\n\x11deletionTimesta\
    mp\x18\t\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\x11de\
    letionTimestamp\x12>\n\x1adeletionGracePeriodSeconds\x18\n\x20\x01(\x03R\
    \x1adeletionGracePeriodSeconds\x12B\n\x06labels\x18\x0b\x20\x03(\x0b2*.k\
    8s.io.api.core.v1.ObjectMeta.LabelsEntryR\x06labels\x12Q\n\x0bannotation\
    s\x18\x0c\x20\x03(\x0b2/.k8s.io.api.core.v1.ObjectMeta.AnnotationsEntryR\
    \x0bannotations\x12^\n\x0fownerReferences\x18\r\x20\x03(\x0b24.k8s.io.ap\
    imachinery.pkg.apis.meta.v1.OwnerReferenceR\x0fownerReferences\x12V\n\
    \x0cinitializers\x18\x10\x20\x01(\x0b22.k8s.io.apimachinery.pkg.apis.met\
    a.v1.InitializersR\x0cinitializers\x12\x1e\n\nfinalizers\x18\x0e\x20\x03\
    (\tR\nfinalizers\x12\x20\n\x0bclusterName\x18\x0f\x20\x01(\tR\x0bcluster\
    Name\x1a9\n\x0bLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a>\n\x10Ann\
    otationsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xd1\x01\n\x0fObjectReferen\
    ce\x12\x12\n\x04kind\x18\x01\x20\x01(\tR\x04kind\x12\x1c\n\tnamespace\
    \x18\x02\x20\x01(\tR\tnamespace\x12\x12\n\x04name\x18\x03\x20\x01(\tR\
    \x04name\x12\x10\n\x03uid\x18\x04\x20\x01(\tR\x03uid\x12\x1e\n\napiVersi\
    on\x18\x05\x20\x01(\tR\napiVersion\x12(\n\x0fresourceVersion\x18\x06\x20\
    \x01(\tR\x0fresourceVersion\x12\x1c\n\tfieldPath\x18\x07\x20\x01(\tR\tfi\
    eldPath\"\xe2\x01\n\x10PersistentVolume\x12L\n\x08metadata\x18\x01\x20\
    \x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\
    \x12<\n\x04spec\x18\x02\x20\x01(\x0b2(.k8s.io.api.core.v1.PersistentVolu\
    meSpecR\x04spec\x12B\n\x06status\x18\x03\x20\x01(\x0b2*.k8s.io.api.core.\
    v1.PersistentVolumeStatusR\x06status\"\xf1\x01\n\x15PersistentVolumeClai\
    m\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis\
    .meta.v1.ObjectMetaR\x08metadata\x12A\n\x04spec\x18\x02\x20\x01(\x0b2-.k\
    8s.io.api.core.v1.PersistentVolumeClaimSpecR\x04spec\x12G\n\x06status\
    \x18\x03\x20\x01(\x0b2/.k8s.io.api.core.v1.PersistentVolumeClaimStatusR\
    \x06status\"\xa8\x01\n\x19PersistentVolumeClaimList\x12J\n\x08metadata\
    \x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\
    \x08metadata\x12?\n\x05items\x18\x02\x20\x03(\x0b2).k8s.io.api.core.v1.P\
    ersistentVolumeClaimR\x05items\"\xa2\x02\n\x19PersistentVolumeClaimSpec\
    \x12\x20\n\x0baccessModes\x18\x01\x20\x03(\tR\x0baccessModes\x12O\n\x08s\
    elector\x18\x04\x20\x01(\x0b23.k8s.io.apimachinery.pkg.apis.meta.v1.Labe\
    lSelectorR\x08selector\x12F\n\tresources\x18\x02\x20\x01(\x0b2(.k8s.io.a\
    pi.core.v1.ResourceRequirementsR\tresources\x12\x1e\n\nvolumeName\x18\
    \x03\x20\x01(\tR\nvolumeName\x12*\n\x10storageClassName\x18\x05\x20\x01(\
    \tR\x10storageClassName\"\x9d\x02\n\x1bPersistentVolumeClaimStatus\x12\
    \x14\n\x05phase\x18\x01\x20\x01(\tR\x05phase\x12\x20\n\x0baccessModes\
    \x18\x02\x20\x03(\tR\x0baccessModes\x12Y\n\x08capacity\x18\x03\x20\x03(\
    \x0b2=.k8s.io.api.core.v1.PersistentVolumeClaimStatus.CapacityEntryR\x08\
    capacity\x1ak\n\rCapacityEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.re\
    source.QuantityR\x05value:\x028\x01\"]\n!PersistentVolumeClaimVolumeSour\
    ce\x12\x1c\n\tclaimName\x18\x01\x20\x01(\tR\tclaimName\x12\x1a\n\x08read\
    Only\x18\x02\x20\x01(\x08R\x08readOnly\"\x9e\x01\n\x14PersistentVolumeLi\
    st\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api\
    s.meta.v1.ListMetaR\x08metadata\x12:\n\x05items\x18\x02\x20\x03(\x0b2$.k\
    8s.io.api.core.v1.PersistentVolumeR\x05items\"\x98\x0c\n\x16PersistentVo\
    lumeSource\x12_\n\x11gcePersistentDisk\x18\x01\x20\x01(\x0b21.k8s.io.api\
    .core.v1.GCEPersistentDiskVolumeSourceR\x11gcePersistentDisk\x12h\n\x14a\
    wsElasticBlockStore\x18\x02\x20\x01(\x0b24.k8s.io.api.core.v1.AWSElastic\
    BlockStoreVolumeSourceR\x14awsElasticBlockStore\x12D\n\x08hostPath\x18\
    \x03\x20\x01(\x0b2(.k8s.io.api.core.v1.HostPathVolumeSourceR\x08hostPath\
    \x12G\n\tglusterfs\x18\x04\x20\x01(\x0b2).k8s.io.api.core.v1.GlusterfsVo\
    lumeSourceR\tglusterfs\x125\n\x03nfs\x18\x05\x20\x01(\x0b2#.k8s.io.api.c\
    ore.v1.NFSVolumeSourceR\x03nfs\x125\n\x03rbd\x18\x06\x20\x01(\x0b2#.k8s.\
    io.api.core.v1.RBDVolumeSourceR\x03rbd\x12;\n\x05iscsi\x18\x07\x20\x01(\
    \x0b2%.k8s.io.api.core.v1.ISCSIVolumeSourceR\x05iscsi\x12>\n\x06cinder\
    \x18\x08\x20\x01(\x0b2&.k8s.io.api.core.v1.CinderVolumeSourceR\x06cinder\
    \x12>\n\x06cephfs\x18\t\x20\x01(\x0b2&.k8s.io.api.core.v1.CephFSVolumeSo\
    urceR\x06cephfs\x122\n\x02fc\x18\n\x20\x01(\x0b2\".k8s.io.api.core.v1.FC\
    VolumeSourceR\x02fc\x12A\n\x07flocker\x18\x0b\x20\x01(\x0b2'.k8s.io.api.\
    core.v1.FlockerVolumeSourceR\x07flocker\x12D\n\nflexVolume\x18\x0c\x20\
    \x01(\x0b2$.k8s.io.api.core.v1.FlexVolumeSourceR\nflexVolume\x12G\n\tazu\
    reFile\x18\r\x20\x01(\x0b2).k8s.io.api.core.v1.AzureFileVolumeSourceR\ta\
    zureFile\x12X\n\rvsphereVolume\x18\x0e\x20\x01(\x0b22.k8s.io.api.core.v1\
    .VsphereVirtualDiskVolumeSourceR\rvsphereVolume\x12A\n\x07quobyte\x18\
    \x0f\x20\x01(\x0b2'.k8s.io.api.core.v1.QuobyteVolumeSourceR\x07quobyte\
    \x12G\n\tazureDisk\x18\x10\x20\x01(\x0b2).k8s.io.api.core.v1.AzureDiskVo\
    lumeSourceR\tazureDisk\x12h\n\x14photonPersistentDisk\x18\x11\x20\x01(\
    \x0b24.k8s.io.api.core.v1.PhotonPersistentDiskVolumeSourceR\x14photonPer\
    sistentDisk\x12P\n\x0eportworxVolume\x18\x12\x20\x01(\x0b2(.k8s.io.api.c\
    ore.v1.PortworxVolumeSourceR\x0eportworxVolume\x12A\n\x07scaleIO\x18\x13\
    \x20\x01(\x0b2'.k8s.io.api.core.v1.ScaleIOVolumeSourceR\x07scaleIO\x12;\
    \n\x05local\x18\x14\x20\x01(\x0b2%.k8s.io.api.core.v1.LocalVolumeSourceR\
    \x05local\x12Q\n\tstorageos\x18\x15\x20\x01(\x0b23.k8s.io.api.core.v1.St\
    orageOSPersistentVolumeSourceR\tstorageos\"\x90\x04\n\x14PersistentVolum\
    eSpec\x12R\n\x08capacity\x18\x01\x20\x03(\x0b26.k8s.io.api.core.v1.Persi\
    stentVolumeSpec.CapacityEntryR\x08capacity\x12b\n\x16persistentVolumeSou\
    rce\x18\x02\x20\x01(\x0b2*.k8s.io.api.core.v1.PersistentVolumeSourceR\
    \x16persistentVolumeSource\x12\x20\n\x0baccessModes\x18\x03\x20\x03(\tR\
    \x0baccessModes\x12?\n\x08claimRef\x18\x04\x20\x01(\x0b2#.k8s.io.api.cor\
    e.v1.ObjectReferenceR\x08claimRef\x12D\n\x1dpersistentVolumeReclaimPolic\
    y\x18\x05\x20\x01(\tR\x1dpersistentVolumeReclaimPolicy\x12*\n\x10storage\
    ClassName\x18\x06\x20\x01(\tR\x10storageClassName\x1ak\n\rCapacityEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\
    \x01(\x0b2..k8s.io.apimachinery.pkg.api.resource.QuantityR\x05value:\x02\
    8\x01\"`\n\x16PersistentVolumeStatus\x12\x14\n\x05phase\x18\x01\x20\x01(\
    \tR\x05phase\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\x12\x16\
    \n\x06reason\x18\x03\x20\x01(\tR\x06reason\"N\n\x20PhotonPersistentDiskV\
    olumeSource\x12\x12\n\x04pdID\x18\x01\x20\x01(\tR\x04pdID\x12\x16\n\x06f\
    sType\x18\x02\x20\x01(\tR\x06fsType\"\xbb\x01\n\x03Pod\x12L\n\x08metadat\
    a\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta\
    R\x08metadata\x12/\n\x04spec\x18\x02\x20\x01(\x0b2\x1b.k8s.io.api.core.v\
    1.PodSpecR\x04spec\x125\n\x06status\x18\x03\x20\x01(\x0b2\x1d.k8s.io.api\
    .core.v1.PodStatusR\x06status\"\xb3\x02\n\x0bPodAffinity\x12\x8b\x01\n.r\
    equiredDuringSchedulingIgnoredDuringExecution\x18\x01\x20\x03(\x0b2#.k8s\
    .io.api.core.v1.PodAffinityTermR.requiredDuringSchedulingIgnoredDuringEx\
    ecution\x12\x95\x01\n/preferredDuringSchedulingIgnoredDuringExecution\
    \x18\x02\x20\x03(\x0b2+.k8s.io.api.core.v1.WeightedPodAffinityTermR/pref\
    erredDuringSchedulingIgnoredDuringExecution\"\xae\x01\n\x0fPodAffinityTe\
    rm\x12Y\n\rlabelSelector\x18\x01\x20\x01(\x0b23.k8s.io.apimachinery.pkg.\
    apis.meta.v1.LabelSelectorR\rlabelSelector\x12\x1e\n\nnamespaces\x18\x02\
    \x20\x03(\tR\nnamespaces\x12\x20\n\x0btopologyKey\x18\x03\x20\x01(\tR\
    \x0btopologyKey\"\xb7\x02\n\x0fPodAntiAffinity\x12\x8b\x01\n.requiredDur\
    ingSchedulingIgnoredDuringExecution\x18\x01\x20\x03(\x0b2#.k8s.io.api.co\
    re.v1.PodAffinityTermR.requiredDuringSchedulingIgnoredDuringExecution\
    \x12\x95\x01\n/preferredDuringSchedulingIgnoredDuringExecution\x18\x02\
    \x20\x03(\x0b2+.k8s.io.api.core.v1.WeightedPodAffinityTermR/preferredDur\
    ingSchedulingIgnoredDuringExecution\"\x88\x01\n\x10PodAttachOptions\x12\
    \x14\n\x05stdin\x18\x01\x20\x01(\x08R\x05stdin\x12\x16\n\x06stdout\x18\
    \x02\x20\x01(\x08R\x06stdout\x12\x16\n\x06stderr\x18\x03\x20\x01(\x08R\
    \x06stderr\x12\x10\n\x03tty\x18\x04\x20\x01(\x08R\x03tty\x12\x1c\n\tcont\
    ainer\x18\x05\x20\x01(\tR\tcontainer\"\x9a\x02\n\x0cPodCondition\x12\x12\
    \n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06status\x18\x02\x20\
    \x01(\tR\x06status\x12P\n\rlastProbeTime\x18\x03\x20\x01(\x0b2*.k8s.io.a\
    pimachinery.pkg.apis.meta.v1.TimeR\rlastProbeTime\x12Z\n\x12lastTransiti\
    onTime\x18\x04\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\
    \x12lastTransitionTime\x12\x16\n\x06reason\x18\x05\x20\x01(\tR\x06reason\
    \x12\x18\n\x07message\x18\x06\x20\x01(\tR\x07message\"\xa0\x01\n\x0ePodE\
    xecOptions\x12\x14\n\x05stdin\x18\x01\x20\x01(\x08R\x05stdin\x12\x16\n\
    \x06stdout\x18\x02\x20\x01(\x08R\x06stdout\x12\x16\n\x06stderr\x18\x03\
    \x20\x01(\x08R\x06stderr\x12\x10\n\x03tty\x18\x04\x20\x01(\x08R\x03tty\
    \x12\x1c\n\tcontainer\x18\x05\x20\x01(\tR\tcontainer\x12\x18\n\x07comman\
    d\x18\x06\x20\x03(\tR\x07command\"\x84\x01\n\x07PodList\x12J\n\x08metada\
    ta\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\
    \x08metadata\x12-\n\x05items\x18\x02\x20\x03(\x0b2\x17.k8s.io.api.core.v\
    1.PodR\x05items\"\xad\x02\n\rPodLogOptions\x12\x1c\n\tcontainer\x18\x01\
    \x20\x01(\tR\tcontainer\x12\x16\n\x06follow\x18\x02\x20\x01(\x08R\x06fol\
    low\x12\x1a\n\x08previous\x18\x03\x20\x01(\x08R\x08previous\x12\"\n\x0cs\
    inceSeconds\x18\x04\x20\x01(\x03R\x0csinceSeconds\x12H\n\tsinceTime\x18\
    \x05\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\tsinceTim\
    e\x12\x1e\n\ntimestamps\x18\x06\x20\x01(\x08R\ntimestamps\x12\x1c\n\ttai\
    lLines\x18\x07\x20\x01(\x03R\ttailLines\x12\x1e\n\nlimitBytes\x18\x08\
    \x20\x01(\x03R\nlimitBytes\"-\n\x15PodPortForwardOptions\x12\x14\n\x05po\
    rts\x18\x01\x20\x03(\x05R\x05ports\"%\n\x0fPodProxyOptions\x12\x12\n\x04\
    path\x18\x01\x20\x01(\tR\x04path\"\xec\x01\n\x12PodSecurityContext\x12J\
    \n\x0eseLinuxOptions\x18\x01\x20\x01(\x0b2\".k8s.io.api.core.v1.SELinuxO\
    ptionsR\x0eseLinuxOptions\x12\x1c\n\trunAsUser\x18\x02\x20\x01(\x03R\tru\
    nAsUser\x12\"\n\x0crunAsNonRoot\x18\x03\x20\x01(\x08R\x0crunAsNonRoot\
    \x12.\n\x12supplementalGroups\x18\x04\x20\x03(\x03R\x12supplementalGroup\
    s\x12\x18\n\x07fsGroup\x18\x05\x20\x01(\x03R\x07fsGroup\"j\n\x0cPodSigna\
    ture\x12Z\n\rpodController\x18\x01\x20\x01(\x0b24.k8s.io.apimachinery.pk\
    g.apis.meta.v1.OwnerReferenceR\rpodController\"\xb6\n\n\x07PodSpec\x124\
    \n\x07volumes\x18\x01\x20\x03(\x0b2\x1a.k8s.io.api.core.v1.VolumeR\x07vo\
    lumes\x12E\n\x0einitContainers\x18\x14\x20\x03(\x0b2\x1d.k8s.io.api.core\
    .v1.ContainerR\x0einitContainers\x12=\n\ncontainers\x18\x02\x20\x03(\x0b\
    2\x1d.k8s.io.api.core.v1.ContainerR\ncontainers\x12$\n\rrestartPolicy\
    \x18\x03\x20\x01(\tR\rrestartPolicy\x12D\n\x1dterminationGracePeriodSeco\
    nds\x18\x04\x20\x01(\x03R\x1dterminationGracePeriodSeconds\x124\n\x15act\
    iveDeadlineSeconds\x18\x05\x20\x01(\x03R\x15activeDeadlineSeconds\x12\
    \x1c\n\tdnsPolicy\x18\x06\x20\x01(\tR\tdnsPolicy\x12Q\n\x0cnodeSelector\
    \x18\x07\x20\x03(\x0b2-.k8s.io.api.core.v1.PodSpec.NodeSelectorEntryR\
    \x0cnodeSelector\x12.\n\x12serviceAccountName\x18\x08\x20\x01(\tR\x12ser\
    viceAccountName\x12&\n\x0eserviceAccount\x18\t\x20\x01(\tR\x0eserviceAcc\
    ount\x12B\n\x1cautomountServiceAccountToken\x18\x15\x20\x01(\x08R\x1caut\
    omountServiceAccountToken\x12\x1a\n\x08nodeName\x18\n\x20\x01(\tR\x08nod\
    eName\x12\x20\n\x0bhostNetwork\x18\x0b\x20\x01(\x08R\x0bhostNetwork\x12\
    \x18\n\x07hostPID\x18\x0c\x20\x01(\x08R\x07hostPID\x12\x18\n\x07hostIPC\
    \x18\r\x20\x01(\x08R\x07hostIPC\x12P\n\x0fsecurityContext\x18\x0e\x20\
    \x01(\x0b2&.k8s.io.api.core.v1.PodSecurityContextR\x0fsecurityContext\
    \x12T\n\x10imagePullSecrets\x18\x0f\x20\x03(\x0b2(.k8s.io.api.core.v1.Lo\
    calObjectReferenceR\x10imagePullSecrets\x12\x1a\n\x08hostname\x18\x10\
    \x20\x01(\tR\x08hostname\x12\x1c\n\tsubdomain\x18\x11\x20\x01(\tR\tsubdo\
    main\x128\n\x08affinity\x18\x12\x20\x01(\x0b2\x1c.k8s.io.api.core.v1.Aff\
    inityR\x08affinity\x12$\n\rschedulerName\x18\x13\x20\x01(\tR\rschedulerN\
    ame\x12@\n\x0btolerations\x18\x16\x20\x03(\x0b2\x1e.k8s.io.api.core.v1.T\
    olerationR\x0btolerations\x12?\n\x0bhostAliases\x18\x17\x20\x03(\x0b2\
    \x1d.k8s.io.api.core.v1.HostAliasR\x0bhostAliases\x12,\n\x11priorityClas\
    sName\x18\x18\x20\x01(\tR\x11priorityClassName\x12\x1a\n\x08priority\x18\
    \x19\x20\x01(\x05R\x08priority\x1a?\n\x11NodeSelectorEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\
    \x05value:\x028\x01\"\xd7\x03\n\tPodStatus\x12\x14\n\x05phase\x18\x01\
    \x20\x01(\tR\x05phase\x12@\n\nconditions\x18\x02\x20\x03(\x0b2\x20.k8s.i\
    o.api.core.v1.PodConditionR\nconditions\x12\x18\n\x07message\x18\x03\x20\
    \x01(\tR\x07message\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reason\
    \x12\x16\n\x06hostIP\x18\x05\x20\x01(\tR\x06hostIP\x12\x14\n\x05podIP\
    \x18\x06\x20\x01(\tR\x05podIP\x12H\n\tstartTime\x18\x07\x20\x01(\x0b2*.k\
    8s.io.apimachinery.pkg.apis.meta.v1.TimeR\tstartTime\x12Y\n\x15initConta\
    inerStatuses\x18\n\x20\x03(\x0b2#.k8s.io.api.core.v1.ContainerStatusR\
    \x15initContainerStatuses\x12Q\n\x11containerStatuses\x18\x08\x20\x03(\
    \x0b2#.k8s.io.api.core.v1.ContainerStatusR\x11containerStatuses\x12\x1a\
    \n\x08qosClass\x18\t\x20\x01(\tR\x08qosClass\"\x96\x01\n\x0fPodStatusRes\
    ult\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.ap\
    is.meta.v1.ObjectMetaR\x08metadata\x125\n\x06status\x18\x02\x20\x01(\x0b\
    2\x1d.k8s.io.api.core.v1.PodStatusR\x06status\"\x9c\x01\n\x0bPodTemplate\
    \x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.\
    meta.v1.ObjectMetaR\x08metadata\x12?\n\x08template\x18\x02\x20\x01(\x0b2\
    #.k8s.io.api.core.v1.PodTemplateSpecR\x08template\"\x94\x01\n\x0fPodTemp\
    lateList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.p\
    kg.apis.meta.v1.ListMetaR\x08metadata\x125\n\x05items\x18\x02\x20\x03(\
    \x0b2\x1f.k8s.io.api.core.v1.PodTemplateR\x05items\"\x90\x01\n\x0fPodTem\
    plateSpec\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.\
    pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12/\n\x04spec\x18\x02\x20\x01(\
    \x0b2\x1b.k8s.io.api.core.v1.PodSpecR\x04spec\"f\n\x14PortworxVolumeSour\
    ce\x12\x1a\n\x08volumeID\x18\x01\x20\x01(\tR\x08volumeID\x12\x16\n\x06fs\
    Type\x18\x02\x20\x01(\tR\x06fsType\x12\x1a\n\x08readOnly\x18\x03\x20\x01\
    (\x08R\x08readOnly\"!\n\rPreconditions\x12\x10\n\x03uid\x18\x01\x20\x01(\
    \tR\x03uid\"\xde\x01\n\x14PreferAvoidPodsEntry\x12D\n\x0cpodSignature\
    \x18\x01\x20\x01(\x0b2\x20.k8s.io.api.core.v1.PodSignatureR\x0cpodSignat\
    ure\x12N\n\x0cevictionTime\x18\x02\x20\x01(\x0b2*.k8s.io.apimachinery.pk\
    g.apis.meta.v1.TimeR\x0cevictionTime\x12\x16\n\x06reason\x18\x03\x20\x01\
    (\tR\x06reason\x12\x18\n\x07message\x18\x04\x20\x01(\tR\x07message\"w\n\
    \x17PreferredSchedulingTerm\x12\x16\n\x06weight\x18\x01\x20\x01(\x05R\
    \x06weight\x12D\n\npreference\x18\x02\x20\x01(\x0b2$.k8s.io.api.core.v1.\
    NodeSelectorTermR\npreference\"\x96\x02\n\x05Probe\x125\n\x07handler\x18\
    \x01\x20\x01(\x0b2\x1b.k8s.io.api.core.v1.HandlerR\x07handler\x120\n\x13\
    initialDelaySeconds\x18\x02\x20\x01(\x05R\x13initialDelaySeconds\x12&\n\
    \x0etimeoutSeconds\x18\x03\x20\x01(\x05R\x0etimeoutSeconds\x12$\n\rperio\
    dSeconds\x18\x04\x20\x01(\x05R\rperiodSeconds\x12*\n\x10successThreshold\
    \x18\x05\x20\x01(\x05R\x10successThreshold\x12*\n\x10failureThreshold\
    \x18\x06\x20\x01(\x05R\x10failureThreshold\"y\n\x15ProjectedVolumeSource\
    \x12>\n\x07sources\x18\x01\x20\x03(\x0b2$.k8s.io.api.core.v1.VolumeProje\
    ctionR\x07sources\x12\x20\n\x0bdefaultMode\x18\x02\x20\x01(\x05R\x0bdefa\
    ultMode\"\x8f\x01\n\x13QuobyteVolumeSource\x12\x1a\n\x08registry\x18\x01\
    \x20\x01(\tR\x08registry\x12\x16\n\x06volume\x18\x02\x20\x01(\tR\x06volu\
    me\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\x12\x12\n\x04\
    user\x18\x04\x20\x01(\tR\x04user\x12\x14\n\x05group\x18\x05\x20\x01(\tR\
    \x05group\"\x81\x02\n\x0fRBDVolumeSource\x12\x1a\n\x08monitors\x18\x01\
    \x20\x03(\tR\x08monitors\x12\x14\n\x05image\x18\x02\x20\x01(\tR\x05image\
    \x12\x16\n\x06fsType\x18\x03\x20\x01(\tR\x06fsType\x12\x12\n\x04pool\x18\
    \x04\x20\x01(\tR\x04pool\x12\x12\n\x04user\x18\x05\x20\x01(\tR\x04user\
    \x12\x18\n\x07keyring\x18\x06\x20\x01(\tR\x07keyring\x12F\n\tsecretRef\
    \x18\x07\x20\x01(\x0b2(.k8s.io.api.core.v1.LocalObjectReferenceR\tsecret\
    Ref\x12\x1a\n\x08readOnly\x18\x08\x20\x01(\x08R\x08readOnly\"\x89\x01\n\
    \x0fRangeAllocation\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.api\
    machinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12\x14\n\x05range\
    \x18\x02\x20\x01(\tR\x05range\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\
    \x04data\"\xf1\x01\n\x15ReplicationController\x12L\n\x08metadata\x18\x01\
    \x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08meta\
    data\x12A\n\x04spec\x18\x02\x20\x01(\x0b2-.k8s.io.api.core.v1.Replicatio\
    nControllerSpecR\x04spec\x12G\n\x06status\x18\x03\x20\x01(\x0b2/.k8s.io.\
    api.core.v1.ReplicationControllerStatusR\x06status\"\xda\x01\n\x1eReplic\
    ationControllerCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\
    \x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12Z\n\x12lastTransit\
    ionTime\x18\x03\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.Time\
    R\x12lastTransitionTime\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reaso\
    n\x12\x18\n\x07message\x18\x05\x20\x01(\tR\x07message\"\xa8\x01\n\x19Rep\
    licationControllerList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.\
    apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12?\n\x05items\x18\
    \x02\x20\x03(\x0b2).k8s.io.api.core.v1.ReplicationControllerR\x05items\"\
    \xb8\x02\n\x19ReplicationControllerSpec\x12\x1a\n\x08replicas\x18\x01\
    \x20\x01(\x05R\x08replicas\x12(\n\x0fminReadySeconds\x18\x04\x20\x01(\
    \x05R\x0fminReadySeconds\x12W\n\x08selector\x18\x02\x20\x03(\x0b2;.k8s.i\
    o.api.core.v1.ReplicationControllerSpec.SelectorEntryR\x08selector\x12?\
    \n\x08template\x18\x03\x20\x01(\x0b2#.k8s.io.api.core.v1.PodTemplateSpec\
    R\x08template\x1a;\n\rSelectorEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xc5\
    \x02\n\x1bReplicationControllerStatus\x12\x1a\n\x08replicas\x18\x01\x20\
    \x01(\x05R\x08replicas\x122\n\x14fullyLabeledReplicas\x18\x02\x20\x01(\
    \x05R\x14fullyLabeledReplicas\x12$\n\rreadyReplicas\x18\x04\x20\x01(\x05\
    R\rreadyReplicas\x12,\n\x11availableReplicas\x18\x05\x20\x01(\x05R\x11av\
    ailableReplicas\x12.\n\x12observedGeneration\x18\x03\x20\x01(\x03R\x12ob\
    servedGeneration\x12R\n\nconditions\x18\x06\x20\x03(\x0b22.k8s.io.api.co\
    re.v1.ReplicationControllerConditionR\nconditions\"\xa3\x01\n\x15Resourc\
    eFieldSelector\x12$\n\rcontainerName\x18\x01\x20\x01(\tR\rcontainerName\
    \x12\x1a\n\x08resource\x18\x02\x20\x01(\tR\x08resource\x12H\n\x07divisor\
    \x18\x03\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.resource.QuantityR\
    \x07divisor\"\xd9\x01\n\rResourceQuota\x12L\n\x08metadata\x18\x01\x20\
    \x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\
    \x129\n\x04spec\x18\x02\x20\x01(\x0b2%.k8s.io.api.core.v1.ResourceQuotaS\
    pecR\x04spec\x12?\n\x06status\x18\x03\x20\x01(\x0b2'.k8s.io.api.core.v1.\
    ResourceQuotaStatusR\x06status\"\x98\x01\n\x11ResourceQuotaList\x12J\n\
    \x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1\
    .ListMetaR\x08metadata\x127\n\x05items\x18\x02\x20\x03(\x0b2!.k8s.io.api\
    .core.v1.ResourceQuotaR\x05items\"\xd9\x01\n\x11ResourceQuotaSpec\x12C\n\
    \x04hard\x18\x01\x20\x03(\x0b2/.k8s.io.api.core.v1.ResourceQuotaSpec.Har\
    dEntryR\x04hard\x12\x16\n\x06scopes\x18\x02\x20\x03(\tR\x06scopes\x1ag\n\
    \tHardEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\
    \x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.resource.QuantityR\
    \x05value:\x028\x01\"\xf5\x02\n\x13ResourceQuotaStatus\x12E\n\x04hard\
    \x18\x01\x20\x03(\x0b21.k8s.io.api.core.v1.ResourceQuotaStatus.HardEntry\
    R\x04hard\x12E\n\x04used\x18\x02\x20\x03(\x0b21.k8s.io.api.core.v1.Resou\
    rceQuotaStatus.UsedEntryR\x04used\x1ag\n\tHardEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.ap\
    imachinery.pkg.api.resource.QuantityR\x05value:\x028\x01\x1ag\n\tUsedEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\
    \x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.resource.QuantityR\x05value:\
    \x028\x01\"\x90\x03\n\x14ResourceRequirements\x12L\n\x06limits\x18\x01\
    \x20\x03(\x0b24.k8s.io.api.core.v1.ResourceRequirements.LimitsEntryR\x06\
    limits\x12R\n\x08requests\x18\x02\x20\x03(\x0b26.k8s.io.api.core.v1.Reso\
    urceRequirements.RequestsEntryR\x08requests\x1ai\n\x0bLimitsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01\
    (\x0b2..k8s.io.apimachinery.pkg.api.resource.QuantityR\x05value:\x028\
    \x01\x1ak\n\rRequestsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.reso\
    urce.QuantityR\x05value:\x028\x01\"b\n\x0eSELinuxOptions\x12\x12\n\x04us\
    er\x18\x01\x20\x01(\tR\x04user\x12\x12\n\x04role\x18\x02\x20\x01(\tR\x04\
    role\x12\x12\n\x04type\x18\x03\x20\x01(\tR\x04type\x12\x14\n\x05level\
    \x18\x04\x20\x01(\tR\x05level\"\xf3\x02\n\x13ScaleIOVolumeSource\x12\x18\
    \n\x07gateway\x18\x01\x20\x01(\tR\x07gateway\x12\x16\n\x06system\x18\x02\
    \x20\x01(\tR\x06system\x12F\n\tsecretRef\x18\x03\x20\x01(\x0b2(.k8s.io.a\
    pi.core.v1.LocalObjectReferenceR\tsecretRef\x12\x1e\n\nsslEnabled\x18\
    \x04\x20\x01(\x08R\nsslEnabled\x12*\n\x10protectionDomain\x18\x05\x20\
    \x01(\tR\x10protectionDomain\x12\x20\n\x0bstoragePool\x18\x06\x20\x01(\t\
    R\x0bstoragePool\x12\x20\n\x0bstorageMode\x18\x07\x20\x01(\tR\x0bstorage\
    Mode\x12\x1e\n\nvolumeName\x18\x08\x20\x01(\tR\nvolumeName\x12\x16\n\x06\
    fsType\x18\t\x20\x01(\tR\x06fsType\x12\x1a\n\x08readOnly\x18\n\x20\x01(\
    \x08R\x08readOnly\"\xe8\x02\n\x06Secret\x12L\n\x08metadata\x18\x01\x20\
    \x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\
    \x128\n\x04data\x18\x02\x20\x03(\x0b2$.k8s.io.api.core.v1.Secret.DataEnt\
    ryR\x04data\x12J\n\nstringData\x18\x04\x20\x03(\x0b2*.k8s.io.api.core.v1\
    .Secret.StringDataEntryR\nstringData\x12\x12\n\x04type\x18\x03\x20\x01(\
    \tR\x04type\x1a7\n\tDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03ke\
    y\x12\x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value:\x028\x01\x1a=\n\x0f\
    StringDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x8b\x01\n\x0fSecretEn\
    vSource\x12\\\n\x14localObjectReference\x18\x01\x20\x01(\x0b2(.k8s.io.ap\
    i.core.v1.LocalObjectReferenceR\x14localObjectReference\x12\x1a\n\x08opt\
    ional\x18\x02\x20\x01(\x08R\x08optional\"\x9f\x01\n\x11SecretKeySelector\
    \x12\\\n\x14localObjectReference\x18\x01\x20\x01(\x0b2(.k8s.io.api.core.\
    v1.LocalObjectReferenceR\x14localObjectReference\x12\x10\n\x03key\x18\
    \x02\x20\x01(\tR\x03key\x12\x1a\n\x08optional\x18\x03\x20\x01(\x08R\x08o\
    ptional\"\x8a\x01\n\nSecretList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2\
    ..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x120\n\x05i\
    tems\x18\x02\x20\x03(\x0b2\x1a.k8s.io.api.core.v1.SecretR\x05items\"\xc1\
    \x01\n\x10SecretProjection\x12\\\n\x14localObjectReference\x18\x01\x20\
    \x01(\x0b2(.k8s.io.api.core.v1.LocalObjectReferenceR\x14localObjectRefer\
    ence\x123\n\x05items\x18\x02\x20\x03(\x0b2\x1d.k8s.io.api.core.v1.KeyToP\
    athR\x05items\x12\x1a\n\x08optional\x18\x04\x20\x01(\x08R\x08optional\"\
    \xa7\x01\n\x12SecretVolumeSource\x12\x1e\n\nsecretName\x18\x01\x20\x01(\
    \tR\nsecretName\x123\n\x05items\x18\x02\x20\x03(\x0b2\x1d.k8s.io.api.cor\
    e.v1.KeyToPathR\x05items\x12\x20\n\x0bdefaultMode\x18\x03\x20\x01(\x05R\
    \x0bdefaultMode\x12\x1a\n\x08optional\x18\x04\x20\x01(\x08R\x08optional\
    \"\xbd\x02\n\x0fSecurityContext\x12D\n\x0ccapabilities\x18\x01\x20\x01(\
    \x0b2\x20.k8s.io.api.core.v1.CapabilitiesR\x0ccapabilities\x12\x1e\n\npr\
    ivileged\x18\x02\x20\x01(\x08R\nprivileged\x12J\n\x0eseLinuxOptions\x18\
    \x03\x20\x01(\x0b2\".k8s.io.api.core.v1.SELinuxOptionsR\x0eseLinuxOption\
    s\x12\x1c\n\trunAsUser\x18\x04\x20\x01(\x03R\trunAsUser\x12\"\n\x0crunAs\
    NonRoot\x18\x05\x20\x01(\x08R\x0crunAsNonRoot\x126\n\x16readOnlyRootFile\
    system\x18\x06\x20\x01(\x08R\x16readOnlyRootFilesystem\"X\n\x13Serialize\
    dReference\x12A\n\treference\x18\x01\x20\x01(\x0b2#.k8s.io.api.core.v1.O\
    bjectReferenceR\treference\"\xc7\x01\n\x07Service\x12L\n\x08metadata\x18\
    \x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08\
    metadata\x123\n\x04spec\x18\x02\x20\x01(\x0b2\x1f.k8s.io.api.core.v1.Ser\
    viceSpecR\x04spec\x129\n\x06status\x18\x03\x20\x01(\x0b2!.k8s.io.api.cor\
    e.v1.ServiceStatusR\x06status\"\xb7\x02\n\x0eServiceAccount\x12L\n\x08me\
    tadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.Objec\
    tMetaR\x08metadata\x12=\n\x07secrets\x18\x02\x20\x03(\x0b2#.k8s.io.api.c\
    ore.v1.ObjectReferenceR\x07secrets\x12T\n\x10imagePullSecrets\x18\x03\
    \x20\x03(\x0b2(.k8s.io.api.core.v1.LocalObjectReferenceR\x10imagePullSec\
    rets\x12B\n\x1cautomountServiceAccountToken\x18\x04\x20\x01(\x08R\x1caut\
    omountServiceAccountToken\"\x9a\x01\n\x12ServiceAccountList\x12J\n\x08me\
    tadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListM\
    etaR\x08metadata\x128\n\x05items\x18\x02\x20\x03(\x0b2\".k8s.io.api.core\
    .v1.ServiceAccountR\x05items\"\x8c\x01\n\x0bServiceList\x12J\n\x08metada\
    ta\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\
    \x08metadata\x121\n\x05items\x18\x02\x20\x03(\x0b2\x1b.k8s.io.api.core.v\
    1.ServiceR\x05items\"\xbf\x01\n\x0bServicePort\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\x1a\n\x08protocol\x18\x02\x20\x01(\tR\x08protoc\
    ol\x12\x12\n\x04port\x18\x03\x20\x01(\x05R\x04port\x12P\n\ntargetPort\
    \x18\x04\x20\x01(\x0b20.k8s.io.apimachinery.pkg.util.intstr.IntOrStringR\
    \ntargetPort\x12\x1a\n\x08nodePort\x18\x05\x20\x01(\x05R\x08nodePort\")\
    \n\x13ServiceProxyOptions\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\
    \"\xba\x04\n\x0bServiceSpec\x125\n\x05ports\x18\x01\x20\x03(\x0b2\x1f.k8\
    s.io.api.core.v1.ServicePortR\x05ports\x12I\n\x08selector\x18\x02\x20\
    \x03(\x0b2-.k8s.io.api.core.v1.ServiceSpec.SelectorEntryR\x08selector\
    \x12\x1c\n\tclusterIP\x18\x03\x20\x01(\tR\tclusterIP\x12\x12\n\x04type\
    \x18\x04\x20\x01(\tR\x04type\x12\x20\n\x0bexternalIPs\x18\x05\x20\x03(\t\
    R\x0bexternalIPs\x12(\n\x0fsessionAffinity\x18\x07\x20\x01(\tR\x0fsessio\
    nAffinity\x12&\n\x0eloadBalancerIP\x18\x08\x20\x01(\tR\x0eloadBalancerIP\
    \x12:\n\x18loadBalancerSourceRanges\x18\t\x20\x03(\tR\x18loadBalancerSou\
    rceRanges\x12\"\n\x0cexternalName\x18\n\x20\x01(\tR\x0cexternalName\x124\
    \n\x15externalTrafficPolicy\x18\x0b\x20\x01(\tR\x15externalTrafficPolicy\
    \x120\n\x13healthCheckNodePort\x18\x0c\x20\x01(\x05R\x13healthCheckNodeP\
    ort\x1a;\n\rSelectorEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"[\n\rService\
    Status\x12J\n\x0cloadBalancer\x18\x01\x20\x01(\x0b2&.k8s.io.api.core.v1.\
    LoadBalancerStatusR\x0cloadBalancer\"\xe2\x01\n\x1fStorageOSPersistentVo\
    lumeSource\x12\x1e\n\nvolumeName\x18\x01\x20\x01(\tR\nvolumeName\x12(\n\
    \x0fvolumeNamespace\x18\x02\x20\x01(\tR\x0fvolumeNamespace\x12\x16\n\x06\
    fsType\x18\x03\x20\x01(\tR\x06fsType\x12\x1a\n\x08readOnly\x18\x04\x20\
    \x01(\x08R\x08readOnly\x12A\n\tsecretRef\x18\x05\x20\x01(\x0b2#.k8s.io.a\
    pi.core.v1.ObjectReferenceR\tsecretRef\"\xdd\x01\n\x15StorageOSVolumeSou\
    rce\x12\x1e\n\nvolumeName\x18\x01\x20\x01(\tR\nvolumeName\x12(\n\x0fvolu\
    meNamespace\x18\x02\x20\x01(\tR\x0fvolumeNamespace\x12\x16\n\x06fsType\
    \x18\x03\x20\x01(\tR\x06fsType\x12\x1a\n\x08readOnly\x18\x04\x20\x01(\
    \x08R\x08readOnly\x12F\n\tsecretRef\x18\x05\x20\x01(\x0b2(.k8s.io.api.co\
    re.v1.LocalObjectReferenceR\tsecretRef\"2\n\x06Sysctl\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05v\
    alue\"k\n\x0fTCPSocketAction\x12D\n\x04port\x18\x01\x20\x01(\x0b20.k8s.i\
    o.apimachinery.pkg.util.intstr.IntOrStringR\x04port\x12\x12\n\x04host\
    \x18\x02\x20\x01(\tR\x04host\"\x91\x01\n\x05Taint\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\
    \x12\x16\n\x06effect\x18\x03\x20\x01(\tR\x06effect\x12H\n\ttimeAdded\x18\
    \x04\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\ttimeAdde\
    d\"\x96\x01\n\nToleration\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x1a\n\x08operator\x18\x02\x20\x01(\tR\x08operator\x12\x14\n\x05valu\
    e\x18\x03\x20\x01(\tR\x05value\x12\x16\n\x06effect\x18\x04\x20\x01(\tR\
    \x06effect\x12,\n\x11tolerationSeconds\x18\x05\x20\x01(\x03R\x11tolerati\
    onSeconds\"b\n\x06Volume\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12D\n\x0cvolumeSource\x18\x02\x20\x01(\x0b2\x20.k8s.io.api.core.v1.Vol\
    umeSourceR\x0cvolumeSource\"u\n\x0bVolumeMount\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\x1a\n\x08readOnly\x18\x02\x20\x01(\x08R\x08read\
    Only\x12\x1c\n\tmountPath\x18\x03\x20\x01(\tR\tmountPath\x12\x18\n\x07su\
    bPath\x18\x04\x20\x01(\tR\x07subPath\"\xe4\x01\n\x10VolumeProjection\x12\
    <\n\x06secret\x18\x01\x20\x01(\x0b2$.k8s.io.api.core.v1.SecretProjection\
    R\x06secret\x12K\n\x0bdownwardAPI\x18\x02\x20\x01(\x0b2).k8s.io.api.core\
    .v1.DownwardAPIProjectionR\x0bdownwardAPI\x12E\n\tconfigMap\x18\x03\x20\
    \x01(\x0b2'.k8s.io.api.core.v1.ConfigMapProjectionR\tconfigMap\"\xde\x0f\
    \n\x0cVolumeSource\x12D\n\x08hostPath\x18\x01\x20\x01(\x0b2(.k8s.io.api.\
    core.v1.HostPathVolumeSourceR\x08hostPath\x12D\n\x08emptyDir\x18\x02\x20\
    \x01(\x0b2(.k8s.io.api.core.v1.EmptyDirVolumeSourceR\x08emptyDir\x12_\n\
    \x11gcePersistentDisk\x18\x03\x20\x01(\x0b21.k8s.io.api.core.v1.GCEPersi\
    stentDiskVolumeSourceR\x11gcePersistentDisk\x12h\n\x14awsElasticBlockSto\
    re\x18\x04\x20\x01(\x0b24.k8s.io.api.core.v1.AWSElasticBlockStoreVolumeS\
    ourceR\x14awsElasticBlockStore\x12A\n\x07gitRepo\x18\x05\x20\x01(\x0b2'.\
    k8s.io.api.core.v1.GitRepoVolumeSourceR\x07gitRepo\x12>\n\x06secret\x18\
    \x06\x20\x01(\x0b2&.k8s.io.api.core.v1.SecretVolumeSourceR\x06secret\x12\
    5\n\x03nfs\x18\x07\x20\x01(\x0b2#.k8s.io.api.core.v1.NFSVolumeSourceR\
    \x03nfs\x12;\n\x05iscsi\x18\x08\x20\x01(\x0b2%.k8s.io.api.core.v1.ISCSIV\
    olumeSourceR\x05iscsi\x12G\n\tglusterfs\x18\t\x20\x01(\x0b2).k8s.io.api.\
    core.v1.GlusterfsVolumeSourceR\tglusterfs\x12k\n\x15persistentVolumeClai\
    m\x18\n\x20\x01(\x0b25.k8s.io.api.core.v1.PersistentVolumeClaimVolumeSou\
    rceR\x15persistentVolumeClaim\x125\n\x03rbd\x18\x0b\x20\x01(\x0b2#.k8s.i\
    o.api.core.v1.RBDVolumeSourceR\x03rbd\x12D\n\nflexVolume\x18\x0c\x20\x01\
    (\x0b2$.k8s.io.api.core.v1.FlexVolumeSourceR\nflexVolume\x12>\n\x06cinde\
    r\x18\r\x20\x01(\x0b2&.k8s.io.api.core.v1.CinderVolumeSourceR\x06cinder\
    \x12>\n\x06cephfs\x18\x0e\x20\x01(\x0b2&.k8s.io.api.core.v1.CephFSVolume\
    SourceR\x06cephfs\x12A\n\x07flocker\x18\x0f\x20\x01(\x0b2'.k8s.io.api.co\
    re.v1.FlockerVolumeSourceR\x07flocker\x12M\n\x0bdownwardAPI\x18\x10\x20\
    \x01(\x0b2+.k8s.io.api.core.v1.DownwardAPIVolumeSourceR\x0bdownwardAPI\
    \x122\n\x02fc\x18\x11\x20\x01(\x0b2\".k8s.io.api.core.v1.FCVolumeSourceR\
    \x02fc\x12G\n\tazureFile\x18\x12\x20\x01(\x0b2).k8s.io.api.core.v1.Azure\
    FileVolumeSourceR\tazureFile\x12G\n\tconfigMap\x18\x13\x20\x01(\x0b2).k8\
    s.io.api.core.v1.ConfigMapVolumeSourceR\tconfigMap\x12X\n\rvsphereVolume\
    \x18\x14\x20\x01(\x0b22.k8s.io.api.core.v1.VsphereVirtualDiskVolumeSourc\
    eR\rvsphereVolume\x12A\n\x07quobyte\x18\x15\x20\x01(\x0b2'.k8s.io.api.co\
    re.v1.QuobyteVolumeSourceR\x07quobyte\x12G\n\tazureDisk\x18\x16\x20\x01(\
    \x0b2).k8s.io.api.core.v1.AzureDiskVolumeSourceR\tazureDisk\x12h\n\x14ph\
    otonPersistentDisk\x18\x17\x20\x01(\x0b24.k8s.io.api.core.v1.PhotonPersi\
    stentDiskVolumeSourceR\x14photonPersistentDisk\x12G\n\tprojected\x18\x1a\
    \x20\x01(\x0b2).k8s.io.api.core.v1.ProjectedVolumeSourceR\tprojected\x12\
    P\n\x0eportworxVolume\x18\x18\x20\x01(\x0b2(.k8s.io.api.core.v1.Portworx\
    VolumeSourceR\x0eportworxVolume\x12A\n\x07scaleIO\x18\x19\x20\x01(\x0b2'\
    .k8s.io.api.core.v1.ScaleIOVolumeSourceR\x07scaleIO\x12G\n\tstorageos\
    \x18\x1b\x20\x01(\x0b2).k8s.io.api.core.v1.StorageOSVolumeSourceR\tstora\
    geos\"\xb0\x01\n\x1eVsphereVirtualDiskVolumeSource\x12\x1e\n\nvolumePath\
    \x18\x01\x20\x01(\tR\nvolumePath\x12\x16\n\x06fsType\x18\x02\x20\x01(\tR\
    \x06fsType\x12,\n\x11storagePolicyName\x18\x03\x20\x01(\tR\x11storagePol\
    icyName\x12(\n\x0fstoragePolicyID\x18\x04\x20\x01(\tR\x0fstoragePolicyID\
    \"\x80\x01\n\x17WeightedPodAffinityTerm\x12\x16\n\x06weight\x18\x01\x20\
    \x01(\x05R\x06weight\x12M\n\x0fpodAffinityTerm\x18\x02\x20\x01(\x0b2#.k8\
    s.io.api.core.v1.PodAffinityTermR\x0fpodAffinityTermB\x04Z\x02v1\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
